{"version":3,"file":"generated.js","sourceRoot":"","sources":["../../../../src/utils/api/cartridge/generated.ts"],"names":[],"mappings":"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","sourcesContent":["import { useQuery, useMutation, UseQueryOptions, UseMutationOptions } from 'react-query';\nimport { useFetchData } from './fetcher';\nexport type Maybe<T> = T | null;\nexport type InputMaybe<T> = Maybe<T>;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\n  ID: string;\n  String: string;\n  Boolean: boolean;\n  Int: number;\n  Float: number;\n  BigInt: string;\n  ChainID: string;\n  Cursor: string;\n  Felt: string;\n  JSON: any;\n  Long: string;\n  Time: string;\n};\n\nexport type Account = Node & {\n  __typename?: 'Account';\n  activities: ActivityConnection;\n  controllers: ControllerConnection;\n  createdAt: Scalars['Time'];\n  credentials: Credentials;\n  credits: Credits;\n  creditsPlain: Scalars['Int'];\n  /** Optional email for account, required for slot billing and coinbase onramp */\n  email?: Maybe<Scalars['String']>;\n  id: Scalars['ID'];\n  membership: AccountTeamConnection;\n  name?: Maybe<Scalars['String']>;\n  /** Optional phone number, required for coinbase onramp */\n  phoneNumber?: Maybe<Scalars['String']>;\n  /** Timestamp of when the phone number was verified via OTP */\n  phoneNumberVerifiedAt?: Maybe<Scalars['String']>;\n  /** If true, the account is billed for paid slot deployments */\n  slotBilling: Scalars['Boolean'];\n  starterpackMint: StarterpackMintConnection;\n  teams: TeamConnection;\n  updatedAt: Scalars['Time'];\n  username: Scalars['String'];\n};\n\n\nexport type AccountActivitiesArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ActivityOrder>;\n  where?: InputMaybe<ActivityWhereInput>;\n};\n\n\nexport type AccountControllersArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ControllerOrder>;\n  where?: InputMaybe<ControllerWhereInput>;\n};\n\n\nexport type AccountMembershipArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<AccountTeamWhereInput>;\n};\n\n\nexport type AccountStarterpackMintArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<StarterpackMintOrder>;\n  where?: InputMaybe<StarterpackMintWhereInput>;\n};\n\n\nexport type AccountTeamsArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<TeamWhereInput>;\n};\n\n/** A connection to a list of items. */\nexport type AccountConnection = {\n  __typename?: 'AccountConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<AccountEdge>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type AccountEdge = {\n  __typename?: 'AccountEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['Cursor'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Account>;\n};\n\n/** Ordering options for Account connections */\nexport type AccountOrder = {\n  /** The ordering direction. */\n  direction?: OrderDirection;\n  /** The field by which to order Accounts. */\n  field: AccountOrderField;\n};\n\n/** Properties by which Account connections can be ordered. */\nexport enum AccountOrderField {\n  CreatedAt = 'CREATED_AT'\n}\n\nexport type AccountTeam = Node & {\n  __typename?: 'AccountTeam';\n  account: Account;\n  accountID: Scalars['ID'];\n  id: Scalars['ID'];\n  role: AccountTeamRole;\n  team: Team;\n  teamID: Scalars['ID'];\n};\n\n/** A connection to a list of items. */\nexport type AccountTeamConnection = {\n  __typename?: 'AccountTeamConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<AccountTeamEdge>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type AccountTeamEdge = {\n  __typename?: 'AccountTeamEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['Cursor'];\n  /** The item at the end of the edge. */\n  node?: Maybe<AccountTeam>;\n};\n\n/** AccountTeamRole is enum for the field role */\nexport enum AccountTeamRole {\n  Owner = 'owner'\n}\n\n/**\n * AccountTeamWhereInput is used for filtering AccountTeam objects.\n * Input was generated by ent.\n */\nexport type AccountTeamWhereInput = {\n  and?: InputMaybe<Array<AccountTeamWhereInput>>;\n  /** id field predicates */\n  id?: InputMaybe<Scalars['ID']>;\n  idContainsFold?: InputMaybe<Scalars['ID']>;\n  idEqualFold?: InputMaybe<Scalars['ID']>;\n  idGT?: InputMaybe<Scalars['ID']>;\n  idGTE?: InputMaybe<Scalars['ID']>;\n  idIn?: InputMaybe<Array<Scalars['ID']>>;\n  idLT?: InputMaybe<Scalars['ID']>;\n  idLTE?: InputMaybe<Scalars['ID']>;\n  idNEQ?: InputMaybe<Scalars['ID']>;\n  idNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  not?: InputMaybe<AccountTeamWhereInput>;\n  or?: InputMaybe<Array<AccountTeamWhereInput>>;\n  /** role field predicates */\n  role?: InputMaybe<AccountTeamRole>;\n  roleIn?: InputMaybe<Array<AccountTeamRole>>;\n  roleNEQ?: InputMaybe<AccountTeamRole>;\n  roleNotIn?: InputMaybe<Array<AccountTeamRole>>;\n};\n\nexport type AccountUpdateInput = {\n  /** Set the email for the account. */\n  email?: InputMaybe<Scalars['String']>;\n};\n\n/**\n * AccountWhereInput is used for filtering Account objects.\n * Input was generated by ent.\n */\nexport type AccountWhereInput = {\n  and?: InputMaybe<Array<AccountWhereInput>>;\n  /** created_at field predicates */\n  createdAt?: InputMaybe<Scalars['Time']>;\n  createdAtGT?: InputMaybe<Scalars['Time']>;\n  createdAtGTE?: InputMaybe<Scalars['Time']>;\n  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  createdAtLT?: InputMaybe<Scalars['Time']>;\n  createdAtLTE?: InputMaybe<Scalars['Time']>;\n  createdAtNEQ?: InputMaybe<Scalars['Time']>;\n  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n  /** email field predicates */\n  email?: InputMaybe<Scalars['String']>;\n  emailContains?: InputMaybe<Scalars['String']>;\n  emailContainsFold?: InputMaybe<Scalars['String']>;\n  emailEqualFold?: InputMaybe<Scalars['String']>;\n  emailGT?: InputMaybe<Scalars['String']>;\n  emailGTE?: InputMaybe<Scalars['String']>;\n  emailHasPrefix?: InputMaybe<Scalars['String']>;\n  emailHasSuffix?: InputMaybe<Scalars['String']>;\n  emailIn?: InputMaybe<Array<Scalars['String']>>;\n  emailIsNil?: InputMaybe<Scalars['Boolean']>;\n  emailLT?: InputMaybe<Scalars['String']>;\n  emailLTE?: InputMaybe<Scalars['String']>;\n  emailNEQ?: InputMaybe<Scalars['String']>;\n  emailNotIn?: InputMaybe<Array<Scalars['String']>>;\n  emailNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** activities edge predicates */\n  hasActivities?: InputMaybe<Scalars['Boolean']>;\n  hasActivitiesWith?: InputMaybe<Array<ActivityWhereInput>>;\n  /** controllers edge predicates */\n  hasControllers?: InputMaybe<Scalars['Boolean']>;\n  hasControllersWith?: InputMaybe<Array<ControllerWhereInput>>;\n  /** membership edge predicates */\n  hasMembership?: InputMaybe<Scalars['Boolean']>;\n  hasMembershipWith?: InputMaybe<Array<AccountTeamWhereInput>>;\n  /** starterpack_mint edge predicates */\n  hasStarterpackMint?: InputMaybe<Scalars['Boolean']>;\n  hasStarterpackMintWith?: InputMaybe<Array<StarterpackMintWhereInput>>;\n  /** teams edge predicates */\n  hasTeams?: InputMaybe<Scalars['Boolean']>;\n  hasTeamsWith?: InputMaybe<Array<TeamWhereInput>>;\n  /** id field predicates */\n  id?: InputMaybe<Scalars['ID']>;\n  idContainsFold?: InputMaybe<Scalars['ID']>;\n  idEqualFold?: InputMaybe<Scalars['ID']>;\n  idGT?: InputMaybe<Scalars['ID']>;\n  idGTE?: InputMaybe<Scalars['ID']>;\n  idIn?: InputMaybe<Array<Scalars['ID']>>;\n  idLT?: InputMaybe<Scalars['ID']>;\n  idLTE?: InputMaybe<Scalars['ID']>;\n  idNEQ?: InputMaybe<Scalars['ID']>;\n  idNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  /** name field predicates */\n  name?: InputMaybe<Scalars['String']>;\n  nameContains?: InputMaybe<Scalars['String']>;\n  nameContainsFold?: InputMaybe<Scalars['String']>;\n  nameEqualFold?: InputMaybe<Scalars['String']>;\n  nameGT?: InputMaybe<Scalars['String']>;\n  nameGTE?: InputMaybe<Scalars['String']>;\n  nameHasPrefix?: InputMaybe<Scalars['String']>;\n  nameHasSuffix?: InputMaybe<Scalars['String']>;\n  nameIn?: InputMaybe<Array<Scalars['String']>>;\n  nameIsNil?: InputMaybe<Scalars['Boolean']>;\n  nameLT?: InputMaybe<Scalars['String']>;\n  nameLTE?: InputMaybe<Scalars['String']>;\n  nameNEQ?: InputMaybe<Scalars['String']>;\n  nameNotIn?: InputMaybe<Array<Scalars['String']>>;\n  nameNotNil?: InputMaybe<Scalars['Boolean']>;\n  not?: InputMaybe<AccountWhereInput>;\n  or?: InputMaybe<Array<AccountWhereInput>>;\n  /** phone_number field predicates */\n  phoneNumber?: InputMaybe<Scalars['String']>;\n  phoneNumberContains?: InputMaybe<Scalars['String']>;\n  phoneNumberContainsFold?: InputMaybe<Scalars['String']>;\n  phoneNumberEqualFold?: InputMaybe<Scalars['String']>;\n  phoneNumberGT?: InputMaybe<Scalars['String']>;\n  phoneNumberGTE?: InputMaybe<Scalars['String']>;\n  phoneNumberHasPrefix?: InputMaybe<Scalars['String']>;\n  phoneNumberHasSuffix?: InputMaybe<Scalars['String']>;\n  phoneNumberIn?: InputMaybe<Array<Scalars['String']>>;\n  phoneNumberIsNil?: InputMaybe<Scalars['Boolean']>;\n  phoneNumberLT?: InputMaybe<Scalars['String']>;\n  phoneNumberLTE?: InputMaybe<Scalars['String']>;\n  phoneNumberNEQ?: InputMaybe<Scalars['String']>;\n  phoneNumberNotIn?: InputMaybe<Array<Scalars['String']>>;\n  phoneNumberNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** phone_number_verified_at field predicates */\n  phoneNumberVerifiedAt?: InputMaybe<Scalars['String']>;\n  phoneNumberVerifiedAtContains?: InputMaybe<Scalars['String']>;\n  phoneNumberVerifiedAtContainsFold?: InputMaybe<Scalars['String']>;\n  phoneNumberVerifiedAtEqualFold?: InputMaybe<Scalars['String']>;\n  phoneNumberVerifiedAtGT?: InputMaybe<Scalars['String']>;\n  phoneNumberVerifiedAtGTE?: InputMaybe<Scalars['String']>;\n  phoneNumberVerifiedAtHasPrefix?: InputMaybe<Scalars['String']>;\n  phoneNumberVerifiedAtHasSuffix?: InputMaybe<Scalars['String']>;\n  phoneNumberVerifiedAtIn?: InputMaybe<Array<Scalars['String']>>;\n  phoneNumberVerifiedAtIsNil?: InputMaybe<Scalars['Boolean']>;\n  phoneNumberVerifiedAtLT?: InputMaybe<Scalars['String']>;\n  phoneNumberVerifiedAtLTE?: InputMaybe<Scalars['String']>;\n  phoneNumberVerifiedAtNEQ?: InputMaybe<Scalars['String']>;\n  phoneNumberVerifiedAtNotIn?: InputMaybe<Array<Scalars['String']>>;\n  phoneNumberVerifiedAtNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** slot_billing field predicates */\n  slotBilling?: InputMaybe<Scalars['Boolean']>;\n  slotBillingNEQ?: InputMaybe<Scalars['Boolean']>;\n  /** updated_at field predicates */\n  updatedAt?: InputMaybe<Scalars['Time']>;\n  updatedAtGT?: InputMaybe<Scalars['Time']>;\n  updatedAtGTE?: InputMaybe<Scalars['Time']>;\n  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  updatedAtLT?: InputMaybe<Scalars['Time']>;\n  updatedAtLTE?: InputMaybe<Scalars['Time']>;\n  updatedAtNEQ?: InputMaybe<Scalars['Time']>;\n  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n  /** username field predicates */\n  username?: InputMaybe<Scalars['String']>;\n  usernameContains?: InputMaybe<Scalars['String']>;\n  usernameContainsFold?: InputMaybe<Scalars['String']>;\n  usernameEqualFold?: InputMaybe<Scalars['String']>;\n  usernameGT?: InputMaybe<Scalars['String']>;\n  usernameGTE?: InputMaybe<Scalars['String']>;\n  usernameHasPrefix?: InputMaybe<Scalars['String']>;\n  usernameHasSuffix?: InputMaybe<Scalars['String']>;\n  usernameIn?: InputMaybe<Array<Scalars['String']>>;\n  usernameLT?: InputMaybe<Scalars['String']>;\n  usernameLTE?: InputMaybe<Scalars['String']>;\n  usernameNEQ?: InputMaybe<Scalars['String']>;\n  usernameNotIn?: InputMaybe<Array<Scalars['String']>>;\n};\n\nexport type Achievement = {\n  __typename?: 'Achievement';\n  /** Hexadecimal string, e.g., \"0x427261776c6572\" */\n  achievementGroup: Scalars['String'];\n  /** Can be an empty string */\n  data?: Maybe<Scalars['String']>;\n  /** A description of the achievement */\n  description: Scalars['String'];\n  /** Hexadecimal string, can be \"0x\" */\n  end: Scalars['String'];\n  /** Integer, e.g., 0 (possibly a boolean indicator) */\n  hidden: Scalars['Int'];\n  /** Hexadecimal string, e.g., \"0x66612d706572736f6e2d7269666c65\" */\n  icon: Scalars['String'];\n  /** Hexadecimal string, unique identifier */\n  id: Scalars['String'];\n  /** Integer, e.g., 0 (could represent a section or chapter) */\n  page: Scalars['Int'];\n  /** Integer, e.g., 80 */\n  points: Scalars['Int'];\n  /** Hexadecimal string, can be \"0x\" */\n  start: Scalars['String'];\n  /** Description of the task, e.g., \"Defeat a Big Boss\" */\n  taskDescription: Scalars['String'];\n  /** Hexadecimal string, e.g., \"0x425241574c455247\" */\n  taskId: Scalars['String'];\n  /** Integer, e.g., 1 (total tasks to complete) */\n  taskTotal: Scalars['Int'];\n  /** Hexadecimal string, e.g., \"0x427261776c6572\" */\n  title: Scalars['String'];\n};\n\nexport type AchievementItem = {\n  __typename?: 'AchievementItem';\n  achievements: Array<Achievement>;\n  meta: AchievementMeta;\n};\n\nexport type AchievementMeta = {\n  __typename?: 'AchievementMeta';\n  count: Scalars['Int'];\n  error?: Maybe<Scalars['String']>;\n  model: Scalars['String'];\n  namespace: Scalars['String'];\n  project: Scalars['String'];\n};\n\nexport type AchievementResult = {\n  __typename?: 'AchievementResult';\n  items: Array<AchievementItem>;\n};\n\nexport type Activity = Node & {\n  __typename?: 'Activity';\n  account: Account;\n  accountID: Scalars['ID'];\n  /** Actual fee for the activity */\n  actualFee?: Maybe<Scalars['BigInt']>;\n  controller?: Maybe<Controller>;\n  controllerID?: Maybe<Scalars['ID']>;\n  createdAt: Scalars['Time'];\n  /** Credits fee for the activity */\n  creditsFee?: Maybe<Scalars['Int']>;\n  /** Transaction fee payment source */\n  feeSource: ActivityFeeSource;\n  /** Fee unit for the activity */\n  feeUnit: ActivityFeeUnit;\n  id: Scalars['ID'];\n  /** Blockchain network if applicable */\n  network?: Maybe<Scalars['String']>;\n  paymaster?: Maybe<Paymaster>;\n  paymasterID?: Maybe<Scalars['ID']>;\n  session?: Maybe<Session>;\n  sessionID?: Maybe<Scalars['ID']>;\n  starterpackMint: StarterpackMintConnection;\n  /** Status of the activity */\n  status: ActivityStatus;\n  /** Transaction hash if this is a blockchain transaction */\n  transactionHash?: Maybe<Scalars['String']>;\n  /** Type of activity */\n  type: ActivityType;\n  updatedAt: Scalars['Time'];\n};\n\n\nexport type ActivityStarterpackMintArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<StarterpackMintOrder>;\n  where?: InputMaybe<StarterpackMintWhereInput>;\n};\n\n/** A connection to a list of items. */\nexport type ActivityConnection = {\n  __typename?: 'ActivityConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ActivityEdge>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type ActivityEdge = {\n  __typename?: 'ActivityEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['Cursor'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Activity>;\n};\n\nexport type ActivityEntry = {\n  __typename?: 'ActivityEntry';\n  callerAddress: Scalars['String'];\n  contractAddress: Scalars['String'];\n  entrypoint: Scalars['String'];\n  executedAt: Scalars['String'];\n  transactionHash: Scalars['String'];\n};\n\n/** ActivityFeeSource is enum for the field fee_source */\nexport enum ActivityFeeSource {\n  Account = 'ACCOUNT',\n  Credits = 'CREDITS',\n  Paymaster = 'PAYMASTER'\n}\n\n/** ActivityFeeUnit is enum for the field fee_unit */\nexport enum ActivityFeeUnit {\n  Fri = 'FRI',\n  Wei = 'WEI'\n}\n\nexport type ActivityItem = {\n  __typename?: 'ActivityItem';\n  activities: Array<ActivityEntry>;\n  meta: ActivityMeta;\n};\n\nexport type ActivityMeta = {\n  __typename?: 'ActivityMeta';\n  address: Scalars['String'];\n  count: Scalars['Int'];\n  error?: Maybe<Scalars['String']>;\n  limit: Scalars['Int'];\n  project: Scalars['String'];\n};\n\n/** Ordering options for Activity connections */\nexport type ActivityOrder = {\n  /** The ordering direction. */\n  direction?: OrderDirection;\n  /** The field by which to order Activities. */\n  field: ActivityOrderField;\n};\n\n/** Properties by which Activity connections can be ordered. */\nexport enum ActivityOrderField {\n  CreatedAt = 'CREATED_AT'\n}\n\nexport type ActivityProject = {\n  address: Scalars['String'];\n  limit: Scalars['Int'];\n  project: Scalars['String'];\n};\n\nexport type ActivityResult = {\n  __typename?: 'ActivityResult';\n  items: Array<ActivityItem>;\n};\n\n/** ActivityStatus is enum for the field status */\nexport enum ActivityStatus {\n  Completed = 'COMPLETED',\n  Failed = 'FAILED',\n  Pending = 'PENDING',\n  PendingBacklog = 'PENDING_BACKLOG',\n  TimedOut = 'TIMED_OUT'\n}\n\n/** ActivityType is enum for the field type */\nexport enum ActivityType {\n  SessionCreated = 'SESSION_CREATED',\n  Transaction = 'TRANSACTION'\n}\n\n/**\n * ActivityWhereInput is used for filtering Activity objects.\n * Input was generated by ent.\n */\nexport type ActivityWhereInput = {\n  /** account_id field predicates */\n  accountID?: InputMaybe<Scalars['ID']>;\n  accountIDContains?: InputMaybe<Scalars['ID']>;\n  accountIDContainsFold?: InputMaybe<Scalars['ID']>;\n  accountIDEqualFold?: InputMaybe<Scalars['ID']>;\n  accountIDGT?: InputMaybe<Scalars['ID']>;\n  accountIDGTE?: InputMaybe<Scalars['ID']>;\n  accountIDHasPrefix?: InputMaybe<Scalars['ID']>;\n  accountIDHasSuffix?: InputMaybe<Scalars['ID']>;\n  accountIDIn?: InputMaybe<Array<Scalars['ID']>>;\n  accountIDLT?: InputMaybe<Scalars['ID']>;\n  accountIDLTE?: InputMaybe<Scalars['ID']>;\n  accountIDNEQ?: InputMaybe<Scalars['ID']>;\n  accountIDNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  /** actual_fee field predicates */\n  actualFee?: InputMaybe<Scalars['BigInt']>;\n  actualFeeGT?: InputMaybe<Scalars['BigInt']>;\n  actualFeeGTE?: InputMaybe<Scalars['BigInt']>;\n  actualFeeIn?: InputMaybe<Array<Scalars['BigInt']>>;\n  actualFeeIsNil?: InputMaybe<Scalars['Boolean']>;\n  actualFeeLT?: InputMaybe<Scalars['BigInt']>;\n  actualFeeLTE?: InputMaybe<Scalars['BigInt']>;\n  actualFeeNEQ?: InputMaybe<Scalars['BigInt']>;\n  actualFeeNotIn?: InputMaybe<Array<Scalars['BigInt']>>;\n  actualFeeNotNil?: InputMaybe<Scalars['Boolean']>;\n  and?: InputMaybe<Array<ActivityWhereInput>>;\n  /** controller_id field predicates */\n  controllerID?: InputMaybe<Scalars['ID']>;\n  controllerIDContains?: InputMaybe<Scalars['ID']>;\n  controllerIDContainsFold?: InputMaybe<Scalars['ID']>;\n  controllerIDEqualFold?: InputMaybe<Scalars['ID']>;\n  controllerIDGT?: InputMaybe<Scalars['ID']>;\n  controllerIDGTE?: InputMaybe<Scalars['ID']>;\n  controllerIDHasPrefix?: InputMaybe<Scalars['ID']>;\n  controllerIDHasSuffix?: InputMaybe<Scalars['ID']>;\n  controllerIDIn?: InputMaybe<Array<Scalars['ID']>>;\n  controllerIDIsNil?: InputMaybe<Scalars['Boolean']>;\n  controllerIDLT?: InputMaybe<Scalars['ID']>;\n  controllerIDLTE?: InputMaybe<Scalars['ID']>;\n  controllerIDNEQ?: InputMaybe<Scalars['ID']>;\n  controllerIDNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  controllerIDNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** created_at field predicates */\n  createdAt?: InputMaybe<Scalars['Time']>;\n  createdAtGT?: InputMaybe<Scalars['Time']>;\n  createdAtGTE?: InputMaybe<Scalars['Time']>;\n  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  createdAtLT?: InputMaybe<Scalars['Time']>;\n  createdAtLTE?: InputMaybe<Scalars['Time']>;\n  createdAtNEQ?: InputMaybe<Scalars['Time']>;\n  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n  /** credits_fee field predicates */\n  creditsFee?: InputMaybe<Scalars['Int']>;\n  creditsFeeGT?: InputMaybe<Scalars['Int']>;\n  creditsFeeGTE?: InputMaybe<Scalars['Int']>;\n  creditsFeeIn?: InputMaybe<Array<Scalars['Int']>>;\n  creditsFeeIsNil?: InputMaybe<Scalars['Boolean']>;\n  creditsFeeLT?: InputMaybe<Scalars['Int']>;\n  creditsFeeLTE?: InputMaybe<Scalars['Int']>;\n  creditsFeeNEQ?: InputMaybe<Scalars['Int']>;\n  creditsFeeNotIn?: InputMaybe<Array<Scalars['Int']>>;\n  creditsFeeNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** fee_source field predicates */\n  feeSource?: InputMaybe<ActivityFeeSource>;\n  feeSourceIn?: InputMaybe<Array<ActivityFeeSource>>;\n  feeSourceNEQ?: InputMaybe<ActivityFeeSource>;\n  feeSourceNotIn?: InputMaybe<Array<ActivityFeeSource>>;\n  /** fee_unit field predicates */\n  feeUnit?: InputMaybe<ActivityFeeUnit>;\n  feeUnitIn?: InputMaybe<Array<ActivityFeeUnit>>;\n  feeUnitNEQ?: InputMaybe<ActivityFeeUnit>;\n  feeUnitNotIn?: InputMaybe<Array<ActivityFeeUnit>>;\n  /** account edge predicates */\n  hasAccount?: InputMaybe<Scalars['Boolean']>;\n  hasAccountWith?: InputMaybe<Array<AccountWhereInput>>;\n  /** controller edge predicates */\n  hasController?: InputMaybe<Scalars['Boolean']>;\n  hasControllerWith?: InputMaybe<Array<ControllerWhereInput>>;\n  /** paymaster edge predicates */\n  hasPaymaster?: InputMaybe<Scalars['Boolean']>;\n  hasPaymasterWith?: InputMaybe<Array<PaymasterWhereInput>>;\n  /** session edge predicates */\n  hasSession?: InputMaybe<Scalars['Boolean']>;\n  hasSessionWith?: InputMaybe<Array<SessionWhereInput>>;\n  /** starterpack_mint edge predicates */\n  hasStarterpackMint?: InputMaybe<Scalars['Boolean']>;\n  hasStarterpackMintWith?: InputMaybe<Array<StarterpackMintWhereInput>>;\n  /** id field predicates */\n  id?: InputMaybe<Scalars['ID']>;\n  idContainsFold?: InputMaybe<Scalars['ID']>;\n  idEqualFold?: InputMaybe<Scalars['ID']>;\n  idGT?: InputMaybe<Scalars['ID']>;\n  idGTE?: InputMaybe<Scalars['ID']>;\n  idIn?: InputMaybe<Array<Scalars['ID']>>;\n  idLT?: InputMaybe<Scalars['ID']>;\n  idLTE?: InputMaybe<Scalars['ID']>;\n  idNEQ?: InputMaybe<Scalars['ID']>;\n  idNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  /** network field predicates */\n  network?: InputMaybe<Scalars['String']>;\n  networkContains?: InputMaybe<Scalars['String']>;\n  networkContainsFold?: InputMaybe<Scalars['String']>;\n  networkEqualFold?: InputMaybe<Scalars['String']>;\n  networkGT?: InputMaybe<Scalars['String']>;\n  networkGTE?: InputMaybe<Scalars['String']>;\n  networkHasPrefix?: InputMaybe<Scalars['String']>;\n  networkHasSuffix?: InputMaybe<Scalars['String']>;\n  networkIn?: InputMaybe<Array<Scalars['String']>>;\n  networkIsNil?: InputMaybe<Scalars['Boolean']>;\n  networkLT?: InputMaybe<Scalars['String']>;\n  networkLTE?: InputMaybe<Scalars['String']>;\n  networkNEQ?: InputMaybe<Scalars['String']>;\n  networkNotIn?: InputMaybe<Array<Scalars['String']>>;\n  networkNotNil?: InputMaybe<Scalars['Boolean']>;\n  not?: InputMaybe<ActivityWhereInput>;\n  or?: InputMaybe<Array<ActivityWhereInput>>;\n  /** paymaster_id field predicates */\n  paymasterID?: InputMaybe<Scalars['ID']>;\n  paymasterIDContains?: InputMaybe<Scalars['ID']>;\n  paymasterIDContainsFold?: InputMaybe<Scalars['ID']>;\n  paymasterIDEqualFold?: InputMaybe<Scalars['ID']>;\n  paymasterIDGT?: InputMaybe<Scalars['ID']>;\n  paymasterIDGTE?: InputMaybe<Scalars['ID']>;\n  paymasterIDHasPrefix?: InputMaybe<Scalars['ID']>;\n  paymasterIDHasSuffix?: InputMaybe<Scalars['ID']>;\n  paymasterIDIn?: InputMaybe<Array<Scalars['ID']>>;\n  paymasterIDIsNil?: InputMaybe<Scalars['Boolean']>;\n  paymasterIDLT?: InputMaybe<Scalars['ID']>;\n  paymasterIDLTE?: InputMaybe<Scalars['ID']>;\n  paymasterIDNEQ?: InputMaybe<Scalars['ID']>;\n  paymasterIDNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  paymasterIDNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** session_id field predicates */\n  sessionID?: InputMaybe<Scalars['ID']>;\n  sessionIDContains?: InputMaybe<Scalars['ID']>;\n  sessionIDContainsFold?: InputMaybe<Scalars['ID']>;\n  sessionIDEqualFold?: InputMaybe<Scalars['ID']>;\n  sessionIDGT?: InputMaybe<Scalars['ID']>;\n  sessionIDGTE?: InputMaybe<Scalars['ID']>;\n  sessionIDHasPrefix?: InputMaybe<Scalars['ID']>;\n  sessionIDHasSuffix?: InputMaybe<Scalars['ID']>;\n  sessionIDIn?: InputMaybe<Array<Scalars['ID']>>;\n  sessionIDIsNil?: InputMaybe<Scalars['Boolean']>;\n  sessionIDLT?: InputMaybe<Scalars['ID']>;\n  sessionIDLTE?: InputMaybe<Scalars['ID']>;\n  sessionIDNEQ?: InputMaybe<Scalars['ID']>;\n  sessionIDNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  sessionIDNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** status field predicates */\n  status?: InputMaybe<ActivityStatus>;\n  statusIn?: InputMaybe<Array<ActivityStatus>>;\n  statusNEQ?: InputMaybe<ActivityStatus>;\n  statusNotIn?: InputMaybe<Array<ActivityStatus>>;\n  /** transaction_hash field predicates */\n  transactionHash?: InputMaybe<Scalars['String']>;\n  transactionHashContains?: InputMaybe<Scalars['String']>;\n  transactionHashContainsFold?: InputMaybe<Scalars['String']>;\n  transactionHashEqualFold?: InputMaybe<Scalars['String']>;\n  transactionHashGT?: InputMaybe<Scalars['String']>;\n  transactionHashGTE?: InputMaybe<Scalars['String']>;\n  transactionHashHasPrefix?: InputMaybe<Scalars['String']>;\n  transactionHashHasSuffix?: InputMaybe<Scalars['String']>;\n  transactionHashIn?: InputMaybe<Array<Scalars['String']>>;\n  transactionHashIsNil?: InputMaybe<Scalars['Boolean']>;\n  transactionHashLT?: InputMaybe<Scalars['String']>;\n  transactionHashLTE?: InputMaybe<Scalars['String']>;\n  transactionHashNEQ?: InputMaybe<Scalars['String']>;\n  transactionHashNotIn?: InputMaybe<Array<Scalars['String']>>;\n  transactionHashNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** type field predicates */\n  type?: InputMaybe<ActivityType>;\n  typeIn?: InputMaybe<Array<ActivityType>>;\n  typeNEQ?: InputMaybe<ActivityType>;\n  typeNotIn?: InputMaybe<Array<ActivityType>>;\n  /** updated_at field predicates */\n  updatedAt?: InputMaybe<Scalars['Time']>;\n  updatedAtGT?: InputMaybe<Scalars['Time']>;\n  updatedAtGTE?: InputMaybe<Scalars['Time']>;\n  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  updatedAtLT?: InputMaybe<Scalars['Time']>;\n  updatedAtLTE?: InputMaybe<Scalars['Time']>;\n  updatedAtNEQ?: InputMaybe<Scalars['Time']>;\n  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n};\n\nexport type AssetEdge = {\n  __typename?: 'AssetEdge';\n  amount: Scalars['Float'];\n  attributes?: Maybe<Scalars['String']>;\n  description?: Maybe<Scalars['String']>;\n  imageUrl: Scalars['String'];\n  metadata?: Maybe<Scalars['String']>;\n  name: Scalars['String'];\n  raw: Scalars['String'];\n  tokenId: Scalars['String'];\n};\n\nexport type Balance = {\n  __typename?: 'Balance';\n  amount: Scalars['Float'];\n  meta: Erc20Metadata;\n  raw: Scalars['String'];\n  value: Scalars['Float'];\n};\n\nexport type BalanceConnection = {\n  __typename?: 'BalanceConnection';\n  edges: Array<BalanceEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type BalanceEdge = {\n  __typename?: 'BalanceEdge';\n  cursor: Scalars['Cursor'];\n  node: Balance;\n};\n\nexport type CoinbaseAmount = {\n  __typename?: 'CoinbaseAmount';\n  /** The amount value as a string. */\n  amount: Scalars['String'];\n  /** The currency code (e.g., \"USD\", \"USDC\"). */\n  currency: Scalars['String'];\n};\n\nexport enum CoinbaseNetwork {\n  Arbitrum = 'ARBITRUM',\n  Base = 'BASE',\n  Ethereum = 'ETHEREUM',\n  Optimism = 'OPTIMISM',\n  Polygon = 'POLYGON',\n  Solana = 'SOLANA'\n}\n\nexport type CoinbaseOnrampFee = {\n  __typename?: 'CoinbaseOnrampFee';\n  /** The fee amount. */\n  amount: Scalars['String'];\n  /** The currency of the fee. */\n  currency: Scalars['String'];\n  /** The type of fee (FEE_TYPE_NETWORK or FEE_TYPE_EXCHANGE). */\n  type: Scalars['String'];\n};\n\nexport type CoinbaseOnrampOrder = {\n  __typename?: 'CoinbaseOnrampOrder';\n  /** When the order was created. */\n  createdAt: Scalars['Time'];\n  /** The destination address for the crypto. */\n  destinationAddress: Scalars['String'];\n  /** The destination network. */\n  destinationNetwork: Scalars['String'];\n  /** The exchange rate used for the conversion. */\n  exchangeRate: Scalars['String'];\n  /** Fees associated with the order. */\n  fees: Array<CoinbaseOnrampFee>;\n  /** The unique order ID. */\n  orderId: Scalars['String'];\n  /** The fiat currency used for payment. */\n  paymentCurrency: Scalars['String'];\n  /**\n   * The payment link URL for Apple Pay checkout.\n   * Append &useApplePaySandbox=true for testing on localhost.\n   */\n  paymentLink: Scalars['String'];\n  /** The type of payment link. */\n  paymentLinkType: Scalars['String'];\n  /** Payment amount before fees. */\n  paymentSubtotal: Scalars['String'];\n  /** Total payment amount including fees. */\n  paymentTotal: Scalars['String'];\n  /** The amount of crypto to be purchased. */\n  purchaseAmount: Scalars['String'];\n  /** The crypto currency being purchased (always USDC). */\n  purchaseCurrency: Scalars['String'];\n  /** Current status of the order. */\n  status: CoinbaseOnrampStatus;\n  /** Transaction hash (only available after crypto is sent). */\n  txHash?: Maybe<Scalars['String']>;\n  /** When the order was last updated. */\n  updatedAt: Scalars['Time'];\n};\n\nexport type CoinbaseOnrampQuote = {\n  __typename?: 'CoinbaseOnrampQuote';\n  /** Fee charged by Coinbase. */\n  coinbaseFee: CoinbaseAmount;\n  /** Network fee for sending the crypto. */\n  networkFee: CoinbaseAmount;\n  /** Ready-to-use one-click-buy URL. Only returned when destinationAddress is provided. */\n  onrampUrl?: Maybe<Scalars['String']>;\n  /** Payment amount before fees (cost of crypto). */\n  paymentSubtotal: CoinbaseAmount;\n  /** Total payment amount including fees. */\n  paymentTotal: CoinbaseAmount;\n  /** The amount of crypto to be purchased. */\n  purchaseAmount: CoinbaseAmount;\n  /** Quote ID that can be used when launching the Coinbase Onramp widget. */\n  quoteId: Scalars['String'];\n};\n\nexport type CoinbaseOnrampQuoteInput = {\n  /** The client's IP address. Required by Coinbase for compliance. */\n  clientIP: Scalars['String'];\n  /** ISO 3166-1 two-digit country code (e.g., \"US\"). */\n  country: Scalars['String'];\n  /** Optional destination wallet address. If provided, the response will include a one-click-buy URL. */\n  destinationAddress?: InputMaybe<Scalars['String']>;\n  /** The destination network for the USDC purchase. */\n  destinationNetwork: CoinbaseNetwork;\n  /** The amount of fiat currency to pay (e.g., \"100.00\" for $100 USD). */\n  paymentAmount: Scalars['String'];\n  /** The fiat currency to pay with (e.g., \"USD\"). */\n  paymentCurrency: Scalars['String'];\n  /** ISO 3166-2 subdivision code (e.g., \"NY\"). Required for US users. */\n  subdivision?: InputMaybe<Scalars['String']>;\n};\n\n/** Indicates what user information is required for Coinbase onramp. */\nexport type CoinbaseOnrampRequirements = {\n  __typename?: 'CoinbaseOnrampRequirements';\n  /** True if the user needs to provide an email address. */\n  needsEmail: Scalars['Boolean'];\n  /** True if the user needs to provide a valid US phone number. */\n  needsPhoneNumber: Scalars['Boolean'];\n  /** True if the user's phone number needs to be (re)verified. */\n  needsPhoneVerification: Scalars['Boolean'];\n};\n\nexport type CoinbaseOnrampSession = {\n  __typename?: 'CoinbaseOnrampSession';\n  /** The single-use Coinbase onramp URL. This URL can only be used once. */\n  onrampUrl: Scalars['String'];\n  /** The session token (for reference, already embedded in the URL). */\n  sessionToken: Scalars['String'];\n};\n\nexport enum CoinbaseOnrampStatus {\n  Completed = 'COMPLETED',\n  Failed = 'FAILED',\n  PendingAuth = 'PENDING_AUTH',\n  PendingPayment = 'PENDING_PAYMENT',\n  Processing = 'PROCESSING'\n}\n\nexport type CoinbaseTransaction = {\n  __typename?: 'CoinbaseTransaction';\n  /** Coinbase fee amount. */\n  coinbaseFee: CoinbaseAmount;\n  /** Country of the user. */\n  country: Scalars['String'];\n  /** When the transaction was created. */\n  createdAt: Scalars['String'];\n  /** Exchange rate for the transaction. */\n  exchangeRate: CoinbaseAmount;\n  /** Network fee amount. */\n  networkFee: CoinbaseAmount;\n  /** Payment method used. */\n  paymentMethod: Scalars['String'];\n  /** Fiat payment amount before fees. */\n  paymentSubtotal: CoinbaseAmount;\n  /** Total fiat payment amount. */\n  paymentTotal: CoinbaseAmount;\n  /** Amount of crypto being purchased. */\n  purchaseAmount: CoinbaseAmount;\n  /** Crypto currency being purchased. */\n  purchaseCurrency: Scalars['String'];\n  /** Network used to deliver crypto. */\n  purchaseNetwork: Scalars['String'];\n  /** Status of the transaction. */\n  status: CoinbaseTransactionStatus;\n  /** Unique identifier for the transaction. */\n  transactionId: Scalars['String'];\n  /** Transaction hash on the blockchain. */\n  txHash?: Maybe<Scalars['String']>;\n  /** Type of transaction. */\n  type?: Maybe<Scalars['String']>;\n  /** Wallet address the transaction was sent to. */\n  walletAddress?: Maybe<Scalars['String']>;\n};\n\nexport enum CoinbaseTransactionStatus {\n  Failed = 'FAILED',\n  InProgress = 'IN_PROGRESS',\n  Success = 'SUCCESS'\n}\n\nexport type CoinbaseTransactionsInput = {\n  /** Reference to the next page of transactions (from previous response). */\n  pageKey?: InputMaybe<Scalars['String']>;\n  /** Number of transactions to return per page. Default is 1. */\n  pageSize?: InputMaybe<Scalars['Int']>;\n  /**\n   * The partner user reference ID to get transactions for.\n   * This should match the partnerUserRef used when creating orders.\n   */\n  partnerUserRef: Scalars['String'];\n  /** If true, prepend \"sandbox-\" to partnerUserRef to query sandbox transactions. */\n  sandbox?: InputMaybe<Scalars['Boolean']>;\n};\n\nexport type CoinbaseTransactionsResponse = {\n  __typename?: 'CoinbaseTransactionsResponse';\n  /** Reference to the next page of transactions. */\n  nextPageKey?: Maybe<Scalars['String']>;\n  /** Total number of transactions for this user. */\n  totalCount?: Maybe<Scalars['String']>;\n  /** List of transactions in reverse chronological order. */\n  transactions: Array<CoinbaseTransaction>;\n};\n\nexport type Collectible = {\n  __typename?: 'Collectible';\n  assets: Array<AssetEdge>;\n  meta: Erc1155Metadata;\n};\n\nexport type CollectibleConnection = {\n  __typename?: 'CollectibleConnection';\n  edges: Array<CollectibleEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type CollectibleEdge = {\n  __typename?: 'CollectibleEdge';\n  cursor: Scalars['Cursor'];\n  node: Collectible;\n};\n\nexport type Collection = {\n  __typename?: 'Collection';\n  assets: Array<AssetEdge>;\n  meta: Erc721Metadata;\n};\n\nexport type CollectionConnection = {\n  __typename?: 'CollectionConnection';\n  edges: Array<CollectionEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type CollectionEdge = {\n  __typename?: 'CollectionEdge';\n  cursor: Scalars['Cursor'];\n  node: Collection;\n};\n\nexport type Controller = Node & {\n  __typename?: 'Controller';\n  account: Account;\n  accountID: Scalars['ID'];\n  activities: ActivityConnection;\n  address: Scalars['String'];\n  constructorCalldata: Array<Scalars['String']>;\n  createdAt: Scalars['Time'];\n  id: Scalars['ID'];\n  network: Scalars['String'];\n  sessions?: Maybe<Array<Session>>;\n  signers?: Maybe<Array<Signer>>;\n  updatedAt: Scalars['Time'];\n};\n\n\nexport type ControllerActivitiesArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ActivityOrder>;\n  where?: InputMaybe<ActivityWhereInput>;\n};\n\n/** A connection to a list of items. */\nexport type ControllerConnection = {\n  __typename?: 'ControllerConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ControllerEdge>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type ControllerEdge = {\n  __typename?: 'ControllerEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['Cursor'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Controller>;\n};\n\n/** Ordering options for Controller connections */\nexport type ControllerOrder = {\n  /** The ordering direction. */\n  direction?: OrderDirection;\n  /** The field by which to order Controllers. */\n  field: ControllerOrderField;\n};\n\n/** Properties by which Controller connections can be ordered. */\nexport enum ControllerOrderField {\n  CreatedAt = 'CREATED_AT'\n}\n\n/**\n * ControllerWhereInput is used for filtering Controller objects.\n * Input was generated by ent.\n */\nexport type ControllerWhereInput = {\n  /** account_id field predicates */\n  accountID?: InputMaybe<Scalars['ID']>;\n  accountIDContains?: InputMaybe<Scalars['ID']>;\n  accountIDContainsFold?: InputMaybe<Scalars['ID']>;\n  accountIDEqualFold?: InputMaybe<Scalars['ID']>;\n  accountIDGT?: InputMaybe<Scalars['ID']>;\n  accountIDGTE?: InputMaybe<Scalars['ID']>;\n  accountIDHasPrefix?: InputMaybe<Scalars['ID']>;\n  accountIDHasSuffix?: InputMaybe<Scalars['ID']>;\n  accountIDIn?: InputMaybe<Array<Scalars['ID']>>;\n  accountIDLT?: InputMaybe<Scalars['ID']>;\n  accountIDLTE?: InputMaybe<Scalars['ID']>;\n  accountIDNEQ?: InputMaybe<Scalars['ID']>;\n  accountIDNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  /** address field predicates */\n  address?: InputMaybe<Scalars['String']>;\n  addressContains?: InputMaybe<Scalars['String']>;\n  addressContainsFold?: InputMaybe<Scalars['String']>;\n  addressEqualFold?: InputMaybe<Scalars['String']>;\n  addressGT?: InputMaybe<Scalars['String']>;\n  addressGTE?: InputMaybe<Scalars['String']>;\n  addressHasPrefix?: InputMaybe<Scalars['String']>;\n  addressHasSuffix?: InputMaybe<Scalars['String']>;\n  addressIn?: InputMaybe<Array<Scalars['String']>>;\n  addressLT?: InputMaybe<Scalars['String']>;\n  addressLTE?: InputMaybe<Scalars['String']>;\n  addressNEQ?: InputMaybe<Scalars['String']>;\n  addressNotIn?: InputMaybe<Array<Scalars['String']>>;\n  and?: InputMaybe<Array<ControllerWhereInput>>;\n  /** created_at field predicates */\n  createdAt?: InputMaybe<Scalars['Time']>;\n  createdAtGT?: InputMaybe<Scalars['Time']>;\n  createdAtGTE?: InputMaybe<Scalars['Time']>;\n  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  createdAtLT?: InputMaybe<Scalars['Time']>;\n  createdAtLTE?: InputMaybe<Scalars['Time']>;\n  createdAtNEQ?: InputMaybe<Scalars['Time']>;\n  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n  /** account edge predicates */\n  hasAccount?: InputMaybe<Scalars['Boolean']>;\n  hasAccountWith?: InputMaybe<Array<AccountWhereInput>>;\n  /** activities edge predicates */\n  hasActivities?: InputMaybe<Scalars['Boolean']>;\n  hasActivitiesWith?: InputMaybe<Array<ActivityWhereInput>>;\n  /** sessions edge predicates */\n  hasSessions?: InputMaybe<Scalars['Boolean']>;\n  hasSessionsWith?: InputMaybe<Array<SessionWhereInput>>;\n  /** signers edge predicates */\n  hasSigners?: InputMaybe<Scalars['Boolean']>;\n  hasSignersWith?: InputMaybe<Array<SignerWhereInput>>;\n  /** id field predicates */\n  id?: InputMaybe<Scalars['ID']>;\n  idContainsFold?: InputMaybe<Scalars['ID']>;\n  idEqualFold?: InputMaybe<Scalars['ID']>;\n  idGT?: InputMaybe<Scalars['ID']>;\n  idGTE?: InputMaybe<Scalars['ID']>;\n  idIn?: InputMaybe<Array<Scalars['ID']>>;\n  idLT?: InputMaybe<Scalars['ID']>;\n  idLTE?: InputMaybe<Scalars['ID']>;\n  idNEQ?: InputMaybe<Scalars['ID']>;\n  idNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  /** network field predicates */\n  network?: InputMaybe<Scalars['String']>;\n  networkContains?: InputMaybe<Scalars['String']>;\n  networkContainsFold?: InputMaybe<Scalars['String']>;\n  networkEqualFold?: InputMaybe<Scalars['String']>;\n  networkGT?: InputMaybe<Scalars['String']>;\n  networkGTE?: InputMaybe<Scalars['String']>;\n  networkHasPrefix?: InputMaybe<Scalars['String']>;\n  networkHasSuffix?: InputMaybe<Scalars['String']>;\n  networkIn?: InputMaybe<Array<Scalars['String']>>;\n  networkLT?: InputMaybe<Scalars['String']>;\n  networkLTE?: InputMaybe<Scalars['String']>;\n  networkNEQ?: InputMaybe<Scalars['String']>;\n  networkNotIn?: InputMaybe<Array<Scalars['String']>>;\n  not?: InputMaybe<ControllerWhereInput>;\n  or?: InputMaybe<Array<ControllerWhereInput>>;\n  /** updated_at field predicates */\n  updatedAt?: InputMaybe<Scalars['Time']>;\n  updatedAtGT?: InputMaybe<Scalars['Time']>;\n  updatedAtGTE?: InputMaybe<Scalars['Time']>;\n  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  updatedAtLT?: InputMaybe<Scalars['Time']>;\n  updatedAtLTE?: InputMaybe<Scalars['Time']>;\n  updatedAtNEQ?: InputMaybe<Scalars['Time']>;\n  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n};\n\nexport type CreateCoinbaseOnrampOrderInput = {\n  /** The IP address of the end user (required for compliance). */\n  clientIp?: InputMaybe<Scalars['String']>;\n  /** The destination wallet address on Base to receive the USDC. */\n  destinationAddress: Scalars['String'];\n  /**\n   * The domain where the Apple Pay button will be rendered.\n   * Required when embedding the payment link in an iframe.\n   */\n  domain?: InputMaybe<Scalars['String']>;\n  /** Optional partner order reference ID. */\n  partnerOrderRef?: InputMaybe<Scalars['String']>;\n  /**\n   * The amount of fiat currency to pay (e.g., \"100.00\" for $100 USD).\n   * Either paymentAmount or purchaseAmount must be provided.\n   */\n  paymentAmount?: InputMaybe<Scalars['String']>;\n  /** The fiat currency to pay with. Currently only \"USD\" is supported. */\n  paymentCurrency: Scalars['String'];\n  /**\n   * The amount of USDC to purchase (e.g., \"100.000000\" for 100 USDC).\n   * Either paymentAmount or purchaseAmount must be provided.\n   */\n  purchaseAmount?: InputMaybe<Scalars['String']>;\n  /** If true, use sandbox mode for testing (no real charges). */\n  sandbox?: InputMaybe<Scalars['Boolean']>;\n  /** The controller username to create the onramp order for. */\n  username: Scalars['String'];\n};\n\nexport type CreateCoinbaseOnrampSessionInput = {\n  /** The IP address of the end user (required for compliance). */\n  clientIp: Scalars['String'];\n  /** The destination wallet address to receive the crypto. */\n  destinationAddress: Scalars['String'];\n  /** The destination network (e.g., \"base\", \"ethereum\"). */\n  destinationNetwork: CoinbaseNetwork;\n  /**\n   * The amount of fiat currency to pay (e.g., \"100.00\" for $100 USD).\n   * Optional - if provided, creates a one-click buy URL.\n   */\n  paymentAmount?: InputMaybe<Scalars['String']>;\n  /** The fiat currency to pay with (e.g., \"USD\"). Required if paymentAmount is provided. */\n  paymentCurrency?: InputMaybe<Scalars['String']>;\n  /** URL to redirect the user after completing the purchase. */\n  redirectUrl?: InputMaybe<Scalars['String']>;\n};\n\nexport type CreateCryptoPaymentInput = {\n  credits?: InputMaybe<CreditsInput>;\n  isMainnet?: InputMaybe<Scalars['Boolean']>;\n  network: Network;\n  purchaseType: PurchaseType;\n  starterpackId?: InputMaybe<Scalars['ID']>;\n  teamId?: InputMaybe<Scalars['ID']>;\n  username: Scalars['String'];\n};\n\nexport type CreateLayerswapDepositInput = {\n  amount: Scalars['BigInt'];\n  layerswapFees?: InputMaybe<Scalars['BigInt']>;\n  marginPercent?: InputMaybe<Scalars['Int']>;\n  sourceNetwork: LayerswapSourceNetwork;\n  username: Scalars['String'];\n};\n\nexport type CreateLayerswapPaymentInput = {\n  credits?: InputMaybe<CreditsInput>;\n  destinationNetwork: LayerswapDestinationNetwork;\n  layerswapFees?: InputMaybe<Scalars['BigInt']>;\n  purchaseType: PurchaseType;\n  sourceNetwork: LayerswapSourceNetwork;\n  starterpackId?: InputMaybe<Scalars['ID']>;\n  teamId?: InputMaybe<Scalars['ID']>;\n  username: Scalars['String'];\n};\n\n/**\n * CreateMerkleClaimInput is used for create MerkleClaim object.\n * Input was generated by ent.\n */\nexport type CreateMerkleClaimInput = {\n  address: Scalars['String'];\n  claimed?: InputMaybe<Scalars['Boolean']>;\n  claimedAt?: InputMaybe<Scalars['Time']>;\n  createdAt?: InputMaybe<Scalars['Time']>;\n  data: Array<Scalars['String']>;\n  /** Index of the claim in the merkle tree */\n  index?: InputMaybe<Scalars['Int']>;\n  merkleDropID: Scalars['ID'];\n  merkleProof?: InputMaybe<Array<Scalars['String']>>;\n  updatedAt?: InputMaybe<Scalars['Time']>;\n};\n\n/**\n * CreateMerkleDropInput is used for create MerkleDrop object.\n * Input was generated by ent.\n */\nexport type CreateMerkleDropInput = {\n  claimIDs?: InputMaybe<Array<Scalars['ID']>>;\n  contract: Scalars['String'];\n  createdAt?: InputMaybe<Scalars['Time']>;\n  description?: InputMaybe<Scalars['String']>;\n  entrypoint: Scalars['String'];\n  key: Scalars['String'];\n  matchStarterpackItem?: InputMaybe<Scalars['Boolean']>;\n  merkleRoot: Scalars['String'];\n  /** Additional metadata for the merkle drop */\n  metadata?: InputMaybe<Scalars['JSON']>;\n  network: MerkleDropNetwork;\n  salt: Scalars['String'];\n  starterpackID?: InputMaybe<Scalars['ID']>;\n  updatedAt?: InputMaybe<Scalars['Time']>;\n};\n\nexport type CreateRpcApiKeyPayload = {\n  __typename?: 'CreateRpcApiKeyPayload';\n  apiKey: RpcApiKey;\n  secretKey: Scalars['String'];\n};\n\nexport type CreateServiceInput = {\n  config: Scalars['String'];\n  katana?: InputMaybe<KatanaCreateInput>;\n  torii?: InputMaybe<ToriiCreateInput>;\n  type: DeploymentService;\n  version?: InputMaybe<Scalars['String']>;\n};\n\nexport type CreateStripePaymentIntentInput = {\n  credits?: InputMaybe<CreditsInput>;\n  isMainnet?: InputMaybe<Scalars['Boolean']>;\n  purchaseType: PurchaseType;\n  starterpackId?: InputMaybe<Scalars['ID']>;\n  teamId?: InputMaybe<Scalars['ID']>;\n  username: Scalars['String'];\n};\n\nexport type CredentialMetadata = Eip191Credentials | PasswordCredentials | SiwsCredentials | StarknetCredentials | WebauthnCredentials;\n\nexport type Credentials = {\n  __typename?: 'Credentials';\n  webauthn?: Maybe<Array<WebauthnCredential>>;\n};\n\nexport type Credits = {\n  __typename?: 'Credits';\n  amount: Scalars['BigInt'];\n  decimals: Scalars['Int'];\n};\n\nexport type CreditsHistory = Node & {\n  __typename?: 'CreditsHistory';\n  accountID: Scalars['String'];\n  amount: Scalars['Int'];\n  /** Optional comment for transaction reason */\n  comment?: Maybe<Scalars['String']>;\n  createdAt: Scalars['Time'];\n  id: Scalars['ID'];\n  /** Transaction hash for debit transactions */\n  transactionHash?: Maybe<Scalars['String']>;\n  /** Type of transaction: credit or debit */\n  transactionType: CreditsHistoryTransactionType;\n  updatedAt: Scalars['Time'];\n};\n\n/** Ordering options for CreditsHistory connections */\nexport type CreditsHistoryOrder = {\n  /** The ordering direction. */\n  direction?: OrderDirection;\n  /** The field by which to order CreditsHistories. */\n  field: CreditsHistoryOrderField;\n};\n\n/** Properties by which CreditsHistory connections can be ordered. */\nexport enum CreditsHistoryOrderField {\n  CreatedAt = 'CREATED_AT'\n}\n\n/** CreditsHistoryTransactionType is enum for the field transaction_type */\nexport enum CreditsHistoryTransactionType {\n  Credit = 'credit',\n  Debit = 'debit'\n}\n\n/**\n * CreditsHistoryWhereInput is used for filtering CreditsHistory objects.\n * Input was generated by ent.\n */\nexport type CreditsHistoryWhereInput = {\n  /** account_id field predicates */\n  accountID?: InputMaybe<Scalars['String']>;\n  accountIDContains?: InputMaybe<Scalars['String']>;\n  accountIDContainsFold?: InputMaybe<Scalars['String']>;\n  accountIDEqualFold?: InputMaybe<Scalars['String']>;\n  accountIDGT?: InputMaybe<Scalars['String']>;\n  accountIDGTE?: InputMaybe<Scalars['String']>;\n  accountIDHasPrefix?: InputMaybe<Scalars['String']>;\n  accountIDHasSuffix?: InputMaybe<Scalars['String']>;\n  accountIDIn?: InputMaybe<Array<Scalars['String']>>;\n  accountIDLT?: InputMaybe<Scalars['String']>;\n  accountIDLTE?: InputMaybe<Scalars['String']>;\n  accountIDNEQ?: InputMaybe<Scalars['String']>;\n  accountIDNotIn?: InputMaybe<Array<Scalars['String']>>;\n  /** amount field predicates */\n  amount?: InputMaybe<Scalars['Int']>;\n  amountGT?: InputMaybe<Scalars['Int']>;\n  amountGTE?: InputMaybe<Scalars['Int']>;\n  amountIn?: InputMaybe<Array<Scalars['Int']>>;\n  amountLT?: InputMaybe<Scalars['Int']>;\n  amountLTE?: InputMaybe<Scalars['Int']>;\n  amountNEQ?: InputMaybe<Scalars['Int']>;\n  amountNotIn?: InputMaybe<Array<Scalars['Int']>>;\n  and?: InputMaybe<Array<CreditsHistoryWhereInput>>;\n  /** comment field predicates */\n  comment?: InputMaybe<Scalars['String']>;\n  commentContains?: InputMaybe<Scalars['String']>;\n  commentContainsFold?: InputMaybe<Scalars['String']>;\n  commentEqualFold?: InputMaybe<Scalars['String']>;\n  commentGT?: InputMaybe<Scalars['String']>;\n  commentGTE?: InputMaybe<Scalars['String']>;\n  commentHasPrefix?: InputMaybe<Scalars['String']>;\n  commentHasSuffix?: InputMaybe<Scalars['String']>;\n  commentIn?: InputMaybe<Array<Scalars['String']>>;\n  commentIsNil?: InputMaybe<Scalars['Boolean']>;\n  commentLT?: InputMaybe<Scalars['String']>;\n  commentLTE?: InputMaybe<Scalars['String']>;\n  commentNEQ?: InputMaybe<Scalars['String']>;\n  commentNotIn?: InputMaybe<Array<Scalars['String']>>;\n  commentNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** created_at field predicates */\n  createdAt?: InputMaybe<Scalars['Time']>;\n  createdAtGT?: InputMaybe<Scalars['Time']>;\n  createdAtGTE?: InputMaybe<Scalars['Time']>;\n  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  createdAtLT?: InputMaybe<Scalars['Time']>;\n  createdAtLTE?: InputMaybe<Scalars['Time']>;\n  createdAtNEQ?: InputMaybe<Scalars['Time']>;\n  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n  /** id field predicates */\n  id?: InputMaybe<Scalars['ID']>;\n  idContainsFold?: InputMaybe<Scalars['ID']>;\n  idEqualFold?: InputMaybe<Scalars['ID']>;\n  idGT?: InputMaybe<Scalars['ID']>;\n  idGTE?: InputMaybe<Scalars['ID']>;\n  idIn?: InputMaybe<Array<Scalars['ID']>>;\n  idLT?: InputMaybe<Scalars['ID']>;\n  idLTE?: InputMaybe<Scalars['ID']>;\n  idNEQ?: InputMaybe<Scalars['ID']>;\n  idNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  not?: InputMaybe<CreditsHistoryWhereInput>;\n  or?: InputMaybe<Array<CreditsHistoryWhereInput>>;\n  /** transaction_hash field predicates */\n  transactionHash?: InputMaybe<Scalars['String']>;\n  transactionHashContains?: InputMaybe<Scalars['String']>;\n  transactionHashContainsFold?: InputMaybe<Scalars['String']>;\n  transactionHashEqualFold?: InputMaybe<Scalars['String']>;\n  transactionHashGT?: InputMaybe<Scalars['String']>;\n  transactionHashGTE?: InputMaybe<Scalars['String']>;\n  transactionHashHasPrefix?: InputMaybe<Scalars['String']>;\n  transactionHashHasSuffix?: InputMaybe<Scalars['String']>;\n  transactionHashIn?: InputMaybe<Array<Scalars['String']>>;\n  transactionHashIsNil?: InputMaybe<Scalars['Boolean']>;\n  transactionHashLT?: InputMaybe<Scalars['String']>;\n  transactionHashLTE?: InputMaybe<Scalars['String']>;\n  transactionHashNEQ?: InputMaybe<Scalars['String']>;\n  transactionHashNotIn?: InputMaybe<Array<Scalars['String']>>;\n  transactionHashNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** transaction_type field predicates */\n  transactionType?: InputMaybe<CreditsHistoryTransactionType>;\n  transactionTypeIn?: InputMaybe<Array<CreditsHistoryTransactionType>>;\n  transactionTypeNEQ?: InputMaybe<CreditsHistoryTransactionType>;\n  transactionTypeNotIn?: InputMaybe<Array<CreditsHistoryTransactionType>>;\n  /** updated_at field predicates */\n  updatedAt?: InputMaybe<Scalars['Time']>;\n  updatedAtGT?: InputMaybe<Scalars['Time']>;\n  updatedAtGTE?: InputMaybe<Scalars['Time']>;\n  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  updatedAtLT?: InputMaybe<Scalars['Time']>;\n  updatedAtLTE?: InputMaybe<Scalars['Time']>;\n  updatedAtNEQ?: InputMaybe<Scalars['Time']>;\n  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n};\n\nexport type CreditsInput = {\n  amount: Scalars['Int'];\n  decimals: Scalars['Int'];\n};\n\nexport type CryptoPayment = {\n  __typename?: 'CryptoPayment';\n  depositAddress: Scalars['String'];\n  expiresAt: Scalars['Time'];\n  id: Scalars['ID'];\n  network: Network;\n  status: CryptoPaymentStatus;\n  tokenAddress: Scalars['String'];\n  tokenAmount: Scalars['BigInt'];\n  tokenFees: Scalars['BigInt'];\n};\n\nexport enum CryptoPaymentStatus {\n  Confirmed = 'CONFIRMED',\n  Expired = 'EXPIRED',\n  Failed = 'FAILED',\n  Pending = 'PENDING'\n}\n\nexport type Deployment = Node & {\n  __typename?: 'Deployment';\n  autoUpgrade: Scalars['Boolean'];\n  branch?: Maybe<Scalars['String']>;\n  config: DeploymentConfig;\n  createdAt: Scalars['Time'];\n  deprecated?: Maybe<Scalars['Boolean']>;\n  error?: Maybe<Scalars['String']>;\n  events?: Maybe<Array<DeploymentLog>>;\n  id: Scalars['ID'];\n  logs: Logs;\n  observability: Scalars['Boolean'];\n  observabilitySecret?: Maybe<Scalars['String']>;\n  project: Scalars['String'];\n  regions: Array<Scalars['String']>;\n  replicas: Scalars['Int'];\n  service: Service;\n  serviceID: Scalars['ID'];\n  spinDownAt?: Maybe<Scalars['Time']>;\n  spinUpAt?: Maybe<Scalars['Time']>;\n  status: DeploymentStatus;\n  storage: Scalars['Int'];\n  teams: TeamConnection;\n  tier: DeploymentTier;\n  updatedAt: Scalars['Time'];\n  version: Scalars['String'];\n};\n\n\nexport type DeploymentLogsArgs = {\n  container?: InputMaybe<Scalars['String']>;\n  limit?: InputMaybe<Scalars['Int']>;\n  order?: InputMaybe<Order>;\n  region?: InputMaybe<Scalars['String']>;\n  since?: InputMaybe<Scalars['Time']>;\n};\n\n\nexport type DeploymentTeamsArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<TeamWhereInput>;\n};\n\nexport type DeploymentConfig = {\n  __typename?: 'DeploymentConfig';\n  configFile: Scalars['String'];\n};\n\n/** A connection to a list of items. */\nexport type DeploymentConnection = {\n  __typename?: 'DeploymentConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DeploymentEdge>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type DeploymentEdge = {\n  __typename?: 'DeploymentEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['Cursor'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Deployment>;\n};\n\nexport type DeploymentLog = Node & {\n  __typename?: 'DeploymentLog';\n  deployment: Deployment;\n  deploymentID: Scalars['ID'];\n  id: Scalars['ID'];\n  logType: DeploymentLogLogType;\n  timestamp: Scalars['Time'];\n};\n\n/** A connection to a list of items. */\nexport type DeploymentLogConnection = {\n  __typename?: 'DeploymentLogConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DeploymentLogEdge>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type DeploymentLogEdge = {\n  __typename?: 'DeploymentLogEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['Cursor'];\n  /** The item at the end of the edge. */\n  node?: Maybe<DeploymentLog>;\n};\n\n/** DeploymentLogLogType is enum for the field log_type */\nexport enum DeploymentLogLogType {\n  Created = 'created',\n  Deleted = 'deleted',\n  ScaledDown = 'scaled_down',\n  ScaledUp = 'scaled_up'\n}\n\n/**\n * DeploymentLogWhereInput is used for filtering DeploymentLog objects.\n * Input was generated by ent.\n */\nexport type DeploymentLogWhereInput = {\n  and?: InputMaybe<Array<DeploymentLogWhereInput>>;\n  /** deployment_id field predicates */\n  deploymentID?: InputMaybe<Scalars['ID']>;\n  deploymentIDContains?: InputMaybe<Scalars['ID']>;\n  deploymentIDContainsFold?: InputMaybe<Scalars['ID']>;\n  deploymentIDEqualFold?: InputMaybe<Scalars['ID']>;\n  deploymentIDGT?: InputMaybe<Scalars['ID']>;\n  deploymentIDGTE?: InputMaybe<Scalars['ID']>;\n  deploymentIDHasPrefix?: InputMaybe<Scalars['ID']>;\n  deploymentIDHasSuffix?: InputMaybe<Scalars['ID']>;\n  deploymentIDIn?: InputMaybe<Array<Scalars['ID']>>;\n  deploymentIDLT?: InputMaybe<Scalars['ID']>;\n  deploymentIDLTE?: InputMaybe<Scalars['ID']>;\n  deploymentIDNEQ?: InputMaybe<Scalars['ID']>;\n  deploymentIDNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  /** deployment edge predicates */\n  hasDeployment?: InputMaybe<Scalars['Boolean']>;\n  hasDeploymentWith?: InputMaybe<Array<DeploymentWhereInput>>;\n  /** id field predicates */\n  id?: InputMaybe<Scalars['ID']>;\n  idContainsFold?: InputMaybe<Scalars['ID']>;\n  idEqualFold?: InputMaybe<Scalars['ID']>;\n  idGT?: InputMaybe<Scalars['ID']>;\n  idGTE?: InputMaybe<Scalars['ID']>;\n  idIn?: InputMaybe<Array<Scalars['ID']>>;\n  idLT?: InputMaybe<Scalars['ID']>;\n  idLTE?: InputMaybe<Scalars['ID']>;\n  idNEQ?: InputMaybe<Scalars['ID']>;\n  idNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  /** log_type field predicates */\n  logType?: InputMaybe<DeploymentLogLogType>;\n  logTypeIn?: InputMaybe<Array<DeploymentLogLogType>>;\n  logTypeNEQ?: InputMaybe<DeploymentLogLogType>;\n  logTypeNotIn?: InputMaybe<Array<DeploymentLogLogType>>;\n  not?: InputMaybe<DeploymentLogWhereInput>;\n  or?: InputMaybe<Array<DeploymentLogWhereInput>>;\n  /** timestamp field predicates */\n  timestamp?: InputMaybe<Scalars['Time']>;\n  timestampGT?: InputMaybe<Scalars['Time']>;\n  timestampGTE?: InputMaybe<Scalars['Time']>;\n  timestampIn?: InputMaybe<Array<Scalars['Time']>>;\n  timestampLT?: InputMaybe<Scalars['Time']>;\n  timestampLTE?: InputMaybe<Scalars['Time']>;\n  timestampNEQ?: InputMaybe<Scalars['Time']>;\n  timestampNotIn?: InputMaybe<Array<Scalars['Time']>>;\n};\n\n/** Ordering options for Deployment connections */\nexport type DeploymentOrder = {\n  /** The ordering direction. */\n  direction?: OrderDirection;\n  /** The field by which to order Deployments. */\n  field: DeploymentOrderField;\n};\n\n/** Properties by which Deployment connections can be ordered. */\nexport enum DeploymentOrderField {\n  CreatedAt = 'CREATED_AT'\n}\n\nexport enum DeploymentService {\n  Katana = 'katana',\n  Torii = 'torii'\n}\n\n/** DeploymentStatus is enum for the field status */\nexport enum DeploymentStatus {\n  Active = 'active',\n  Deleted = 'deleted',\n  Disabled = 'disabled',\n  Error = 'error'\n}\n\n/** DeploymentTier is enum for the field tier */\nexport enum DeploymentTier {\n  Basic = 'basic',\n  Common = 'common',\n  Epic = 'epic',\n  Insane = 'insane',\n  Legendary = 'legendary',\n  Pro = 'pro'\n}\n\n/**\n * DeploymentWhereInput is used for filtering Deployment objects.\n * Input was generated by ent.\n */\nexport type DeploymentWhereInput = {\n  and?: InputMaybe<Array<DeploymentWhereInput>>;\n  /** auto_upgrade field predicates */\n  autoUpgrade?: InputMaybe<Scalars['Boolean']>;\n  autoUpgradeNEQ?: InputMaybe<Scalars['Boolean']>;\n  /** branch field predicates */\n  branch?: InputMaybe<Scalars['String']>;\n  branchContains?: InputMaybe<Scalars['String']>;\n  branchContainsFold?: InputMaybe<Scalars['String']>;\n  branchEqualFold?: InputMaybe<Scalars['String']>;\n  branchGT?: InputMaybe<Scalars['String']>;\n  branchGTE?: InputMaybe<Scalars['String']>;\n  branchHasPrefix?: InputMaybe<Scalars['String']>;\n  branchHasSuffix?: InputMaybe<Scalars['String']>;\n  branchIn?: InputMaybe<Array<Scalars['String']>>;\n  branchIsNil?: InputMaybe<Scalars['Boolean']>;\n  branchLT?: InputMaybe<Scalars['String']>;\n  branchLTE?: InputMaybe<Scalars['String']>;\n  branchNEQ?: InputMaybe<Scalars['String']>;\n  branchNotIn?: InputMaybe<Array<Scalars['String']>>;\n  branchNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** created_at field predicates */\n  createdAt?: InputMaybe<Scalars['Time']>;\n  createdAtGT?: InputMaybe<Scalars['Time']>;\n  createdAtGTE?: InputMaybe<Scalars['Time']>;\n  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  createdAtLT?: InputMaybe<Scalars['Time']>;\n  createdAtLTE?: InputMaybe<Scalars['Time']>;\n  createdAtNEQ?: InputMaybe<Scalars['Time']>;\n  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n  /** deprecated field predicates */\n  deprecated?: InputMaybe<Scalars['Boolean']>;\n  deprecatedIsNil?: InputMaybe<Scalars['Boolean']>;\n  deprecatedNEQ?: InputMaybe<Scalars['Boolean']>;\n  deprecatedNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** error field predicates */\n  error?: InputMaybe<Scalars['String']>;\n  errorContains?: InputMaybe<Scalars['String']>;\n  errorContainsFold?: InputMaybe<Scalars['String']>;\n  errorEqualFold?: InputMaybe<Scalars['String']>;\n  errorGT?: InputMaybe<Scalars['String']>;\n  errorGTE?: InputMaybe<Scalars['String']>;\n  errorHasPrefix?: InputMaybe<Scalars['String']>;\n  errorHasSuffix?: InputMaybe<Scalars['String']>;\n  errorIn?: InputMaybe<Array<Scalars['String']>>;\n  errorIsNil?: InputMaybe<Scalars['Boolean']>;\n  errorLT?: InputMaybe<Scalars['String']>;\n  errorLTE?: InputMaybe<Scalars['String']>;\n  errorNEQ?: InputMaybe<Scalars['String']>;\n  errorNotIn?: InputMaybe<Array<Scalars['String']>>;\n  errorNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** events edge predicates */\n  hasEvents?: InputMaybe<Scalars['Boolean']>;\n  hasEventsWith?: InputMaybe<Array<DeploymentLogWhereInput>>;\n  /** service edge predicates */\n  hasService?: InputMaybe<Scalars['Boolean']>;\n  hasServiceWith?: InputMaybe<Array<ServiceWhereInput>>;\n  /** teams edge predicates */\n  hasTeams?: InputMaybe<Scalars['Boolean']>;\n  hasTeamsWith?: InputMaybe<Array<TeamWhereInput>>;\n  /** id field predicates */\n  id?: InputMaybe<Scalars['ID']>;\n  idContainsFold?: InputMaybe<Scalars['ID']>;\n  idEqualFold?: InputMaybe<Scalars['ID']>;\n  idGT?: InputMaybe<Scalars['ID']>;\n  idGTE?: InputMaybe<Scalars['ID']>;\n  idIn?: InputMaybe<Array<Scalars['ID']>>;\n  idLT?: InputMaybe<Scalars['ID']>;\n  idLTE?: InputMaybe<Scalars['ID']>;\n  idNEQ?: InputMaybe<Scalars['ID']>;\n  idNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  not?: InputMaybe<DeploymentWhereInput>;\n  /** observability field predicates */\n  observability?: InputMaybe<Scalars['Boolean']>;\n  observabilityNEQ?: InputMaybe<Scalars['Boolean']>;\n  or?: InputMaybe<Array<DeploymentWhereInput>>;\n  /** project field predicates */\n  project?: InputMaybe<Scalars['String']>;\n  projectContains?: InputMaybe<Scalars['String']>;\n  projectContainsFold?: InputMaybe<Scalars['String']>;\n  projectEqualFold?: InputMaybe<Scalars['String']>;\n  projectGT?: InputMaybe<Scalars['String']>;\n  projectGTE?: InputMaybe<Scalars['String']>;\n  projectHasPrefix?: InputMaybe<Scalars['String']>;\n  projectHasSuffix?: InputMaybe<Scalars['String']>;\n  projectIn?: InputMaybe<Array<Scalars['String']>>;\n  projectLT?: InputMaybe<Scalars['String']>;\n  projectLTE?: InputMaybe<Scalars['String']>;\n  projectNEQ?: InputMaybe<Scalars['String']>;\n  projectNotIn?: InputMaybe<Array<Scalars['String']>>;\n  /** replicas field predicates */\n  replicas?: InputMaybe<Scalars['Int']>;\n  replicasGT?: InputMaybe<Scalars['Int']>;\n  replicasGTE?: InputMaybe<Scalars['Int']>;\n  replicasIn?: InputMaybe<Array<Scalars['Int']>>;\n  replicasLT?: InputMaybe<Scalars['Int']>;\n  replicasLTE?: InputMaybe<Scalars['Int']>;\n  replicasNEQ?: InputMaybe<Scalars['Int']>;\n  replicasNotIn?: InputMaybe<Array<Scalars['Int']>>;\n  /** service_id field predicates */\n  serviceID?: InputMaybe<Scalars['ID']>;\n  serviceIDContains?: InputMaybe<Scalars['ID']>;\n  serviceIDContainsFold?: InputMaybe<Scalars['ID']>;\n  serviceIDEqualFold?: InputMaybe<Scalars['ID']>;\n  serviceIDGT?: InputMaybe<Scalars['ID']>;\n  serviceIDGTE?: InputMaybe<Scalars['ID']>;\n  serviceIDHasPrefix?: InputMaybe<Scalars['ID']>;\n  serviceIDHasSuffix?: InputMaybe<Scalars['ID']>;\n  serviceIDIn?: InputMaybe<Array<Scalars['ID']>>;\n  serviceIDLT?: InputMaybe<Scalars['ID']>;\n  serviceIDLTE?: InputMaybe<Scalars['ID']>;\n  serviceIDNEQ?: InputMaybe<Scalars['ID']>;\n  serviceIDNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  /** spin_down_at field predicates */\n  spinDownAt?: InputMaybe<Scalars['Time']>;\n  spinDownAtGT?: InputMaybe<Scalars['Time']>;\n  spinDownAtGTE?: InputMaybe<Scalars['Time']>;\n  spinDownAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  spinDownAtIsNil?: InputMaybe<Scalars['Boolean']>;\n  spinDownAtLT?: InputMaybe<Scalars['Time']>;\n  spinDownAtLTE?: InputMaybe<Scalars['Time']>;\n  spinDownAtNEQ?: InputMaybe<Scalars['Time']>;\n  spinDownAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n  spinDownAtNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** spin_up_at field predicates */\n  spinUpAt?: InputMaybe<Scalars['Time']>;\n  spinUpAtGT?: InputMaybe<Scalars['Time']>;\n  spinUpAtGTE?: InputMaybe<Scalars['Time']>;\n  spinUpAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  spinUpAtIsNil?: InputMaybe<Scalars['Boolean']>;\n  spinUpAtLT?: InputMaybe<Scalars['Time']>;\n  spinUpAtLTE?: InputMaybe<Scalars['Time']>;\n  spinUpAtNEQ?: InputMaybe<Scalars['Time']>;\n  spinUpAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n  spinUpAtNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** status field predicates */\n  status?: InputMaybe<DeploymentStatus>;\n  statusIn?: InputMaybe<Array<DeploymentStatus>>;\n  statusNEQ?: InputMaybe<DeploymentStatus>;\n  statusNotIn?: InputMaybe<Array<DeploymentStatus>>;\n  /** storage field predicates */\n  storage?: InputMaybe<Scalars['Int']>;\n  storageGT?: InputMaybe<Scalars['Int']>;\n  storageGTE?: InputMaybe<Scalars['Int']>;\n  storageIn?: InputMaybe<Array<Scalars['Int']>>;\n  storageLT?: InputMaybe<Scalars['Int']>;\n  storageLTE?: InputMaybe<Scalars['Int']>;\n  storageNEQ?: InputMaybe<Scalars['Int']>;\n  storageNotIn?: InputMaybe<Array<Scalars['Int']>>;\n  /** tier field predicates */\n  tier?: InputMaybe<DeploymentTier>;\n  tierIn?: InputMaybe<Array<DeploymentTier>>;\n  tierNEQ?: InputMaybe<DeploymentTier>;\n  tierNotIn?: InputMaybe<Array<DeploymentTier>>;\n  /** updated_at field predicates */\n  updatedAt?: InputMaybe<Scalars['Time']>;\n  updatedAtGT?: InputMaybe<Scalars['Time']>;\n  updatedAtGTE?: InputMaybe<Scalars['Time']>;\n  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  updatedAtLT?: InputMaybe<Scalars['Time']>;\n  updatedAtLTE?: InputMaybe<Scalars['Time']>;\n  updatedAtNEQ?: InputMaybe<Scalars['Time']>;\n  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n  /** version field predicates */\n  version?: InputMaybe<Scalars['String']>;\n  versionContains?: InputMaybe<Scalars['String']>;\n  versionContainsFold?: InputMaybe<Scalars['String']>;\n  versionEqualFold?: InputMaybe<Scalars['String']>;\n  versionGT?: InputMaybe<Scalars['String']>;\n  versionGTE?: InputMaybe<Scalars['String']>;\n  versionHasPrefix?: InputMaybe<Scalars['String']>;\n  versionHasSuffix?: InputMaybe<Scalars['String']>;\n  versionIn?: InputMaybe<Array<Scalars['String']>>;\n  versionLT?: InputMaybe<Scalars['String']>;\n  versionLTE?: InputMaybe<Scalars['String']>;\n  versionNEQ?: InputMaybe<Scalars['String']>;\n  versionNotIn?: InputMaybe<Array<Scalars['String']>>;\n};\n\nexport type Erc20Metadata = {\n  __typename?: 'ERC20Metadata';\n  contractAddress: Scalars['String'];\n  decimals: Scalars['Int'];\n  name: Scalars['String'];\n  periodPrice: Scalars['Float'];\n  price: Scalars['Float'];\n  project: Scalars['String'];\n  symbol: Scalars['String'];\n};\n\nexport type Erc721Metadata = {\n  __typename?: 'ERC721Metadata';\n  assetCount: Scalars['Int'];\n  contractAddress: Scalars['String'];\n  imagePath: Scalars['String'];\n  name: Scalars['String'];\n  project: Scalars['String'];\n};\n\nexport type Erc1155Metadata = {\n  __typename?: 'ERC1155Metadata';\n  assetCount: Scalars['Int'];\n  contractAddress: Scalars['String'];\n  imagePath: Scalars['String'];\n  name: Scalars['String'];\n  project: Scalars['String'];\n};\n\nexport type Eip191Credential = {\n  __typename?: 'Eip191Credential';\n  ethAddress: Scalars['String'];\n  provider: Scalars['String'];\n};\n\nexport type Eip191Credentials = {\n  __typename?: 'Eip191Credentials';\n  eip191?: Maybe<Array<Eip191Credential>>;\n};\n\nexport enum FeeUnit {\n  Credit = 'CREDIT',\n  Strk = 'STRK'\n}\n\nexport type HasValueInput = {\n  index: Scalars['Int'];\n  value: Scalars['String'];\n};\n\nexport type Invoice = Node & {\n  __typename?: 'Invoice';\n  createdAt: Scalars['Time'];\n  /** Whether the invoice is finalized and ready for billing */\n  finalized: Scalars['Boolean'];\n  id: Scalars['ID'];\n  /** Auto-credits from incubator program. 1 credit = 0.01 USD. */\n  incubatorCredits: Scalars['Int'];\n  /** Incubator stage at time of invoice: kohai, senpai, or sensei */\n  incubatorStage?: Maybe<Scalars['String']>;\n  /** Month in YYYY-MM format */\n  month: Scalars['String'];\n  /** Net amount (total_debits - total_credits). 1 credit = 0.01 USD. */\n  netAmount: Scalars['Int'];\n  /** Debits for paymaster usage. 1 credit = 0.01 USD. */\n  paymasterDebits: Scalars['Int'];\n  /** Debits for slot deployments. 1 credit = 0.01 USD. */\n  slotDebits: Scalars['Int'];\n  team: Team;\n  /** Foreign key to team table */\n  teamID: Scalars['ID'];\n  /** Total credits added during the month. 1 credit = 0.01 USD. */\n  totalCredits: Scalars['Int'];\n  /** Total debits during the month. 1 credit = 0.01 USD. */\n  totalDebits: Scalars['Int'];\n  updatedAt: Scalars['Time'];\n};\n\n/** A connection to a list of items. */\nexport type InvoiceConnection = {\n  __typename?: 'InvoiceConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<InvoiceEdge>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type InvoiceEdge = {\n  __typename?: 'InvoiceEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['Cursor'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Invoice>;\n};\n\n/** Ordering options for Invoice connections */\nexport type InvoiceOrder = {\n  /** The ordering direction. */\n  direction?: OrderDirection;\n  /** The field by which to order Invoices. */\n  field: InvoiceOrderField;\n};\n\n/** Properties by which Invoice connections can be ordered. */\nexport enum InvoiceOrderField {\n  CreatedAt = 'CREATED_AT'\n}\n\n/**\n * InvoiceWhereInput is used for filtering Invoice objects.\n * Input was generated by ent.\n */\nexport type InvoiceWhereInput = {\n  and?: InputMaybe<Array<InvoiceWhereInput>>;\n  /** created_at field predicates */\n  createdAt?: InputMaybe<Scalars['Time']>;\n  createdAtGT?: InputMaybe<Scalars['Time']>;\n  createdAtGTE?: InputMaybe<Scalars['Time']>;\n  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  createdAtLT?: InputMaybe<Scalars['Time']>;\n  createdAtLTE?: InputMaybe<Scalars['Time']>;\n  createdAtNEQ?: InputMaybe<Scalars['Time']>;\n  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n  /** finalized field predicates */\n  finalized?: InputMaybe<Scalars['Boolean']>;\n  finalizedNEQ?: InputMaybe<Scalars['Boolean']>;\n  /** team edge predicates */\n  hasTeam?: InputMaybe<Scalars['Boolean']>;\n  hasTeamWith?: InputMaybe<Array<TeamWhereInput>>;\n  /** id field predicates */\n  id?: InputMaybe<Scalars['ID']>;\n  idContainsFold?: InputMaybe<Scalars['ID']>;\n  idEqualFold?: InputMaybe<Scalars['ID']>;\n  idGT?: InputMaybe<Scalars['ID']>;\n  idGTE?: InputMaybe<Scalars['ID']>;\n  idIn?: InputMaybe<Array<Scalars['ID']>>;\n  idLT?: InputMaybe<Scalars['ID']>;\n  idLTE?: InputMaybe<Scalars['ID']>;\n  idNEQ?: InputMaybe<Scalars['ID']>;\n  idNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  /** incubator_credits field predicates */\n  incubatorCredits?: InputMaybe<Scalars['Int']>;\n  incubatorCreditsGT?: InputMaybe<Scalars['Int']>;\n  incubatorCreditsGTE?: InputMaybe<Scalars['Int']>;\n  incubatorCreditsIn?: InputMaybe<Array<Scalars['Int']>>;\n  incubatorCreditsLT?: InputMaybe<Scalars['Int']>;\n  incubatorCreditsLTE?: InputMaybe<Scalars['Int']>;\n  incubatorCreditsNEQ?: InputMaybe<Scalars['Int']>;\n  incubatorCreditsNotIn?: InputMaybe<Array<Scalars['Int']>>;\n  /** incubator_stage field predicates */\n  incubatorStage?: InputMaybe<Scalars['String']>;\n  incubatorStageContains?: InputMaybe<Scalars['String']>;\n  incubatorStageContainsFold?: InputMaybe<Scalars['String']>;\n  incubatorStageEqualFold?: InputMaybe<Scalars['String']>;\n  incubatorStageGT?: InputMaybe<Scalars['String']>;\n  incubatorStageGTE?: InputMaybe<Scalars['String']>;\n  incubatorStageHasPrefix?: InputMaybe<Scalars['String']>;\n  incubatorStageHasSuffix?: InputMaybe<Scalars['String']>;\n  incubatorStageIn?: InputMaybe<Array<Scalars['String']>>;\n  incubatorStageIsNil?: InputMaybe<Scalars['Boolean']>;\n  incubatorStageLT?: InputMaybe<Scalars['String']>;\n  incubatorStageLTE?: InputMaybe<Scalars['String']>;\n  incubatorStageNEQ?: InputMaybe<Scalars['String']>;\n  incubatorStageNotIn?: InputMaybe<Array<Scalars['String']>>;\n  incubatorStageNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** month field predicates */\n  month?: InputMaybe<Scalars['String']>;\n  monthContains?: InputMaybe<Scalars['String']>;\n  monthContainsFold?: InputMaybe<Scalars['String']>;\n  monthEqualFold?: InputMaybe<Scalars['String']>;\n  monthGT?: InputMaybe<Scalars['String']>;\n  monthGTE?: InputMaybe<Scalars['String']>;\n  monthHasPrefix?: InputMaybe<Scalars['String']>;\n  monthHasSuffix?: InputMaybe<Scalars['String']>;\n  monthIn?: InputMaybe<Array<Scalars['String']>>;\n  monthLT?: InputMaybe<Scalars['String']>;\n  monthLTE?: InputMaybe<Scalars['String']>;\n  monthNEQ?: InputMaybe<Scalars['String']>;\n  monthNotIn?: InputMaybe<Array<Scalars['String']>>;\n  /** net_amount field predicates */\n  netAmount?: InputMaybe<Scalars['Int']>;\n  netAmountGT?: InputMaybe<Scalars['Int']>;\n  netAmountGTE?: InputMaybe<Scalars['Int']>;\n  netAmountIn?: InputMaybe<Array<Scalars['Int']>>;\n  netAmountLT?: InputMaybe<Scalars['Int']>;\n  netAmountLTE?: InputMaybe<Scalars['Int']>;\n  netAmountNEQ?: InputMaybe<Scalars['Int']>;\n  netAmountNotIn?: InputMaybe<Array<Scalars['Int']>>;\n  not?: InputMaybe<InvoiceWhereInput>;\n  or?: InputMaybe<Array<InvoiceWhereInput>>;\n  /** paymaster_debits field predicates */\n  paymasterDebits?: InputMaybe<Scalars['Int']>;\n  paymasterDebitsGT?: InputMaybe<Scalars['Int']>;\n  paymasterDebitsGTE?: InputMaybe<Scalars['Int']>;\n  paymasterDebitsIn?: InputMaybe<Array<Scalars['Int']>>;\n  paymasterDebitsLT?: InputMaybe<Scalars['Int']>;\n  paymasterDebitsLTE?: InputMaybe<Scalars['Int']>;\n  paymasterDebitsNEQ?: InputMaybe<Scalars['Int']>;\n  paymasterDebitsNotIn?: InputMaybe<Array<Scalars['Int']>>;\n  /** slot_debits field predicates */\n  slotDebits?: InputMaybe<Scalars['Int']>;\n  slotDebitsGT?: InputMaybe<Scalars['Int']>;\n  slotDebitsGTE?: InputMaybe<Scalars['Int']>;\n  slotDebitsIn?: InputMaybe<Array<Scalars['Int']>>;\n  slotDebitsLT?: InputMaybe<Scalars['Int']>;\n  slotDebitsLTE?: InputMaybe<Scalars['Int']>;\n  slotDebitsNEQ?: InputMaybe<Scalars['Int']>;\n  slotDebitsNotIn?: InputMaybe<Array<Scalars['Int']>>;\n  /** team_id field predicates */\n  teamID?: InputMaybe<Scalars['ID']>;\n  teamIDContains?: InputMaybe<Scalars['ID']>;\n  teamIDContainsFold?: InputMaybe<Scalars['ID']>;\n  teamIDEqualFold?: InputMaybe<Scalars['ID']>;\n  teamIDGT?: InputMaybe<Scalars['ID']>;\n  teamIDGTE?: InputMaybe<Scalars['ID']>;\n  teamIDHasPrefix?: InputMaybe<Scalars['ID']>;\n  teamIDHasSuffix?: InputMaybe<Scalars['ID']>;\n  teamIDIn?: InputMaybe<Array<Scalars['ID']>>;\n  teamIDLT?: InputMaybe<Scalars['ID']>;\n  teamIDLTE?: InputMaybe<Scalars['ID']>;\n  teamIDNEQ?: InputMaybe<Scalars['ID']>;\n  teamIDNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  /** total_credits field predicates */\n  totalCredits?: InputMaybe<Scalars['Int']>;\n  totalCreditsGT?: InputMaybe<Scalars['Int']>;\n  totalCreditsGTE?: InputMaybe<Scalars['Int']>;\n  totalCreditsIn?: InputMaybe<Array<Scalars['Int']>>;\n  totalCreditsLT?: InputMaybe<Scalars['Int']>;\n  totalCreditsLTE?: InputMaybe<Scalars['Int']>;\n  totalCreditsNEQ?: InputMaybe<Scalars['Int']>;\n  totalCreditsNotIn?: InputMaybe<Array<Scalars['Int']>>;\n  /** total_debits field predicates */\n  totalDebits?: InputMaybe<Scalars['Int']>;\n  totalDebitsGT?: InputMaybe<Scalars['Int']>;\n  totalDebitsGTE?: InputMaybe<Scalars['Int']>;\n  totalDebitsIn?: InputMaybe<Array<Scalars['Int']>>;\n  totalDebitsLT?: InputMaybe<Scalars['Int']>;\n  totalDebitsLTE?: InputMaybe<Scalars['Int']>;\n  totalDebitsNEQ?: InputMaybe<Scalars['Int']>;\n  totalDebitsNotIn?: InputMaybe<Array<Scalars['Int']>>;\n  /** updated_at field predicates */\n  updatedAt?: InputMaybe<Scalars['Time']>;\n  updatedAtGT?: InputMaybe<Scalars['Time']>;\n  updatedAtGTE?: InputMaybe<Scalars['Time']>;\n  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  updatedAtLT?: InputMaybe<Scalars['Time']>;\n  updatedAtLTE?: InputMaybe<Scalars['Time']>;\n  updatedAtNEQ?: InputMaybe<Scalars['Time']>;\n  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n};\n\nexport type KatanaCreateInput = {\n  forkProviderUrl?: InputMaybe<Scalars['String']>;\n  network?: InputMaybe<Scalars['String']>;\n  optimistic?: InputMaybe<Scalars['Boolean']>;\n  provable?: InputMaybe<Scalars['Boolean']>;\n  saya?: InputMaybe<Scalars['Boolean']>;\n};\n\nexport enum LayerswapDestinationNetwork {\n  StarknetMainnet = 'STARKNET_MAINNET',\n  StarknetSepolia = 'STARKNET_SEPOLIA'\n}\n\nexport type LayerswapPayment = {\n  __typename?: 'LayerswapPayment';\n  cryptoPaymentId: Scalars['ID'];\n  expiresAt: Scalars['Time'];\n  sourceDepositAddress: Scalars['String'];\n  sourceNetwork: LayerswapSourceNetwork;\n  sourceTokenAddress: Scalars['String'];\n  sourceTokenAmount: Scalars['BigInt'];\n  status: LayerswapStatus;\n  swapId: Scalars['String'];\n};\n\nexport type LayerswapQuote = {\n  __typename?: 'LayerswapQuote';\n  averageCompletionTime: Scalars['String'];\n  receivedAmount: Scalars['BigInt'];\n  requestedAmount: Scalars['BigInt'];\n  totalFees: Scalars['BigInt'];\n};\n\nexport type LayerswapSource = {\n  __typename?: 'LayerswapSource';\n  accountExplorerTemplate: Scalars['String'];\n  chainId: Scalars['String'];\n  depositMethods: Array<Scalars['String']>;\n  destinationRank: Scalars['Int'];\n  displayName: Scalars['String'];\n  logo: Scalars['String'];\n  name: Scalars['String'];\n  nodeUrl: Scalars['String'];\n  sourceRank: Scalars['Int'];\n  tokens: Array<LayerswapSourceToken>;\n  transactionExplorerTemplate: Scalars['String'];\n  type: Scalars['String'];\n};\n\nexport enum LayerswapSourceNetwork {\n  ArbitrumMainnet = 'ARBITRUM_MAINNET',\n  ArbitrumSepolia = 'ARBITRUM_SEPOLIA',\n  BaseMainnet = 'BASE_MAINNET',\n  BaseSepolia = 'BASE_SEPOLIA',\n  EthereumMainnet = 'ETHEREUM_MAINNET',\n  EthereumSepolia = 'ETHEREUM_SEPOLIA',\n  OptimismMainnet = 'OPTIMISM_MAINNET',\n  OptimismSepolia = 'OPTIMISM_SEPOLIA',\n  SolanaDevnet = 'SOLANA_DEVNET',\n  SolanaMainnet = 'SOLANA_MAINNET'\n}\n\nexport type LayerswapSourceToken = {\n  __typename?: 'LayerswapSourceToken';\n  contract?: Maybe<Scalars['String']>;\n  decimals: Scalars['Int'];\n  displayAsset: Scalars['String'];\n  logo: Scalars['String'];\n  precision: Scalars['Int'];\n  priceInUsd: Scalars['Float'];\n  status: Scalars['String'];\n  symbol: Scalars['String'];\n};\n\nexport enum LayerswapStatus {\n  Confirmed = 'CONFIRMED',\n  Expired = 'EXPIRED',\n  Failed = 'FAILED',\n  Pending = 'PENDING',\n  PendingLsTransfer = 'PENDING_LS_TRANSFER',\n  PendingUserTransfer = 'PENDING_USER_TRANSFER'\n}\n\nexport type Lock = Node & {\n  __typename?: 'Lock';\n  createdAt: Scalars['Time'];\n  id: Scalars['ID'];\n  updatedAt: Scalars['Time'];\n};\n\n/** Ordering options for Lock connections */\nexport type LockOrder = {\n  /** The ordering direction. */\n  direction?: OrderDirection;\n  /** The field by which to order Locks. */\n  field: LockOrderField;\n};\n\n/** Properties by which Lock connections can be ordered. */\nexport enum LockOrderField {\n  CreatedAt = 'CREATED_AT'\n}\n\n/**\n * LockWhereInput is used for filtering Lock objects.\n * Input was generated by ent.\n */\nexport type LockWhereInput = {\n  and?: InputMaybe<Array<LockWhereInput>>;\n  /** created_at field predicates */\n  createdAt?: InputMaybe<Scalars['Time']>;\n  createdAtGT?: InputMaybe<Scalars['Time']>;\n  createdAtGTE?: InputMaybe<Scalars['Time']>;\n  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  createdAtLT?: InputMaybe<Scalars['Time']>;\n  createdAtLTE?: InputMaybe<Scalars['Time']>;\n  createdAtNEQ?: InputMaybe<Scalars['Time']>;\n  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n  /** id field predicates */\n  id?: InputMaybe<Scalars['ID']>;\n  idContainsFold?: InputMaybe<Scalars['ID']>;\n  idEqualFold?: InputMaybe<Scalars['ID']>;\n  idGT?: InputMaybe<Scalars['ID']>;\n  idGTE?: InputMaybe<Scalars['ID']>;\n  idIn?: InputMaybe<Array<Scalars['ID']>>;\n  idLT?: InputMaybe<Scalars['ID']>;\n  idLTE?: InputMaybe<Scalars['ID']>;\n  idNEQ?: InputMaybe<Scalars['ID']>;\n  idNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  not?: InputMaybe<LockWhereInput>;\n  or?: InputMaybe<Array<LockWhereInput>>;\n  /** updated_at field predicates */\n  updatedAt?: InputMaybe<Scalars['Time']>;\n  updatedAtGT?: InputMaybe<Scalars['Time']>;\n  updatedAtGTE?: InputMaybe<Scalars['Time']>;\n  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  updatedAtLT?: InputMaybe<Scalars['Time']>;\n  updatedAtLTE?: InputMaybe<Scalars['Time']>;\n  updatedAtNEQ?: InputMaybe<Scalars['Time']>;\n  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n};\n\nexport type Logs = {\n  __typename?: 'Logs';\n  content: Scalars['String'];\n  until: Scalars['Time'];\n};\n\nexport type MerkleClaim = Node & {\n  __typename?: 'MerkleClaim';\n  address: Scalars['String'];\n  claimed: Scalars['Boolean'];\n  claimedAt?: Maybe<Scalars['Time']>;\n  createdAt: Scalars['Time'];\n  data: Array<Scalars['String']>;\n  id: Scalars['ID'];\n  /** Index of the claim in the merkle tree */\n  index: Scalars['Int'];\n  merkleDrop: MerkleDrop;\n  merkleDropID: Scalars['ID'];\n  merkleProof?: Maybe<Array<Scalars['String']>>;\n  updatedAt: Scalars['Time'];\n};\n\n/** A connection to a list of items. */\nexport type MerkleClaimConnection = {\n  __typename?: 'MerkleClaimConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<MerkleClaimEdge>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type MerkleClaimEdge = {\n  __typename?: 'MerkleClaimEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['Cursor'];\n  /** The item at the end of the edge. */\n  node?: Maybe<MerkleClaim>;\n};\n\nexport type MerkleClaimInput = {\n  address: Scalars['Felt'];\n  data: Array<Scalars['Felt']>;\n  index: Scalars['Int'];\n};\n\n/** Ordering options for MerkleClaim connections */\nexport type MerkleClaimOrder = {\n  /** The ordering direction. */\n  direction?: OrderDirection;\n  /** The field by which to order MerkleClaims. */\n  field: MerkleClaimOrderField;\n};\n\n/** Properties by which MerkleClaim connections can be ordered. */\nexport enum MerkleClaimOrderField {\n  CreatedAt = 'CREATED_AT'\n}\n\n/**\n * MerkleClaimWhereInput is used for filtering MerkleClaim objects.\n * Input was generated by ent.\n */\nexport type MerkleClaimWhereInput = {\n  /** address field predicates */\n  address?: InputMaybe<Scalars['String']>;\n  addressContains?: InputMaybe<Scalars['String']>;\n  addressContainsFold?: InputMaybe<Scalars['String']>;\n  addressEqualFold?: InputMaybe<Scalars['String']>;\n  addressGT?: InputMaybe<Scalars['String']>;\n  addressGTE?: InputMaybe<Scalars['String']>;\n  addressHasPrefix?: InputMaybe<Scalars['String']>;\n  addressHasSuffix?: InputMaybe<Scalars['String']>;\n  addressIn?: InputMaybe<Array<Scalars['String']>>;\n  addressLT?: InputMaybe<Scalars['String']>;\n  addressLTE?: InputMaybe<Scalars['String']>;\n  addressNEQ?: InputMaybe<Scalars['String']>;\n  addressNotIn?: InputMaybe<Array<Scalars['String']>>;\n  and?: InputMaybe<Array<MerkleClaimWhereInput>>;\n  /** claimed field predicates */\n  claimed?: InputMaybe<Scalars['Boolean']>;\n  /** claimed_at field predicates */\n  claimedAt?: InputMaybe<Scalars['Time']>;\n  claimedAtGT?: InputMaybe<Scalars['Time']>;\n  claimedAtGTE?: InputMaybe<Scalars['Time']>;\n  claimedAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  claimedAtIsNil?: InputMaybe<Scalars['Boolean']>;\n  claimedAtLT?: InputMaybe<Scalars['Time']>;\n  claimedAtLTE?: InputMaybe<Scalars['Time']>;\n  claimedAtNEQ?: InputMaybe<Scalars['Time']>;\n  claimedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n  claimedAtNotNil?: InputMaybe<Scalars['Boolean']>;\n  claimedNEQ?: InputMaybe<Scalars['Boolean']>;\n  /** created_at field predicates */\n  createdAt?: InputMaybe<Scalars['Time']>;\n  createdAtGT?: InputMaybe<Scalars['Time']>;\n  createdAtGTE?: InputMaybe<Scalars['Time']>;\n  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  createdAtLT?: InputMaybe<Scalars['Time']>;\n  createdAtLTE?: InputMaybe<Scalars['Time']>;\n  createdAtNEQ?: InputMaybe<Scalars['Time']>;\n  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n  /** merkle_drop edge predicates */\n  hasMerkleDrop?: InputMaybe<Scalars['Boolean']>;\n  hasMerkleDropWith?: InputMaybe<Array<MerkleDropWhereInput>>;\n  /** id field predicates */\n  id?: InputMaybe<Scalars['ID']>;\n  idContainsFold?: InputMaybe<Scalars['ID']>;\n  idEqualFold?: InputMaybe<Scalars['ID']>;\n  idGT?: InputMaybe<Scalars['ID']>;\n  idGTE?: InputMaybe<Scalars['ID']>;\n  idIn?: InputMaybe<Array<Scalars['ID']>>;\n  idLT?: InputMaybe<Scalars['ID']>;\n  idLTE?: InputMaybe<Scalars['ID']>;\n  idNEQ?: InputMaybe<Scalars['ID']>;\n  idNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  /** index field predicates */\n  index?: InputMaybe<Scalars['Int']>;\n  indexGT?: InputMaybe<Scalars['Int']>;\n  indexGTE?: InputMaybe<Scalars['Int']>;\n  indexIn?: InputMaybe<Array<Scalars['Int']>>;\n  indexLT?: InputMaybe<Scalars['Int']>;\n  indexLTE?: InputMaybe<Scalars['Int']>;\n  indexNEQ?: InputMaybe<Scalars['Int']>;\n  indexNotIn?: InputMaybe<Array<Scalars['Int']>>;\n  /** merkle_drop_id field predicates */\n  merkleDropID?: InputMaybe<Scalars['ID']>;\n  merkleDropIDContains?: InputMaybe<Scalars['ID']>;\n  merkleDropIDContainsFold?: InputMaybe<Scalars['ID']>;\n  merkleDropIDEqualFold?: InputMaybe<Scalars['ID']>;\n  merkleDropIDGT?: InputMaybe<Scalars['ID']>;\n  merkleDropIDGTE?: InputMaybe<Scalars['ID']>;\n  merkleDropIDHasPrefix?: InputMaybe<Scalars['ID']>;\n  merkleDropIDHasSuffix?: InputMaybe<Scalars['ID']>;\n  merkleDropIDIn?: InputMaybe<Array<Scalars['ID']>>;\n  merkleDropIDLT?: InputMaybe<Scalars['ID']>;\n  merkleDropIDLTE?: InputMaybe<Scalars['ID']>;\n  merkleDropIDNEQ?: InputMaybe<Scalars['ID']>;\n  merkleDropIDNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  not?: InputMaybe<MerkleClaimWhereInput>;\n  or?: InputMaybe<Array<MerkleClaimWhereInput>>;\n  /** updated_at field predicates */\n  updatedAt?: InputMaybe<Scalars['Time']>;\n  updatedAtGT?: InputMaybe<Scalars['Time']>;\n  updatedAtGTE?: InputMaybe<Scalars['Time']>;\n  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  updatedAtLT?: InputMaybe<Scalars['Time']>;\n  updatedAtLTE?: InputMaybe<Scalars['Time']>;\n  updatedAtNEQ?: InputMaybe<Scalars['Time']>;\n  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n};\n\nexport type MerkleDrop = Node & {\n  __typename?: 'MerkleDrop';\n  claims: MerkleClaimConnection;\n  contract: Scalars['String'];\n  createdAt: Scalars['Time'];\n  description?: Maybe<Scalars['String']>;\n  entrypoint: Scalars['String'];\n  id: Scalars['ID'];\n  key: Scalars['String'];\n  matchStarterpackItem: Scalars['Boolean'];\n  merkleRoot: Scalars['String'];\n  /** Additional metadata for the merkle drop */\n  metadata?: Maybe<Scalars['JSON']>;\n  network: MerkleDropNetwork;\n  salt: Scalars['String'];\n  starterpack?: Maybe<Starterpack>;\n  updatedAt: Scalars['Time'];\n};\n\n\nexport type MerkleDropClaimsArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<MerkleClaimOrder>;\n  where?: InputMaybe<MerkleClaimWhereInput>;\n};\n\n/** A connection to a list of items. */\nexport type MerkleDropConnection = {\n  __typename?: 'MerkleDropConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<MerkleDropEdge>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type MerkleDropEdge = {\n  __typename?: 'MerkleDropEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['Cursor'];\n  /** The item at the end of the edge. */\n  node?: Maybe<MerkleDrop>;\n};\n\n/** MerkleDropNetwork is enum for the field network */\nexport enum MerkleDropNetwork {\n  Arbitrum = 'ARBITRUM',\n  Base = 'BASE',\n  Ethereum = 'ETHEREUM',\n  Optimism = 'OPTIMISM',\n  Polygon = 'POLYGON',\n  Starknet = 'STARKNET'\n}\n\n/** Ordering options for MerkleDrop connections */\nexport type MerkleDropOrder = {\n  /** The ordering direction. */\n  direction?: OrderDirection;\n  /** The field by which to order MerkleDrops. */\n  field: MerkleDropOrderField;\n};\n\n/** Properties by which MerkleDrop connections can be ordered. */\nexport enum MerkleDropOrderField {\n  CreatedAt = 'CREATED_AT'\n}\n\n/**\n * MerkleDropWhereInput is used for filtering MerkleDrop objects.\n * Input was generated by ent.\n */\nexport type MerkleDropWhereInput = {\n  and?: InputMaybe<Array<MerkleDropWhereInput>>;\n  /** contract field predicates */\n  contract?: InputMaybe<Scalars['String']>;\n  contractContains?: InputMaybe<Scalars['String']>;\n  contractContainsFold?: InputMaybe<Scalars['String']>;\n  contractEqualFold?: InputMaybe<Scalars['String']>;\n  contractGT?: InputMaybe<Scalars['String']>;\n  contractGTE?: InputMaybe<Scalars['String']>;\n  contractHasPrefix?: InputMaybe<Scalars['String']>;\n  contractHasSuffix?: InputMaybe<Scalars['String']>;\n  contractIn?: InputMaybe<Array<Scalars['String']>>;\n  contractLT?: InputMaybe<Scalars['String']>;\n  contractLTE?: InputMaybe<Scalars['String']>;\n  contractNEQ?: InputMaybe<Scalars['String']>;\n  contractNotIn?: InputMaybe<Array<Scalars['String']>>;\n  /** created_at field predicates */\n  createdAt?: InputMaybe<Scalars['Time']>;\n  createdAtGT?: InputMaybe<Scalars['Time']>;\n  createdAtGTE?: InputMaybe<Scalars['Time']>;\n  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  createdAtLT?: InputMaybe<Scalars['Time']>;\n  createdAtLTE?: InputMaybe<Scalars['Time']>;\n  createdAtNEQ?: InputMaybe<Scalars['Time']>;\n  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n  /** description field predicates */\n  description?: InputMaybe<Scalars['String']>;\n  descriptionContains?: InputMaybe<Scalars['String']>;\n  descriptionContainsFold?: InputMaybe<Scalars['String']>;\n  descriptionEqualFold?: InputMaybe<Scalars['String']>;\n  descriptionGT?: InputMaybe<Scalars['String']>;\n  descriptionGTE?: InputMaybe<Scalars['String']>;\n  descriptionHasPrefix?: InputMaybe<Scalars['String']>;\n  descriptionHasSuffix?: InputMaybe<Scalars['String']>;\n  descriptionIn?: InputMaybe<Array<Scalars['String']>>;\n  descriptionIsNil?: InputMaybe<Scalars['Boolean']>;\n  descriptionLT?: InputMaybe<Scalars['String']>;\n  descriptionLTE?: InputMaybe<Scalars['String']>;\n  descriptionNEQ?: InputMaybe<Scalars['String']>;\n  descriptionNotIn?: InputMaybe<Array<Scalars['String']>>;\n  descriptionNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** entrypoint field predicates */\n  entrypoint?: InputMaybe<Scalars['String']>;\n  entrypointContains?: InputMaybe<Scalars['String']>;\n  entrypointContainsFold?: InputMaybe<Scalars['String']>;\n  entrypointEqualFold?: InputMaybe<Scalars['String']>;\n  entrypointGT?: InputMaybe<Scalars['String']>;\n  entrypointGTE?: InputMaybe<Scalars['String']>;\n  entrypointHasPrefix?: InputMaybe<Scalars['String']>;\n  entrypointHasSuffix?: InputMaybe<Scalars['String']>;\n  entrypointIn?: InputMaybe<Array<Scalars['String']>>;\n  entrypointLT?: InputMaybe<Scalars['String']>;\n  entrypointLTE?: InputMaybe<Scalars['String']>;\n  entrypointNEQ?: InputMaybe<Scalars['String']>;\n  entrypointNotIn?: InputMaybe<Array<Scalars['String']>>;\n  /** claims edge predicates */\n  hasClaims?: InputMaybe<Scalars['Boolean']>;\n  hasClaimsWith?: InputMaybe<Array<MerkleClaimWhereInput>>;\n  /** starterpack edge predicates */\n  hasStarterpack?: InputMaybe<Scalars['Boolean']>;\n  hasStarterpackWith?: InputMaybe<Array<StarterpackWhereInput>>;\n  /** id field predicates */\n  id?: InputMaybe<Scalars['ID']>;\n  idContainsFold?: InputMaybe<Scalars['ID']>;\n  idEqualFold?: InputMaybe<Scalars['ID']>;\n  idGT?: InputMaybe<Scalars['ID']>;\n  idGTE?: InputMaybe<Scalars['ID']>;\n  idIn?: InputMaybe<Array<Scalars['ID']>>;\n  idLT?: InputMaybe<Scalars['ID']>;\n  idLTE?: InputMaybe<Scalars['ID']>;\n  idNEQ?: InputMaybe<Scalars['ID']>;\n  idNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  /** key field predicates */\n  key?: InputMaybe<Scalars['String']>;\n  keyContains?: InputMaybe<Scalars['String']>;\n  keyContainsFold?: InputMaybe<Scalars['String']>;\n  keyEqualFold?: InputMaybe<Scalars['String']>;\n  keyGT?: InputMaybe<Scalars['String']>;\n  keyGTE?: InputMaybe<Scalars['String']>;\n  keyHasPrefix?: InputMaybe<Scalars['String']>;\n  keyHasSuffix?: InputMaybe<Scalars['String']>;\n  keyIn?: InputMaybe<Array<Scalars['String']>>;\n  keyLT?: InputMaybe<Scalars['String']>;\n  keyLTE?: InputMaybe<Scalars['String']>;\n  keyNEQ?: InputMaybe<Scalars['String']>;\n  keyNotIn?: InputMaybe<Array<Scalars['String']>>;\n  /** match_starterpack_item field predicates */\n  matchStarterpackItem?: InputMaybe<Scalars['Boolean']>;\n  matchStarterpackItemNEQ?: InputMaybe<Scalars['Boolean']>;\n  /** merkle_root field predicates */\n  merkleRoot?: InputMaybe<Scalars['String']>;\n  merkleRootContains?: InputMaybe<Scalars['String']>;\n  merkleRootContainsFold?: InputMaybe<Scalars['String']>;\n  merkleRootEqualFold?: InputMaybe<Scalars['String']>;\n  merkleRootGT?: InputMaybe<Scalars['String']>;\n  merkleRootGTE?: InputMaybe<Scalars['String']>;\n  merkleRootHasPrefix?: InputMaybe<Scalars['String']>;\n  merkleRootHasSuffix?: InputMaybe<Scalars['String']>;\n  merkleRootIn?: InputMaybe<Array<Scalars['String']>>;\n  merkleRootLT?: InputMaybe<Scalars['String']>;\n  merkleRootLTE?: InputMaybe<Scalars['String']>;\n  merkleRootNEQ?: InputMaybe<Scalars['String']>;\n  merkleRootNotIn?: InputMaybe<Array<Scalars['String']>>;\n  /** network field predicates */\n  network?: InputMaybe<MerkleDropNetwork>;\n  networkIn?: InputMaybe<Array<MerkleDropNetwork>>;\n  networkNEQ?: InputMaybe<MerkleDropNetwork>;\n  networkNotIn?: InputMaybe<Array<MerkleDropNetwork>>;\n  not?: InputMaybe<MerkleDropWhereInput>;\n  or?: InputMaybe<Array<MerkleDropWhereInput>>;\n  /** salt field predicates */\n  salt?: InputMaybe<Scalars['String']>;\n  saltContains?: InputMaybe<Scalars['String']>;\n  saltContainsFold?: InputMaybe<Scalars['String']>;\n  saltEqualFold?: InputMaybe<Scalars['String']>;\n  saltGT?: InputMaybe<Scalars['String']>;\n  saltGTE?: InputMaybe<Scalars['String']>;\n  saltHasPrefix?: InputMaybe<Scalars['String']>;\n  saltHasSuffix?: InputMaybe<Scalars['String']>;\n  saltIn?: InputMaybe<Array<Scalars['String']>>;\n  saltLT?: InputMaybe<Scalars['String']>;\n  saltLTE?: InputMaybe<Scalars['String']>;\n  saltNEQ?: InputMaybe<Scalars['String']>;\n  saltNotIn?: InputMaybe<Array<Scalars['String']>>;\n  /** updated_at field predicates */\n  updatedAt?: InputMaybe<Scalars['Time']>;\n  updatedAtGT?: InputMaybe<Scalars['Time']>;\n  updatedAtGTE?: InputMaybe<Scalars['Time']>;\n  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  updatedAtLT?: InputMaybe<Scalars['Time']>;\n  updatedAtLTE?: InputMaybe<Scalars['Time']>;\n  updatedAtNEQ?: InputMaybe<Scalars['Time']>;\n  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n};\n\nexport type MetricsEntry = {\n  __typename?: 'MetricsEntry';\n  callerCount: Scalars['Int'];\n  transactionCount: Scalars['Int'];\n  transactionDate: Scalars['String'];\n};\n\nexport type MetricsItem = {\n  __typename?: 'MetricsItem';\n  meta: MetricsMeta;\n  metrics: Array<MetricsEntry>;\n};\n\nexport type MetricsMeta = {\n  __typename?: 'MetricsMeta';\n  count: Scalars['Int'];\n  error?: Maybe<Scalars['String']>;\n  project: Scalars['String'];\n};\n\nexport type MetricsProject = {\n  project: Scalars['String'];\n};\n\nexport type MetricsResult = {\n  __typename?: 'MetricsResult';\n  items: Array<MetricsItem>;\n};\n\nexport type MintAllowance = {\n  __typename?: 'MintAllowance';\n  count: Scalars['Int'];\n  limit: Scalars['Int'];\n};\n\nexport type Mutation = {\n  __typename?: 'Mutation';\n  addOwner: Scalars['Boolean'];\n  addPolicies?: Maybe<Array<PaymasterPolicy>>;\n  addToTeam: Scalars['Boolean'];\n  beginLogin: Scalars['JSON'];\n  beginRegistration: Scalars['JSON'];\n  claimFreeStarterpack: Scalars['String'];\n  /**\n   * Create a Coinbase onramp order for purchasing USDC via Apple Pay.\n   * Returns a payment link URL that can be used to complete the purchase.\n   */\n  createCoinbaseOnrampOrder: CoinbaseOnrampOrder;\n  /**\n   * Create a Coinbase onramp session with a single-use URL.\n   * This is the recommended approach for integrating Coinbase onramp.\n   * Returns a session token and URL that can be used once to complete a purchase.\n   */\n  createCoinbaseOnrampSession: CoinbaseOnrampSession;\n  createCryptoPayment: CryptoPayment;\n  createDeployment: Deployment;\n  createLayerswapDeposit: LayerswapPayment;\n  createLayerswapPayment: LayerswapPayment;\n  createMerkleDrop: MerkleDrop;\n  createPaymaster: Paymaster;\n  createRpcApiKey: CreateRpcApiKeyPayload;\n  createRpcCorsDomain: RpcCorsDomain;\n  createSession: Scalars['String'];\n  createStripePaymentIntent: StripePaymentIntent;\n  createTeam: Team;\n  decreaseBudget: Paymaster;\n  deleteDeployment: Scalars['Boolean'];\n  deleteRpcApiKey: Scalars['Boolean'];\n  deleteRpcCorsDomain: Scalars['Boolean'];\n  deleteTeam: Scalars['Boolean'];\n  finalizeLogin: Scalars['String'];\n  finalizeRegistration: Account;\n  increaseBudget: Paymaster;\n  register: Account;\n  removeAllPolicies: Scalars['Boolean'];\n  removeFromTeam: Scalars['Boolean'];\n  removeOwner: Scalars['Boolean'];\n  removePaymaster: Scalars['Boolean'];\n  removePolicy: Scalars['Boolean'];\n  revokeSessions: Scalars['Boolean'];\n  transfer: TransferResponse;\n  transferDeployment: Scalars['Boolean'];\n  updateDeployment: Deployment;\n  updateMe: Account;\n  updatePaymaster: Scalars['Boolean'];\n  updateRpcApiKey: RpcApiKey;\n  updateRpcCorsDomain: RpcCorsDomain;\n  updateTeam: Team;\n};\n\n\nexport type MutationAddOwnerArgs = {\n  chainID: Scalars['String'];\n  owner: SignerInput;\n  signerGuid: Scalars['Felt'];\n  username: Scalars['String'];\n};\n\n\nexport type MutationAddPoliciesArgs = {\n  paymasterName: Scalars['ID'];\n  policies?: InputMaybe<Array<PolicyInput>>;\n};\n\n\nexport type MutationAddToTeamArgs = {\n  name: Scalars['ID'];\n  usernames: Array<Scalars['String']>;\n};\n\n\nexport type MutationBeginLoginArgs = {\n  username: Scalars['String'];\n};\n\n\nexport type MutationBeginRegistrationArgs = {\n  username: Scalars['String'];\n};\n\n\nexport type MutationClaimFreeStarterpackArgs = {\n  input: StarterpackInput;\n};\n\n\nexport type MutationCreateCoinbaseOnrampOrderArgs = {\n  input: CreateCoinbaseOnrampOrderInput;\n};\n\n\nexport type MutationCreateCoinbaseOnrampSessionArgs = {\n  input: CreateCoinbaseOnrampSessionInput;\n};\n\n\nexport type MutationCreateCryptoPaymentArgs = {\n  input: CreateCryptoPaymentInput;\n};\n\n\nexport type MutationCreateDeploymentArgs = {\n  name: Scalars['String'];\n  observability?: InputMaybe<Scalars['Boolean']>;\n  regions?: InputMaybe<Array<Scalars['String']>>;\n  service: CreateServiceInput;\n  team?: InputMaybe<Scalars['String']>;\n  tier?: InputMaybe<DeploymentTier>;\n  wait?: InputMaybe<Scalars['Boolean']>;\n};\n\n\nexport type MutationCreateLayerswapDepositArgs = {\n  input: CreateLayerswapDepositInput;\n};\n\n\nexport type MutationCreateLayerswapPaymentArgs = {\n  input: CreateLayerswapPaymentInput;\n};\n\n\nexport type MutationCreateMerkleDropArgs = {\n  claims: Array<MerkleClaimInput>;\n  contract: Scalars['Felt'];\n  description?: InputMaybe<Scalars['String']>;\n  entrypoint: Scalars['String'];\n  key: Scalars['String'];\n  network: MerkleDropNetwork;\n  salt: Scalars['String'];\n};\n\n\nexport type MutationCreatePaymasterArgs = {\n  budget: Scalars['Int'];\n  name: Scalars['String'];\n  teamName: Scalars['String'];\n  unit: FeeUnit;\n};\n\n\nexport type MutationCreateRpcApiKeyArgs = {\n  name: Scalars['String'];\n  teamName: Scalars['String'];\n};\n\n\nexport type MutationCreateRpcCorsDomainArgs = {\n  domain: Scalars['String'];\n  rateLimitPerMinute?: InputMaybe<Scalars['Int']>;\n  teamName: Scalars['String'];\n};\n\n\nexport type MutationCreateSessionArgs = {\n  appId: Scalars['String'];\n  chainId: Scalars['String'];\n  session: SessionInput;\n  username: Scalars['String'];\n};\n\n\nexport type MutationCreateStripePaymentIntentArgs = {\n  input: CreateStripePaymentIntentInput;\n};\n\n\nexport type MutationCreateTeamArgs = {\n  data?: InputMaybe<TeamInput>;\n  name: Scalars['String'];\n};\n\n\nexport type MutationDecreaseBudgetArgs = {\n  amount: Scalars['Int'];\n  paymasterName: Scalars['ID'];\n  unit: FeeUnit;\n};\n\n\nexport type MutationDeleteDeploymentArgs = {\n  name: Scalars['String'];\n  service: DeploymentService;\n};\n\n\nexport type MutationDeleteRpcApiKeyArgs = {\n  id: Scalars['ID'];\n};\n\n\nexport type MutationDeleteRpcCorsDomainArgs = {\n  id: Scalars['ID'];\n};\n\n\nexport type MutationDeleteTeamArgs = {\n  name: Scalars['String'];\n};\n\n\nexport type MutationFinalizeLoginArgs = {\n  credentials: Scalars['String'];\n};\n\n\nexport type MutationFinalizeRegistrationArgs = {\n  credentials: Scalars['String'];\n  network: Scalars['String'];\n};\n\n\nexport type MutationIncreaseBudgetArgs = {\n  amount: Scalars['Int'];\n  paymasterName: Scalars['ID'];\n  unit: FeeUnit;\n};\n\n\nexport type MutationRegisterArgs = {\n  chainId: Scalars['String'];\n  owner: SignerInput;\n  session: SessionInput;\n  username: Scalars['String'];\n};\n\n\nexport type MutationRemoveAllPoliciesArgs = {\n  paymasterName: Scalars['ID'];\n};\n\n\nexport type MutationRemoveFromTeamArgs = {\n  name: Scalars['ID'];\n  usernames: Array<Scalars['String']>;\n};\n\n\nexport type MutationRemoveOwnerArgs = {\n  chainID: Scalars['String'];\n  owner: SignerInput;\n  signerGuid: Scalars['Felt'];\n  username: Scalars['String'];\n};\n\n\nexport type MutationRemovePaymasterArgs = {\n  paymasterName: Scalars['ID'];\n};\n\n\nexport type MutationRemovePolicyArgs = {\n  paymasterName: Scalars['ID'];\n  policy: PolicyInput;\n};\n\n\nexport type MutationRevokeSessionsArgs = {\n  sessions: Array<RevokeSessionInput>;\n};\n\n\nexport type MutationTransferArgs = {\n  data: TransferInput;\n};\n\n\nexport type MutationTransferDeploymentArgs = {\n  name: Scalars['String'];\n  service: DeploymentService;\n  team: Scalars['String'];\n};\n\n\nexport type MutationUpdateDeploymentArgs = {\n  name: Scalars['String'];\n  observability?: InputMaybe<Scalars['Boolean']>;\n  service: UpdateServiceInput;\n  tier?: InputMaybe<DeploymentTier>;\n  wait?: InputMaybe<Scalars['Boolean']>;\n};\n\n\nexport type MutationUpdateMeArgs = {\n  data: AccountUpdateInput;\n};\n\n\nexport type MutationUpdatePaymasterArgs = {\n  active?: InputMaybe<Scalars['Boolean']>;\n  newName?: InputMaybe<Scalars['String']>;\n  paymasterName: Scalars['ID'];\n  teamName?: InputMaybe<Scalars['String']>;\n};\n\n\nexport type MutationUpdateRpcApiKeyArgs = {\n  id: Scalars['ID'];\n  update: RpcApiKeyInput;\n};\n\n\nexport type MutationUpdateRpcCorsDomainArgs = {\n  id: Scalars['ID'];\n  update: RpcCorsDomainInput;\n};\n\n\nexport type MutationUpdateTeamArgs = {\n  name: Scalars['String'];\n  update: TeamInput;\n};\n\nexport enum Network {\n  Solana = 'SOLANA',\n  Starknet = 'STARKNET'\n}\n\n/**\n * An object with an ID.\n * Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)\n */\nexport type Node = {\n  /** The id of the object. */\n  id: Scalars['ID'];\n};\n\nexport enum Order {\n  Asc = 'asc',\n  Desc = 'desc'\n}\n\n/** Possible directions in which to order a list of items when provided an `orderBy` argument. */\nexport enum OrderDirection {\n  /** Specifies an ascending order for a given `orderBy` argument. */\n  Asc = 'ASC',\n  /** Specifies a descending order for a given `orderBy` argument. */\n  Desc = 'DESC'\n}\n\nexport type Ownership = {\n  __typename?: 'Ownership';\n  accountAddress: Scalars['String'];\n  balance: Scalars['String'];\n  contractAddress: Scalars['String'];\n  tokenId: Scalars['String'];\n};\n\nexport type OwnershipItem = {\n  __typename?: 'OwnershipItem';\n  meta: OwnershipMeta;\n  ownerships: Array<Ownership>;\n};\n\nexport type OwnershipMeta = {\n  __typename?: 'OwnershipMeta';\n  contractAddresses: Array<Scalars['String']>;\n  count: Scalars['Int'];\n  error?: Maybe<Scalars['String']>;\n  limit: Scalars['Int'];\n  project: Scalars['String'];\n  tokenIds: Array<Scalars['String']>;\n};\n\nexport type OwnershipProject = {\n  contractAddresses: Array<Scalars['String']>;\n  limit: Scalars['Int'];\n  project: Scalars['String'];\n  tokenIds: Array<Scalars['String']>;\n};\n\nexport type OwnershipResult = {\n  __typename?: 'OwnershipResult';\n  items: Array<OwnershipItem>;\n};\n\n/**\n * Information about pagination in a connection.\n * https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo\n */\nexport type PageInfo = {\n  __typename?: 'PageInfo';\n  /** When paginating forwards, the cursor to continue. */\n  endCursor?: Maybe<Scalars['Cursor']>;\n  /** When paginating forwards, are there more items? */\n  hasNextPage: Scalars['Boolean'];\n  /** When paginating backwards, are there more items? */\n  hasPreviousPage: Scalars['Boolean'];\n  /** When paginating backwards, the cursor to continue. */\n  startCursor?: Maybe<Scalars['Cursor']>;\n};\n\nexport type PasswordCredential = {\n  __typename?: 'PasswordCredential';\n  encryptedPrivateKey: Scalars['String'];\n  publicKey: Scalars['String'];\n};\n\nexport type PasswordCredentials = {\n  __typename?: 'PasswordCredentials';\n  password?: Maybe<Array<PasswordCredential>>;\n};\n\nexport type Paymaster = Node & {\n  __typename?: 'Paymaster';\n  active: Scalars['Boolean'];\n  activities: ActivityConnection;\n  /** Budget in 6 decimal precision */\n  budget: Scalars['Int'];\n  budgetFeeUnit: PaymasterBudgetFeeUnit;\n  createdAt: Scalars['Time'];\n  /** Accumulated CREDITS fees in 6 decimal precision */\n  creditFees: Scalars['Int'];\n  id: Scalars['ID'];\n  legacyEthFees: Scalars['Int'];\n  legacyRevertedTransactions: Scalars['Int'];\n  legacyStrkFees: Scalars['Int'];\n  legacySuccessfulTransactions: Scalars['Int'];\n  name: Scalars['String'];\n  outbox: PaymasterOutboxConnection;\n  policies: PaymasterPolicyConnection;\n  /** Number of reverted transactions */\n  revertedTransactions: Scalars['Int'];\n  starterpacks: StarterpackConnection;\n  /** Accumulated STRK fees in 6 decimal precision */\n  strkFees: Scalars['Int'];\n  /** Number of successful transactions */\n  successfulTransactions: Scalars['Int'];\n  team?: Maybe<Team>;\n  updatedAt: Scalars['Time'];\n};\n\n\nexport type PaymasterActivitiesArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ActivityOrder>;\n  where?: InputMaybe<ActivityWhereInput>;\n};\n\n\nexport type PaymasterOutboxArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<PaymasterOutboxOrder>;\n  where?: InputMaybe<PaymasterOutboxWhereInput>;\n};\n\n\nexport type PaymasterPoliciesArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<PaymasterPolicyOrder>;\n  where?: InputMaybe<PaymasterPolicyWhereInput>;\n};\n\n\nexport type PaymasterStarterpacksArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<StarterpackOrder>;\n  where?: InputMaybe<StarterpackWhereInput>;\n};\n\n/** PaymasterBudgetFeeUnit is enum for the field budget_fee_unit */\nexport enum PaymasterBudgetFeeUnit {\n  Credit = 'CREDIT',\n  Strk = 'STRK'\n}\n\n/** A connection to a list of items. */\nexport type PaymasterConnection = {\n  __typename?: 'PaymasterConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PaymasterEdge>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type PaymasterEdge = {\n  __typename?: 'PaymasterEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['Cursor'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Paymaster>;\n};\n\n/** Ordering options for Paymaster connections */\nexport type PaymasterOrder = {\n  /** The ordering direction. */\n  direction?: OrderDirection;\n  /** The field by which to order Paymasters. */\n  field: PaymasterOrderField;\n};\n\n/** Properties by which Paymaster connections can be ordered. */\nexport enum PaymasterOrderField {\n  CreatedAt = 'CREATED_AT'\n}\n\nexport type PaymasterOutbox = Node & {\n  __typename?: 'PaymasterOutbox';\n  claimToken?: Maybe<Scalars['String']>;\n  claimedAt?: Maybe<Scalars['Time']>;\n  createdAt: Scalars['Time'];\n  creditFee: Scalars['Int'];\n  id: Scalars['ID'];\n  paymaster: Paymaster;\n  /** Paymaster ID */\n  paymasterID: Scalars['ID'];\n  status: PaymasterOutboxStatus;\n  strkFee: Scalars['Int'];\n  transactionHash: Scalars['String'];\n  transactionStatus: PaymasterOutboxTransactionStatus;\n  updatedAt: Scalars['Time'];\n};\n\n/** A connection to a list of items. */\nexport type PaymasterOutboxConnection = {\n  __typename?: 'PaymasterOutboxConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PaymasterOutboxEdge>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type PaymasterOutboxEdge = {\n  __typename?: 'PaymasterOutboxEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['Cursor'];\n  /** The item at the end of the edge. */\n  node?: Maybe<PaymasterOutbox>;\n};\n\n/** Ordering options for PaymasterOutbox connections */\nexport type PaymasterOutboxOrder = {\n  /** The ordering direction. */\n  direction?: OrderDirection;\n  /** The field by which to order PaymasterOutboxes. */\n  field: PaymasterOutboxOrderField;\n};\n\n/** Properties by which PaymasterOutbox connections can be ordered. */\nexport enum PaymasterOutboxOrderField {\n  CreatedAt = 'CREATED_AT'\n}\n\n/** PaymasterOutboxStatus is enum for the field status */\nexport enum PaymasterOutboxStatus {\n  New = 'NEW',\n  Processing = 'PROCESSING'\n}\n\n/** PaymasterOutboxTransactionStatus is enum for the field transaction_status */\nexport enum PaymasterOutboxTransactionStatus {\n  Reverted = 'REVERTED',\n  Success = 'SUCCESS'\n}\n\n/**\n * PaymasterOutboxWhereInput is used for filtering PaymasterOutbox objects.\n * Input was generated by ent.\n */\nexport type PaymasterOutboxWhereInput = {\n  and?: InputMaybe<Array<PaymasterOutboxWhereInput>>;\n  /** claim_token field predicates */\n  claimToken?: InputMaybe<Scalars['String']>;\n  claimTokenContains?: InputMaybe<Scalars['String']>;\n  claimTokenContainsFold?: InputMaybe<Scalars['String']>;\n  claimTokenEqualFold?: InputMaybe<Scalars['String']>;\n  claimTokenGT?: InputMaybe<Scalars['String']>;\n  claimTokenGTE?: InputMaybe<Scalars['String']>;\n  claimTokenHasPrefix?: InputMaybe<Scalars['String']>;\n  claimTokenHasSuffix?: InputMaybe<Scalars['String']>;\n  claimTokenIn?: InputMaybe<Array<Scalars['String']>>;\n  claimTokenIsNil?: InputMaybe<Scalars['Boolean']>;\n  claimTokenLT?: InputMaybe<Scalars['String']>;\n  claimTokenLTE?: InputMaybe<Scalars['String']>;\n  claimTokenNEQ?: InputMaybe<Scalars['String']>;\n  claimTokenNotIn?: InputMaybe<Array<Scalars['String']>>;\n  claimTokenNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** claimed_at field predicates */\n  claimedAt?: InputMaybe<Scalars['Time']>;\n  claimedAtGT?: InputMaybe<Scalars['Time']>;\n  claimedAtGTE?: InputMaybe<Scalars['Time']>;\n  claimedAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  claimedAtIsNil?: InputMaybe<Scalars['Boolean']>;\n  claimedAtLT?: InputMaybe<Scalars['Time']>;\n  claimedAtLTE?: InputMaybe<Scalars['Time']>;\n  claimedAtNEQ?: InputMaybe<Scalars['Time']>;\n  claimedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n  claimedAtNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** created_at field predicates */\n  createdAt?: InputMaybe<Scalars['Time']>;\n  createdAtGT?: InputMaybe<Scalars['Time']>;\n  createdAtGTE?: InputMaybe<Scalars['Time']>;\n  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  createdAtLT?: InputMaybe<Scalars['Time']>;\n  createdAtLTE?: InputMaybe<Scalars['Time']>;\n  createdAtNEQ?: InputMaybe<Scalars['Time']>;\n  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n  /** credit_fee field predicates */\n  creditFee?: InputMaybe<Scalars['Int']>;\n  creditFeeGT?: InputMaybe<Scalars['Int']>;\n  creditFeeGTE?: InputMaybe<Scalars['Int']>;\n  creditFeeIn?: InputMaybe<Array<Scalars['Int']>>;\n  creditFeeLT?: InputMaybe<Scalars['Int']>;\n  creditFeeLTE?: InputMaybe<Scalars['Int']>;\n  creditFeeNEQ?: InputMaybe<Scalars['Int']>;\n  creditFeeNotIn?: InputMaybe<Array<Scalars['Int']>>;\n  /** paymaster edge predicates */\n  hasPaymaster?: InputMaybe<Scalars['Boolean']>;\n  hasPaymasterWith?: InputMaybe<Array<PaymasterWhereInput>>;\n  /** id field predicates */\n  id?: InputMaybe<Scalars['ID']>;\n  idContainsFold?: InputMaybe<Scalars['ID']>;\n  idEqualFold?: InputMaybe<Scalars['ID']>;\n  idGT?: InputMaybe<Scalars['ID']>;\n  idGTE?: InputMaybe<Scalars['ID']>;\n  idIn?: InputMaybe<Array<Scalars['ID']>>;\n  idLT?: InputMaybe<Scalars['ID']>;\n  idLTE?: InputMaybe<Scalars['ID']>;\n  idNEQ?: InputMaybe<Scalars['ID']>;\n  idNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  not?: InputMaybe<PaymasterOutboxWhereInput>;\n  or?: InputMaybe<Array<PaymasterOutboxWhereInput>>;\n  /** paymaster_id field predicates */\n  paymasterID?: InputMaybe<Scalars['ID']>;\n  paymasterIDContains?: InputMaybe<Scalars['ID']>;\n  paymasterIDContainsFold?: InputMaybe<Scalars['ID']>;\n  paymasterIDEqualFold?: InputMaybe<Scalars['ID']>;\n  paymasterIDGT?: InputMaybe<Scalars['ID']>;\n  paymasterIDGTE?: InputMaybe<Scalars['ID']>;\n  paymasterIDHasPrefix?: InputMaybe<Scalars['ID']>;\n  paymasterIDHasSuffix?: InputMaybe<Scalars['ID']>;\n  paymasterIDIn?: InputMaybe<Array<Scalars['ID']>>;\n  paymasterIDLT?: InputMaybe<Scalars['ID']>;\n  paymasterIDLTE?: InputMaybe<Scalars['ID']>;\n  paymasterIDNEQ?: InputMaybe<Scalars['ID']>;\n  paymasterIDNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  /** status field predicates */\n  status?: InputMaybe<PaymasterOutboxStatus>;\n  statusIn?: InputMaybe<Array<PaymasterOutboxStatus>>;\n  statusNEQ?: InputMaybe<PaymasterOutboxStatus>;\n  statusNotIn?: InputMaybe<Array<PaymasterOutboxStatus>>;\n  /** strk_fee field predicates */\n  strkFee?: InputMaybe<Scalars['Int']>;\n  strkFeeGT?: InputMaybe<Scalars['Int']>;\n  strkFeeGTE?: InputMaybe<Scalars['Int']>;\n  strkFeeIn?: InputMaybe<Array<Scalars['Int']>>;\n  strkFeeLT?: InputMaybe<Scalars['Int']>;\n  strkFeeLTE?: InputMaybe<Scalars['Int']>;\n  strkFeeNEQ?: InputMaybe<Scalars['Int']>;\n  strkFeeNotIn?: InputMaybe<Array<Scalars['Int']>>;\n  /** transaction_hash field predicates */\n  transactionHash?: InputMaybe<Scalars['String']>;\n  transactionHashContains?: InputMaybe<Scalars['String']>;\n  transactionHashContainsFold?: InputMaybe<Scalars['String']>;\n  transactionHashEqualFold?: InputMaybe<Scalars['String']>;\n  transactionHashGT?: InputMaybe<Scalars['String']>;\n  transactionHashGTE?: InputMaybe<Scalars['String']>;\n  transactionHashHasPrefix?: InputMaybe<Scalars['String']>;\n  transactionHashHasSuffix?: InputMaybe<Scalars['String']>;\n  transactionHashIn?: InputMaybe<Array<Scalars['String']>>;\n  transactionHashLT?: InputMaybe<Scalars['String']>;\n  transactionHashLTE?: InputMaybe<Scalars['String']>;\n  transactionHashNEQ?: InputMaybe<Scalars['String']>;\n  transactionHashNotIn?: InputMaybe<Array<Scalars['String']>>;\n  /** transaction_status field predicates */\n  transactionStatus?: InputMaybe<PaymasterOutboxTransactionStatus>;\n  transactionStatusIn?: InputMaybe<Array<PaymasterOutboxTransactionStatus>>;\n  transactionStatusNEQ?: InputMaybe<PaymasterOutboxTransactionStatus>;\n  transactionStatusNotIn?: InputMaybe<Array<PaymasterOutboxTransactionStatus>>;\n  /** updated_at field predicates */\n  updatedAt?: InputMaybe<Scalars['Time']>;\n  updatedAtGT?: InputMaybe<Scalars['Time']>;\n  updatedAtGTE?: InputMaybe<Scalars['Time']>;\n  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  updatedAtLT?: InputMaybe<Scalars['Time']>;\n  updatedAtLTE?: InputMaybe<Scalars['Time']>;\n  updatedAtNEQ?: InputMaybe<Scalars['Time']>;\n  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n};\n\nexport type PaymasterPolicy = Node & {\n  __typename?: 'PaymasterPolicy';\n  active: Scalars['Boolean'];\n  contractAddress: Scalars['String'];\n  createdAt: Scalars['Time'];\n  entryPoint: Scalars['String'];\n  id: Scalars['ID'];\n  paymasterID?: Maybe<Scalars['ID']>;\n  paymasters?: Maybe<Paymaster>;\n  /** Predicate configuration for the policy */\n  predicate?: Maybe<PolicyPredicate>;\n  /** If set, this policy only applies to requests from the specified katana project (e.g., 'myproject' for /x/myproject/katana) */\n  requiredKatanaProject?: Maybe<Scalars['String']>;\n  selector: Scalars['String'];\n  /** Trigger configuration - policy only applies if this call exists in the multicall */\n  trigger?: Maybe<PolicyTrigger>;\n  updatedAt: Scalars['Time'];\n};\n\n/** A connection to a list of items. */\nexport type PaymasterPolicyConnection = {\n  __typename?: 'PaymasterPolicyConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PaymasterPolicyEdge>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type PaymasterPolicyEdge = {\n  __typename?: 'PaymasterPolicyEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['Cursor'];\n  /** The item at the end of the edge. */\n  node?: Maybe<PaymasterPolicy>;\n};\n\n/** Ordering options for PaymasterPolicy connections */\nexport type PaymasterPolicyOrder = {\n  /** The ordering direction. */\n  direction?: OrderDirection;\n  /** The field by which to order PaymasterPolicies. */\n  field: PaymasterPolicyOrderField;\n};\n\n/** Properties by which PaymasterPolicy connections can be ordered. */\nexport enum PaymasterPolicyOrderField {\n  CreatedAt = 'CREATED_AT'\n}\n\n/**\n * PaymasterPolicyWhereInput is used for filtering PaymasterPolicy objects.\n * Input was generated by ent.\n */\nexport type PaymasterPolicyWhereInput = {\n  /** active field predicates */\n  active?: InputMaybe<Scalars['Boolean']>;\n  activeNEQ?: InputMaybe<Scalars['Boolean']>;\n  and?: InputMaybe<Array<PaymasterPolicyWhereInput>>;\n  /** contract_address field predicates */\n  contractAddress?: InputMaybe<Scalars['String']>;\n  contractAddressContains?: InputMaybe<Scalars['String']>;\n  contractAddressContainsFold?: InputMaybe<Scalars['String']>;\n  contractAddressEqualFold?: InputMaybe<Scalars['String']>;\n  contractAddressGT?: InputMaybe<Scalars['String']>;\n  contractAddressGTE?: InputMaybe<Scalars['String']>;\n  contractAddressHasPrefix?: InputMaybe<Scalars['String']>;\n  contractAddressHasSuffix?: InputMaybe<Scalars['String']>;\n  contractAddressIn?: InputMaybe<Array<Scalars['String']>>;\n  contractAddressLT?: InputMaybe<Scalars['String']>;\n  contractAddressLTE?: InputMaybe<Scalars['String']>;\n  contractAddressNEQ?: InputMaybe<Scalars['String']>;\n  contractAddressNotIn?: InputMaybe<Array<Scalars['String']>>;\n  /** created_at field predicates */\n  createdAt?: InputMaybe<Scalars['Time']>;\n  createdAtGT?: InputMaybe<Scalars['Time']>;\n  createdAtGTE?: InputMaybe<Scalars['Time']>;\n  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  createdAtLT?: InputMaybe<Scalars['Time']>;\n  createdAtLTE?: InputMaybe<Scalars['Time']>;\n  createdAtNEQ?: InputMaybe<Scalars['Time']>;\n  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n  /** entry_point field predicates */\n  entryPoint?: InputMaybe<Scalars['String']>;\n  entryPointContains?: InputMaybe<Scalars['String']>;\n  entryPointContainsFold?: InputMaybe<Scalars['String']>;\n  entryPointEqualFold?: InputMaybe<Scalars['String']>;\n  entryPointGT?: InputMaybe<Scalars['String']>;\n  entryPointGTE?: InputMaybe<Scalars['String']>;\n  entryPointHasPrefix?: InputMaybe<Scalars['String']>;\n  entryPointHasSuffix?: InputMaybe<Scalars['String']>;\n  entryPointIn?: InputMaybe<Array<Scalars['String']>>;\n  entryPointLT?: InputMaybe<Scalars['String']>;\n  entryPointLTE?: InputMaybe<Scalars['String']>;\n  entryPointNEQ?: InputMaybe<Scalars['String']>;\n  entryPointNotIn?: InputMaybe<Array<Scalars['String']>>;\n  /** paymasters edge predicates */\n  hasPaymasters?: InputMaybe<Scalars['Boolean']>;\n  hasPaymastersWith?: InputMaybe<Array<PaymasterWhereInput>>;\n  /** id field predicates */\n  id?: InputMaybe<Scalars['ID']>;\n  idContainsFold?: InputMaybe<Scalars['ID']>;\n  idEqualFold?: InputMaybe<Scalars['ID']>;\n  idGT?: InputMaybe<Scalars['ID']>;\n  idGTE?: InputMaybe<Scalars['ID']>;\n  idIn?: InputMaybe<Array<Scalars['ID']>>;\n  idLT?: InputMaybe<Scalars['ID']>;\n  idLTE?: InputMaybe<Scalars['ID']>;\n  idNEQ?: InputMaybe<Scalars['ID']>;\n  idNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  not?: InputMaybe<PaymasterPolicyWhereInput>;\n  or?: InputMaybe<Array<PaymasterPolicyWhereInput>>;\n  /** paymaster_id field predicates */\n  paymasterID?: InputMaybe<Scalars['ID']>;\n  paymasterIDContains?: InputMaybe<Scalars['ID']>;\n  paymasterIDContainsFold?: InputMaybe<Scalars['ID']>;\n  paymasterIDEqualFold?: InputMaybe<Scalars['ID']>;\n  paymasterIDGT?: InputMaybe<Scalars['ID']>;\n  paymasterIDGTE?: InputMaybe<Scalars['ID']>;\n  paymasterIDHasPrefix?: InputMaybe<Scalars['ID']>;\n  paymasterIDHasSuffix?: InputMaybe<Scalars['ID']>;\n  paymasterIDIn?: InputMaybe<Array<Scalars['ID']>>;\n  paymasterIDIsNil?: InputMaybe<Scalars['Boolean']>;\n  paymasterIDLT?: InputMaybe<Scalars['ID']>;\n  paymasterIDLTE?: InputMaybe<Scalars['ID']>;\n  paymasterIDNEQ?: InputMaybe<Scalars['ID']>;\n  paymasterIDNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  paymasterIDNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** required_katana_project field predicates */\n  requiredKatanaProject?: InputMaybe<Scalars['String']>;\n  requiredKatanaProjectContains?: InputMaybe<Scalars['String']>;\n  requiredKatanaProjectContainsFold?: InputMaybe<Scalars['String']>;\n  requiredKatanaProjectEqualFold?: InputMaybe<Scalars['String']>;\n  requiredKatanaProjectGT?: InputMaybe<Scalars['String']>;\n  requiredKatanaProjectGTE?: InputMaybe<Scalars['String']>;\n  requiredKatanaProjectHasPrefix?: InputMaybe<Scalars['String']>;\n  requiredKatanaProjectHasSuffix?: InputMaybe<Scalars['String']>;\n  requiredKatanaProjectIn?: InputMaybe<Array<Scalars['String']>>;\n  requiredKatanaProjectIsNil?: InputMaybe<Scalars['Boolean']>;\n  requiredKatanaProjectLT?: InputMaybe<Scalars['String']>;\n  requiredKatanaProjectLTE?: InputMaybe<Scalars['String']>;\n  requiredKatanaProjectNEQ?: InputMaybe<Scalars['String']>;\n  requiredKatanaProjectNotIn?: InputMaybe<Array<Scalars['String']>>;\n  requiredKatanaProjectNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** selector field predicates */\n  selector?: InputMaybe<Scalars['String']>;\n  selectorContains?: InputMaybe<Scalars['String']>;\n  selectorContainsFold?: InputMaybe<Scalars['String']>;\n  selectorEqualFold?: InputMaybe<Scalars['String']>;\n  selectorGT?: InputMaybe<Scalars['String']>;\n  selectorGTE?: InputMaybe<Scalars['String']>;\n  selectorHasPrefix?: InputMaybe<Scalars['String']>;\n  selectorHasSuffix?: InputMaybe<Scalars['String']>;\n  selectorIn?: InputMaybe<Array<Scalars['String']>>;\n  selectorLT?: InputMaybe<Scalars['String']>;\n  selectorLTE?: InputMaybe<Scalars['String']>;\n  selectorNEQ?: InputMaybe<Scalars['String']>;\n  selectorNotIn?: InputMaybe<Array<Scalars['String']>>;\n  /** updated_at field predicates */\n  updatedAt?: InputMaybe<Scalars['Time']>;\n  updatedAtGT?: InputMaybe<Scalars['Time']>;\n  updatedAtGTE?: InputMaybe<Scalars['Time']>;\n  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  updatedAtLT?: InputMaybe<Scalars['Time']>;\n  updatedAtLTE?: InputMaybe<Scalars['Time']>;\n  updatedAtNEQ?: InputMaybe<Scalars['Time']>;\n  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n};\n\nexport type PaymasterStats = {\n  __typename?: 'PaymasterStats';\n  avgUsdFee?: Maybe<Scalars['Float']>;\n  maxUsdFee?: Maybe<Scalars['Float']>;\n  minUsdFee?: Maybe<Scalars['Float']>;\n  revertedTransactions: Scalars['Int'];\n  successfulTransactions: Scalars['Int'];\n  totalTransactions: Scalars['Int'];\n  totalUsdFees?: Maybe<Scalars['Float']>;\n  uniqueUsers: Scalars['Int'];\n};\n\nexport type PaymasterTransaction = {\n  __typename?: 'PaymasterTransaction';\n  executedAt: Scalars['Time'];\n  status: ActivityStatus;\n  transactionHash: Scalars['String'];\n  usdFee: Scalars['Float'];\n};\n\nexport enum PaymasterTransactionFilter {\n  All = 'ALL',\n  Reverted = 'REVERTED',\n  Success = 'SUCCESS'\n}\n\nexport enum PaymasterTransactionOrder {\n  ExecutedAtAsc = 'EXECUTED_AT_ASC',\n  ExecutedAtDesc = 'EXECUTED_AT_DESC',\n  FeesAsc = 'FEES_ASC',\n  FeesDesc = 'FEES_DESC'\n}\n\n/**\n * PaymasterWhereInput is used for filtering Paymaster objects.\n * Input was generated by ent.\n */\nexport type PaymasterWhereInput = {\n  /** active field predicates */\n  active?: InputMaybe<Scalars['Boolean']>;\n  activeNEQ?: InputMaybe<Scalars['Boolean']>;\n  and?: InputMaybe<Array<PaymasterWhereInput>>;\n  /** budget field predicates */\n  budget?: InputMaybe<Scalars['Int']>;\n  /** budget_fee_unit field predicates */\n  budgetFeeUnit?: InputMaybe<PaymasterBudgetFeeUnit>;\n  budgetFeeUnitIn?: InputMaybe<Array<PaymasterBudgetFeeUnit>>;\n  budgetFeeUnitNEQ?: InputMaybe<PaymasterBudgetFeeUnit>;\n  budgetFeeUnitNotIn?: InputMaybe<Array<PaymasterBudgetFeeUnit>>;\n  budgetGT?: InputMaybe<Scalars['Int']>;\n  budgetGTE?: InputMaybe<Scalars['Int']>;\n  budgetIn?: InputMaybe<Array<Scalars['Int']>>;\n  budgetLT?: InputMaybe<Scalars['Int']>;\n  budgetLTE?: InputMaybe<Scalars['Int']>;\n  budgetNEQ?: InputMaybe<Scalars['Int']>;\n  budgetNotIn?: InputMaybe<Array<Scalars['Int']>>;\n  /** created_at field predicates */\n  createdAt?: InputMaybe<Scalars['Time']>;\n  createdAtGT?: InputMaybe<Scalars['Time']>;\n  createdAtGTE?: InputMaybe<Scalars['Time']>;\n  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  createdAtLT?: InputMaybe<Scalars['Time']>;\n  createdAtLTE?: InputMaybe<Scalars['Time']>;\n  createdAtNEQ?: InputMaybe<Scalars['Time']>;\n  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n  /** credit_fees field predicates */\n  creditFees?: InputMaybe<Scalars['Int']>;\n  creditFeesGT?: InputMaybe<Scalars['Int']>;\n  creditFeesGTE?: InputMaybe<Scalars['Int']>;\n  creditFeesIn?: InputMaybe<Array<Scalars['Int']>>;\n  creditFeesLT?: InputMaybe<Scalars['Int']>;\n  creditFeesLTE?: InputMaybe<Scalars['Int']>;\n  creditFeesNEQ?: InputMaybe<Scalars['Int']>;\n  creditFeesNotIn?: InputMaybe<Array<Scalars['Int']>>;\n  /** activities edge predicates */\n  hasActivities?: InputMaybe<Scalars['Boolean']>;\n  hasActivitiesWith?: InputMaybe<Array<ActivityWhereInput>>;\n  /** outbox edge predicates */\n  hasOutbox?: InputMaybe<Scalars['Boolean']>;\n  hasOutboxWith?: InputMaybe<Array<PaymasterOutboxWhereInput>>;\n  /** policies edge predicates */\n  hasPolicies?: InputMaybe<Scalars['Boolean']>;\n  hasPoliciesWith?: InputMaybe<Array<PaymasterPolicyWhereInput>>;\n  /** starterpacks edge predicates */\n  hasStarterpacks?: InputMaybe<Scalars['Boolean']>;\n  hasStarterpacksWith?: InputMaybe<Array<StarterpackWhereInput>>;\n  /** team edge predicates */\n  hasTeam?: InputMaybe<Scalars['Boolean']>;\n  hasTeamWith?: InputMaybe<Array<TeamWhereInput>>;\n  /** id field predicates */\n  id?: InputMaybe<Scalars['ID']>;\n  idContainsFold?: InputMaybe<Scalars['ID']>;\n  idEqualFold?: InputMaybe<Scalars['ID']>;\n  idGT?: InputMaybe<Scalars['ID']>;\n  idGTE?: InputMaybe<Scalars['ID']>;\n  idIn?: InputMaybe<Array<Scalars['ID']>>;\n  idLT?: InputMaybe<Scalars['ID']>;\n  idLTE?: InputMaybe<Scalars['ID']>;\n  idNEQ?: InputMaybe<Scalars['ID']>;\n  idNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  /** legacy_eth_fees field predicates */\n  legacyEthFees?: InputMaybe<Scalars['Int']>;\n  legacyEthFeesGT?: InputMaybe<Scalars['Int']>;\n  legacyEthFeesGTE?: InputMaybe<Scalars['Int']>;\n  legacyEthFeesIn?: InputMaybe<Array<Scalars['Int']>>;\n  legacyEthFeesLT?: InputMaybe<Scalars['Int']>;\n  legacyEthFeesLTE?: InputMaybe<Scalars['Int']>;\n  legacyEthFeesNEQ?: InputMaybe<Scalars['Int']>;\n  legacyEthFeesNotIn?: InputMaybe<Array<Scalars['Int']>>;\n  /** legacy_reverted_transactions field predicates */\n  legacyRevertedTransactions?: InputMaybe<Scalars['Int']>;\n  legacyRevertedTransactionsGT?: InputMaybe<Scalars['Int']>;\n  legacyRevertedTransactionsGTE?: InputMaybe<Scalars['Int']>;\n  legacyRevertedTransactionsIn?: InputMaybe<Array<Scalars['Int']>>;\n  legacyRevertedTransactionsLT?: InputMaybe<Scalars['Int']>;\n  legacyRevertedTransactionsLTE?: InputMaybe<Scalars['Int']>;\n  legacyRevertedTransactionsNEQ?: InputMaybe<Scalars['Int']>;\n  legacyRevertedTransactionsNotIn?: InputMaybe<Array<Scalars['Int']>>;\n  /** legacy_strk_fees field predicates */\n  legacyStrkFees?: InputMaybe<Scalars['Int']>;\n  legacyStrkFeesGT?: InputMaybe<Scalars['Int']>;\n  legacyStrkFeesGTE?: InputMaybe<Scalars['Int']>;\n  legacyStrkFeesIn?: InputMaybe<Array<Scalars['Int']>>;\n  legacyStrkFeesLT?: InputMaybe<Scalars['Int']>;\n  legacyStrkFeesLTE?: InputMaybe<Scalars['Int']>;\n  legacyStrkFeesNEQ?: InputMaybe<Scalars['Int']>;\n  legacyStrkFeesNotIn?: InputMaybe<Array<Scalars['Int']>>;\n  /** legacy_successful_transactions field predicates */\n  legacySuccessfulTransactions?: InputMaybe<Scalars['Int']>;\n  legacySuccessfulTransactionsGT?: InputMaybe<Scalars['Int']>;\n  legacySuccessfulTransactionsGTE?: InputMaybe<Scalars['Int']>;\n  legacySuccessfulTransactionsIn?: InputMaybe<Array<Scalars['Int']>>;\n  legacySuccessfulTransactionsLT?: InputMaybe<Scalars['Int']>;\n  legacySuccessfulTransactionsLTE?: InputMaybe<Scalars['Int']>;\n  legacySuccessfulTransactionsNEQ?: InputMaybe<Scalars['Int']>;\n  legacySuccessfulTransactionsNotIn?: InputMaybe<Array<Scalars['Int']>>;\n  /** name field predicates */\n  name?: InputMaybe<Scalars['String']>;\n  nameContains?: InputMaybe<Scalars['String']>;\n  nameContainsFold?: InputMaybe<Scalars['String']>;\n  nameEqualFold?: InputMaybe<Scalars['String']>;\n  nameGT?: InputMaybe<Scalars['String']>;\n  nameGTE?: InputMaybe<Scalars['String']>;\n  nameHasPrefix?: InputMaybe<Scalars['String']>;\n  nameHasSuffix?: InputMaybe<Scalars['String']>;\n  nameIn?: InputMaybe<Array<Scalars['String']>>;\n  nameLT?: InputMaybe<Scalars['String']>;\n  nameLTE?: InputMaybe<Scalars['String']>;\n  nameNEQ?: InputMaybe<Scalars['String']>;\n  nameNotIn?: InputMaybe<Array<Scalars['String']>>;\n  not?: InputMaybe<PaymasterWhereInput>;\n  or?: InputMaybe<Array<PaymasterWhereInput>>;\n  /** reverted_transactions field predicates */\n  revertedTransactions?: InputMaybe<Scalars['Int']>;\n  revertedTransactionsGT?: InputMaybe<Scalars['Int']>;\n  revertedTransactionsGTE?: InputMaybe<Scalars['Int']>;\n  revertedTransactionsIn?: InputMaybe<Array<Scalars['Int']>>;\n  revertedTransactionsLT?: InputMaybe<Scalars['Int']>;\n  revertedTransactionsLTE?: InputMaybe<Scalars['Int']>;\n  revertedTransactionsNEQ?: InputMaybe<Scalars['Int']>;\n  revertedTransactionsNotIn?: InputMaybe<Array<Scalars['Int']>>;\n  /** strk_fees field predicates */\n  strkFees?: InputMaybe<Scalars['Int']>;\n  strkFeesGT?: InputMaybe<Scalars['Int']>;\n  strkFeesGTE?: InputMaybe<Scalars['Int']>;\n  strkFeesIn?: InputMaybe<Array<Scalars['Int']>>;\n  strkFeesLT?: InputMaybe<Scalars['Int']>;\n  strkFeesLTE?: InputMaybe<Scalars['Int']>;\n  strkFeesNEQ?: InputMaybe<Scalars['Int']>;\n  strkFeesNotIn?: InputMaybe<Array<Scalars['Int']>>;\n  /** successful_transactions field predicates */\n  successfulTransactions?: InputMaybe<Scalars['Int']>;\n  successfulTransactionsGT?: InputMaybe<Scalars['Int']>;\n  successfulTransactionsGTE?: InputMaybe<Scalars['Int']>;\n  successfulTransactionsIn?: InputMaybe<Array<Scalars['Int']>>;\n  successfulTransactionsLT?: InputMaybe<Scalars['Int']>;\n  successfulTransactionsLTE?: InputMaybe<Scalars['Int']>;\n  successfulTransactionsNEQ?: InputMaybe<Scalars['Int']>;\n  successfulTransactionsNotIn?: InputMaybe<Array<Scalars['Int']>>;\n  /** updated_at field predicates */\n  updatedAt?: InputMaybe<Scalars['Time']>;\n  updatedAtGT?: InputMaybe<Scalars['Time']>;\n  updatedAtGTE?: InputMaybe<Scalars['Time']>;\n  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  updatedAtLT?: InputMaybe<Scalars['Time']>;\n  updatedAtLTE?: InputMaybe<Scalars['Time']>;\n  updatedAtNEQ?: InputMaybe<Scalars['Time']>;\n  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n};\n\nexport type PlayerAchievement = {\n  __typename?: 'PlayerAchievement';\n  /** The unique identifier for the achievement. */\n  achievementId: Scalars['ID'];\n  /** The timestamp when the achievement was completed in ISO 8601 format. */\n  completionTime: Scalars['String'];\n  /** The unique identifier of the player who earned the achievement. */\n  playerId: Scalars['ID'];\n  /** The number of points awarded for completing the achievement. */\n  points: Scalars['Int'];\n  /** The unique identifier for the task associated with this achievement. */\n  taskId: Scalars['ID'];\n  /** The total number of tasks required for this specific achievement. */\n  taskTotal: Scalars['Int'];\n  /** The total number of achievements completed by the player. */\n  total: Scalars['Int'];\n};\n\nexport type PlayerAchievementItem = {\n  __typename?: 'PlayerAchievementItem';\n  achievements: Array<PlayerAchievement>;\n  meta: AchievementMeta;\n};\n\nexport type PlayerAchievementResult = {\n  __typename?: 'PlayerAchievementResult';\n  items: Array<PlayerAchievementItem>;\n};\n\nexport type PlaythroughEntry = {\n  __typename?: 'PlaythroughEntry';\n  actionCount: Scalars['Int'];\n  callerAddress: Scalars['String'];\n  entrypoints: Scalars['String'];\n  sessionEnd: Scalars['String'];\n  sessionStart: Scalars['String'];\n};\n\nexport type PlaythroughItem = {\n  __typename?: 'PlaythroughItem';\n  meta: PlaythroughMeta;\n  playthroughs: Array<PlaythroughEntry>;\n};\n\nexport type PlaythroughMeta = {\n  __typename?: 'PlaythroughMeta';\n  count: Scalars['Int'];\n  error?: Maybe<Scalars['String']>;\n  limit: Scalars['Int'];\n  project: Scalars['String'];\n};\n\nexport type PlaythroughProject = {\n  limit: Scalars['Int'];\n  project: Scalars['String'];\n};\n\nexport type PlaythroughResult = {\n  __typename?: 'PlaythroughResult';\n  items: Array<PlaythroughItem>;\n};\n\nexport type PolicyInput = {\n  contractAddress: Scalars['String'];\n  entryPoint: Scalars['String'];\n  predicate?: InputMaybe<PolicyPredicateInput>;\n  trigger?: InputMaybe<PolicyTriggerInput>;\n};\n\nexport type PolicyPredicate = {\n  __typename?: 'PolicyPredicate';\n  contractAddress: Scalars['String'];\n  entryPoint: Scalars['String'];\n};\n\nexport type PolicyPredicateInput = {\n  address: Scalars['String'];\n  entrypoint: Scalars['String'];\n};\n\nexport type PolicyTrigger = {\n  __typename?: 'PolicyTrigger';\n  contractAddress: Scalars['String'];\n  entryPoint: Scalars['String'];\n};\n\nexport type PolicyTriggerInput = {\n  address: Scalars['String'];\n  entrypoint: Scalars['String'];\n};\n\nexport type Price = {\n  __typename?: 'Price';\n  amount: Scalars['BigInt'];\n  base: Scalars['String'];\n  decimals: Scalars['Int'];\n  quote: Scalars['String'];\n};\n\nexport type Project = {\n  model: Scalars['String'];\n  namespace: Scalars['String'];\n  project: Scalars['String'];\n};\n\nexport enum PurchaseType {\n  Credits = 'CREDITS',\n  /** @deprecated Starterpack purchases are now handled client-side */\n  Starterpack = 'STARTERPACK'\n}\n\nexport type Query = {\n  __typename?: 'Query';\n  account?: Maybe<Account>;\n  accounts?: Maybe<AccountConnection>;\n  achievements: AchievementResult;\n  activities: ActivityResult;\n  balance: Balance;\n  balances: BalanceConnection;\n  /**\n   * Get a quote for a Coinbase onramp purchase without creating a transaction.\n   * This is an estimate only and does not guarantee the final price.\n   */\n  coinbaseOnrampQuote: CoinbaseOnrampQuote;\n  /**\n   * Check if a user has the required information for Coinbase onramp.\n   * Returns flags indicating what information is missing or needs to be updated.\n   * Does not expose any user data.\n   */\n  coinbaseOnrampRequirements: CoinbaseOnrampRequirements;\n  /**\n   * Get the status and history of Coinbase onramp transactions for a user.\n   * Returns a paginated list of transactions in reverse chronological order.\n   */\n  coinbaseOnrampTransactions: CoinbaseTransactionsResponse;\n  collectible: Collectible;\n  collectibles: CollectibleConnection;\n  collection: Collection;\n  collections: CollectionConnection;\n  controller?: Maybe<Controller>;\n  controllers?: Maybe<ControllerConnection>;\n  cryptoPayment?: Maybe<CryptoPayment>;\n  deployment?: Maybe<Deployment>;\n  deployments?: Maybe<DeploymentConnection>;\n  layerswapPayment?: Maybe<LayerswapPayment>;\n  layerswapQuote: LayerswapQuote;\n  layerswapSources: Array<LayerswapSource>;\n  layerswapStatus: LayerswapStatus;\n  me?: Maybe<Account>;\n  merkleClaims: MerkleClaimConnection;\n  merkleClaimsForAddress: Array<MerkleClaim>;\n  merkleDropByKey?: Maybe<MerkleDrop>;\n  merkleDrops: MerkleDropConnection;\n  metrics: MetricsResult;\n  /** Fetches an object given its ID. */\n  node?: Maybe<Node>;\n  /** Lookup nodes by a list of IDs. */\n  nodes: Array<Maybe<Node>>;\n  ownerships: OwnershipResult;\n  paymaster?: Maybe<Paymaster>;\n  paymasterStats: PaymasterStats;\n  paymasterTransactions: Array<PaymasterTransaction>;\n  paymasters?: Maybe<PaymasterConnection>;\n  playerAchievements: PlayerAchievementResult;\n  playthroughs: PlaythroughResult;\n  price: Array<Price>;\n  priceByAddresses: Array<Price>;\n  pricePeriodByAddresses: Array<Price>;\n  rpcApiKeys?: Maybe<RpcApiKeyConnection>;\n  rpcCorsDomains?: Maybe<RpcCorsDomainConnection>;\n  rpcLogs?: Maybe<RpcLogConnection>;\n  searchAccounts: Array<Account>;\n  session?: Maybe<Session>;\n  sessions?: Maybe<SessionConnection>;\n  starterpack?: Maybe<StarterpackDetails>;\n  streaks: StreakResult;\n  stripePayment: StripePayment;\n  subscribeCreateSession?: Maybe<Session>;\n  team?: Maybe<Team>;\n  teams?: Maybe<TeamConnection>;\n  traceabilities: TraceabilityResult;\n  transfers: TransferResult;\n};\n\n\nexport type QueryAccountArgs = {\n  username?: InputMaybe<Scalars['String']>;\n};\n\n\nexport type QueryAccountsArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<AccountOrder>;\n  where?: InputMaybe<AccountWhereInput>;\n};\n\n\nexport type QueryAchievementsArgs = {\n  projects?: InputMaybe<Array<Project>>;\n};\n\n\nexport type QueryActivitiesArgs = {\n  projects?: InputMaybe<Array<ActivityProject>>;\n};\n\n\nexport type QueryBalanceArgs = {\n  accountAddress: Scalars['String'];\n  projects: Array<Scalars['String']>;\n  tokenAddress: Scalars['String'];\n};\n\n\nexport type QueryBalancesArgs = {\n  accountAddress: Scalars['String'];\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  projects?: InputMaybe<Array<Scalars['String']>>;\n};\n\n\nexport type QueryCoinbaseOnrampQuoteArgs = {\n  input: CoinbaseOnrampQuoteInput;\n};\n\n\nexport type QueryCoinbaseOnrampRequirementsArgs = {\n  username: Scalars['String'];\n};\n\n\nexport type QueryCoinbaseOnrampTransactionsArgs = {\n  input: CoinbaseTransactionsInput;\n};\n\n\nexport type QueryCollectibleArgs = {\n  accountAddress: Scalars['String'];\n  contractAddress: Scalars['String'];\n  projects?: InputMaybe<Array<Scalars['String']>>;\n};\n\n\nexport type QueryCollectiblesArgs = {\n  accountAddress: Scalars['String'];\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  projects?: InputMaybe<Array<Scalars['String']>>;\n};\n\n\nexport type QueryCollectionArgs = {\n  accountAddress: Scalars['String'];\n  contractAddress: Scalars['String'];\n  projects?: InputMaybe<Array<Scalars['String']>>;\n};\n\n\nexport type QueryCollectionsArgs = {\n  accountAddress: Scalars['String'];\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  projects?: InputMaybe<Array<Scalars['String']>>;\n};\n\n\nexport type QueryControllerArgs = {\n  chainId: Scalars['String'];\n  username: Scalars['String'];\n};\n\n\nexport type QueryControllersArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ControllerOrder>;\n  where?: InputMaybe<ControllerWhereInput>;\n};\n\n\nexport type QueryCryptoPaymentArgs = {\n  id: Scalars['ID'];\n};\n\n\nexport type QueryDeploymentArgs = {\n  name: Scalars['String'];\n  service: DeploymentService;\n};\n\n\nexport type QueryDeploymentsArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<DeploymentOrder>;\n  where?: InputMaybe<DeploymentWhereInput>;\n};\n\n\nexport type QueryLayerswapPaymentArgs = {\n  swapId: Scalars['ID'];\n};\n\n\nexport type QueryLayerswapQuoteArgs = {\n  input: CreateLayerswapDepositInput;\n};\n\n\nexport type QueryLayerswapSourcesArgs = {\n  isMainnet?: InputMaybe<Scalars['Boolean']>;\n  token: Scalars['String'];\n};\n\n\nexport type QueryLayerswapStatusArgs = {\n  isMainnet?: InputMaybe<Scalars['Boolean']>;\n  swapId: Scalars['ID'];\n};\n\n\nexport type QueryMerkleClaimsArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<MerkleClaimOrder>;\n  where?: InputMaybe<MerkleClaimWhereInput>;\n};\n\n\nexport type QueryMerkleClaimsForAddressArgs = {\n  address: Scalars['String'];\n  keys: Array<Scalars['String']>;\n};\n\n\nexport type QueryMerkleDropByKeyArgs = {\n  key: Scalars['String'];\n};\n\n\nexport type QueryMerkleDropsArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<MerkleDropOrder>;\n  where?: InputMaybe<MerkleDropWhereInput>;\n};\n\n\nexport type QueryMetricsArgs = {\n  projects?: InputMaybe<Array<MetricsProject>>;\n};\n\n\nexport type QueryNodeArgs = {\n  id: Scalars['ID'];\n};\n\n\nexport type QueryNodesArgs = {\n  ids: Array<Scalars['ID']>;\n};\n\n\nexport type QueryOwnershipsArgs = {\n  projects?: InputMaybe<Array<OwnershipProject>>;\n};\n\n\nexport type QueryPaymasterArgs = {\n  name: Scalars['ID'];\n};\n\n\nexport type QueryPaymasterStatsArgs = {\n  paymasterName: Scalars['ID'];\n  since: Scalars['Time'];\n};\n\n\nexport type QueryPaymasterTransactionsArgs = {\n  filter?: InputMaybe<PaymasterTransactionFilter>;\n  limit?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<PaymasterTransactionOrder>;\n  paymasterName: Scalars['ID'];\n  since: Scalars['Time'];\n};\n\n\nexport type QueryPaymastersArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<PaymasterOrder>;\n  where?: InputMaybe<PaymasterWhereInput>;\n};\n\n\nexport type QueryPlayerAchievementsArgs = {\n  projects?: InputMaybe<Array<Project>>;\n};\n\n\nexport type QueryPlaythroughsArgs = {\n  projects?: InputMaybe<Array<PlaythroughProject>>;\n};\n\n\nexport type QueryPriceArgs = {\n  pairs: Array<TokenPair>;\n};\n\n\nexport type QueryPriceByAddressesArgs = {\n  addresses: Array<Scalars['String']>;\n};\n\n\nexport type QueryPricePeriodByAddressesArgs = {\n  addresses: Array<Scalars['String']>;\n  end: Scalars['Int'];\n  start: Scalars['Int'];\n};\n\n\nexport type QueryRpcApiKeysArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  teamName: Scalars['String'];\n  where?: InputMaybe<RpcApiKeyWhereInput>;\n};\n\n\nexport type QueryRpcCorsDomainsArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  teamName: Scalars['String'];\n  where?: InputMaybe<RpcCorsDomainWhereInput>;\n};\n\n\nexport type QueryRpcLogsArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  teamName: Scalars['String'];\n  where?: InputMaybe<RpcLogWhereInput>;\n};\n\n\nexport type QuerySearchAccountsArgs = {\n  limit?: InputMaybe<Scalars['Int']>;\n  query: Scalars['String'];\n};\n\n\nexport type QuerySessionArgs = {\n  id: Scalars['ID'];\n};\n\n\nexport type QuerySessionsArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<SessionOrder>;\n  where?: InputMaybe<SessionWhereInput>;\n};\n\n\nexport type QueryStarterpackArgs = {\n  input: StarterpackInput;\n};\n\n\nexport type QueryStreaksArgs = {\n  projects?: InputMaybe<Array<StreakProject>>;\n};\n\n\nexport type QueryStripePaymentArgs = {\n  id: Scalars['ID'];\n};\n\n\nexport type QuerySubscribeCreateSessionArgs = {\n  sessionKeyGuid: Scalars['Felt'];\n};\n\n\nexport type QueryTeamArgs = {\n  name: Scalars['String'];\n};\n\n\nexport type QueryTeamsArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<TeamWhereInput>;\n};\n\n\nexport type QueryTraceabilitiesArgs = {\n  projects?: InputMaybe<Array<TraceabilityProject>>;\n};\n\n\nexport type QueryTransfersArgs = {\n  projects?: InputMaybe<Array<TransferProject>>;\n};\n\nexport type RpcApiKey = Node & {\n  __typename?: 'RPCApiKey';\n  /** Whether this API key is active */\n  active: Scalars['Boolean'];\n  createdAt: Scalars['Time'];\n  id: Scalars['ID'];\n  /** SHA256 hash of the API key for secure storage */\n  keyHash: Scalars['String'];\n  /** First 8 characters of the key for display purposes */\n  keyPrefix: Scalars['String'];\n  /** Last time this API key was used */\n  lastUsedAt?: Maybe<Scalars['Time']>;\n  /** Human readable name for the API key */\n  name: Scalars['String'];\n  team: Team;\n  /** Team that owns this API key */\n  teamID: Scalars['ID'];\n};\n\n/** A connection to a list of items. */\nexport type RpcApiKeyConnection = {\n  __typename?: 'RPCApiKeyConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RpcApiKeyEdge>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type RpcApiKeyEdge = {\n  __typename?: 'RPCApiKeyEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['Cursor'];\n  /** The item at the end of the edge. */\n  node?: Maybe<RpcApiKey>;\n};\n\nexport type RpcApiKeyInput = {\n  active?: InputMaybe<Scalars['Boolean']>;\n  name?: InputMaybe<Scalars['String']>;\n};\n\n/**\n * RPCApiKeyWhereInput is used for filtering RPCApiKey objects.\n * Input was generated by ent.\n */\nexport type RpcApiKeyWhereInput = {\n  /** active field predicates */\n  active?: InputMaybe<Scalars['Boolean']>;\n  activeNEQ?: InputMaybe<Scalars['Boolean']>;\n  and?: InputMaybe<Array<RpcApiKeyWhereInput>>;\n  /** created_at field predicates */\n  createdAt?: InputMaybe<Scalars['Time']>;\n  createdAtGT?: InputMaybe<Scalars['Time']>;\n  createdAtGTE?: InputMaybe<Scalars['Time']>;\n  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  createdAtLT?: InputMaybe<Scalars['Time']>;\n  createdAtLTE?: InputMaybe<Scalars['Time']>;\n  createdAtNEQ?: InputMaybe<Scalars['Time']>;\n  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n  /** team edge predicates */\n  hasTeam?: InputMaybe<Scalars['Boolean']>;\n  hasTeamWith?: InputMaybe<Array<TeamWhereInput>>;\n  /** id field predicates */\n  id?: InputMaybe<Scalars['ID']>;\n  idContainsFold?: InputMaybe<Scalars['ID']>;\n  idEqualFold?: InputMaybe<Scalars['ID']>;\n  idGT?: InputMaybe<Scalars['ID']>;\n  idGTE?: InputMaybe<Scalars['ID']>;\n  idIn?: InputMaybe<Array<Scalars['ID']>>;\n  idLT?: InputMaybe<Scalars['ID']>;\n  idLTE?: InputMaybe<Scalars['ID']>;\n  idNEQ?: InputMaybe<Scalars['ID']>;\n  idNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  /** key_hash field predicates */\n  keyHash?: InputMaybe<Scalars['String']>;\n  keyHashContains?: InputMaybe<Scalars['String']>;\n  keyHashContainsFold?: InputMaybe<Scalars['String']>;\n  keyHashEqualFold?: InputMaybe<Scalars['String']>;\n  keyHashGT?: InputMaybe<Scalars['String']>;\n  keyHashGTE?: InputMaybe<Scalars['String']>;\n  keyHashHasPrefix?: InputMaybe<Scalars['String']>;\n  keyHashHasSuffix?: InputMaybe<Scalars['String']>;\n  keyHashIn?: InputMaybe<Array<Scalars['String']>>;\n  keyHashLT?: InputMaybe<Scalars['String']>;\n  keyHashLTE?: InputMaybe<Scalars['String']>;\n  keyHashNEQ?: InputMaybe<Scalars['String']>;\n  keyHashNotIn?: InputMaybe<Array<Scalars['String']>>;\n  /** key_prefix field predicates */\n  keyPrefix?: InputMaybe<Scalars['String']>;\n  keyPrefixContains?: InputMaybe<Scalars['String']>;\n  keyPrefixContainsFold?: InputMaybe<Scalars['String']>;\n  keyPrefixEqualFold?: InputMaybe<Scalars['String']>;\n  keyPrefixGT?: InputMaybe<Scalars['String']>;\n  keyPrefixGTE?: InputMaybe<Scalars['String']>;\n  keyPrefixHasPrefix?: InputMaybe<Scalars['String']>;\n  keyPrefixHasSuffix?: InputMaybe<Scalars['String']>;\n  keyPrefixIn?: InputMaybe<Array<Scalars['String']>>;\n  keyPrefixLT?: InputMaybe<Scalars['String']>;\n  keyPrefixLTE?: InputMaybe<Scalars['String']>;\n  keyPrefixNEQ?: InputMaybe<Scalars['String']>;\n  keyPrefixNotIn?: InputMaybe<Array<Scalars['String']>>;\n  /** last_used_at field predicates */\n  lastUsedAt?: InputMaybe<Scalars['Time']>;\n  lastUsedAtGT?: InputMaybe<Scalars['Time']>;\n  lastUsedAtGTE?: InputMaybe<Scalars['Time']>;\n  lastUsedAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  lastUsedAtIsNil?: InputMaybe<Scalars['Boolean']>;\n  lastUsedAtLT?: InputMaybe<Scalars['Time']>;\n  lastUsedAtLTE?: InputMaybe<Scalars['Time']>;\n  lastUsedAtNEQ?: InputMaybe<Scalars['Time']>;\n  lastUsedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n  lastUsedAtNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** name field predicates */\n  name?: InputMaybe<Scalars['String']>;\n  nameContains?: InputMaybe<Scalars['String']>;\n  nameContainsFold?: InputMaybe<Scalars['String']>;\n  nameEqualFold?: InputMaybe<Scalars['String']>;\n  nameGT?: InputMaybe<Scalars['String']>;\n  nameGTE?: InputMaybe<Scalars['String']>;\n  nameHasPrefix?: InputMaybe<Scalars['String']>;\n  nameHasSuffix?: InputMaybe<Scalars['String']>;\n  nameIn?: InputMaybe<Array<Scalars['String']>>;\n  nameLT?: InputMaybe<Scalars['String']>;\n  nameLTE?: InputMaybe<Scalars['String']>;\n  nameNEQ?: InputMaybe<Scalars['String']>;\n  nameNotIn?: InputMaybe<Array<Scalars['String']>>;\n  not?: InputMaybe<RpcApiKeyWhereInput>;\n  or?: InputMaybe<Array<RpcApiKeyWhereInput>>;\n  /** team_id field predicates */\n  teamID?: InputMaybe<Scalars['ID']>;\n  teamIDContains?: InputMaybe<Scalars['ID']>;\n  teamIDContainsFold?: InputMaybe<Scalars['ID']>;\n  teamIDEqualFold?: InputMaybe<Scalars['ID']>;\n  teamIDGT?: InputMaybe<Scalars['ID']>;\n  teamIDGTE?: InputMaybe<Scalars['ID']>;\n  teamIDHasPrefix?: InputMaybe<Scalars['ID']>;\n  teamIDHasSuffix?: InputMaybe<Scalars['ID']>;\n  teamIDIn?: InputMaybe<Array<Scalars['ID']>>;\n  teamIDLT?: InputMaybe<Scalars['ID']>;\n  teamIDLTE?: InputMaybe<Scalars['ID']>;\n  teamIDNEQ?: InputMaybe<Scalars['ID']>;\n  teamIDNotIn?: InputMaybe<Array<Scalars['ID']>>;\n};\n\nexport type RpcCorsDomain = Node & {\n  __typename?: 'RPCCorsDomain';\n  /** Whether this domain is active */\n  active: Scalars['Boolean'];\n  createdAt: Scalars['Time'];\n  /** Domain name for CORS access (e.g., example.com, *.example.com) */\n  domain: Scalars['String'];\n  id: Scalars['ID'];\n  /** Rate limit per IP per minute for this domain */\n  rateLimitPerMinute: Scalars['Int'];\n  team: Team;\n  /** Team that owns this CORS domain */\n  teamID: Scalars['ID'];\n};\n\n/** A connection to a list of items. */\nexport type RpcCorsDomainConnection = {\n  __typename?: 'RPCCorsDomainConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RpcCorsDomainEdge>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type RpcCorsDomainEdge = {\n  __typename?: 'RPCCorsDomainEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['Cursor'];\n  /** The item at the end of the edge. */\n  node?: Maybe<RpcCorsDomain>;\n};\n\nexport type RpcCorsDomainInput = {\n  active?: InputMaybe<Scalars['Boolean']>;\n  domain?: InputMaybe<Scalars['String']>;\n  rateLimitPerMinute?: InputMaybe<Scalars['Int']>;\n};\n\n/**\n * RPCCorsDomainWhereInput is used for filtering RPCCorsDomain objects.\n * Input was generated by ent.\n */\nexport type RpcCorsDomainWhereInput = {\n  /** active field predicates */\n  active?: InputMaybe<Scalars['Boolean']>;\n  activeNEQ?: InputMaybe<Scalars['Boolean']>;\n  and?: InputMaybe<Array<RpcCorsDomainWhereInput>>;\n  /** created_at field predicates */\n  createdAt?: InputMaybe<Scalars['Time']>;\n  createdAtGT?: InputMaybe<Scalars['Time']>;\n  createdAtGTE?: InputMaybe<Scalars['Time']>;\n  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  createdAtLT?: InputMaybe<Scalars['Time']>;\n  createdAtLTE?: InputMaybe<Scalars['Time']>;\n  createdAtNEQ?: InputMaybe<Scalars['Time']>;\n  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n  /** domain field predicates */\n  domain?: InputMaybe<Scalars['String']>;\n  domainContains?: InputMaybe<Scalars['String']>;\n  domainContainsFold?: InputMaybe<Scalars['String']>;\n  domainEqualFold?: InputMaybe<Scalars['String']>;\n  domainGT?: InputMaybe<Scalars['String']>;\n  domainGTE?: InputMaybe<Scalars['String']>;\n  domainHasPrefix?: InputMaybe<Scalars['String']>;\n  domainHasSuffix?: InputMaybe<Scalars['String']>;\n  domainIn?: InputMaybe<Array<Scalars['String']>>;\n  domainLT?: InputMaybe<Scalars['String']>;\n  domainLTE?: InputMaybe<Scalars['String']>;\n  domainNEQ?: InputMaybe<Scalars['String']>;\n  domainNotIn?: InputMaybe<Array<Scalars['String']>>;\n  /** team edge predicates */\n  hasTeam?: InputMaybe<Scalars['Boolean']>;\n  hasTeamWith?: InputMaybe<Array<TeamWhereInput>>;\n  /** id field predicates */\n  id?: InputMaybe<Scalars['ID']>;\n  idContainsFold?: InputMaybe<Scalars['ID']>;\n  idEqualFold?: InputMaybe<Scalars['ID']>;\n  idGT?: InputMaybe<Scalars['ID']>;\n  idGTE?: InputMaybe<Scalars['ID']>;\n  idIn?: InputMaybe<Array<Scalars['ID']>>;\n  idLT?: InputMaybe<Scalars['ID']>;\n  idLTE?: InputMaybe<Scalars['ID']>;\n  idNEQ?: InputMaybe<Scalars['ID']>;\n  idNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  not?: InputMaybe<RpcCorsDomainWhereInput>;\n  or?: InputMaybe<Array<RpcCorsDomainWhereInput>>;\n  /** rate_limit_per_minute field predicates */\n  rateLimitPerMinute?: InputMaybe<Scalars['Int']>;\n  rateLimitPerMinuteGT?: InputMaybe<Scalars['Int']>;\n  rateLimitPerMinuteGTE?: InputMaybe<Scalars['Int']>;\n  rateLimitPerMinuteIn?: InputMaybe<Array<Scalars['Int']>>;\n  rateLimitPerMinuteLT?: InputMaybe<Scalars['Int']>;\n  rateLimitPerMinuteLTE?: InputMaybe<Scalars['Int']>;\n  rateLimitPerMinuteNEQ?: InputMaybe<Scalars['Int']>;\n  rateLimitPerMinuteNotIn?: InputMaybe<Array<Scalars['Int']>>;\n  /** team_id field predicates */\n  teamID?: InputMaybe<Scalars['ID']>;\n  teamIDContains?: InputMaybe<Scalars['ID']>;\n  teamIDContainsFold?: InputMaybe<Scalars['ID']>;\n  teamIDEqualFold?: InputMaybe<Scalars['ID']>;\n  teamIDGT?: InputMaybe<Scalars['ID']>;\n  teamIDGTE?: InputMaybe<Scalars['ID']>;\n  teamIDHasPrefix?: InputMaybe<Scalars['ID']>;\n  teamIDHasSuffix?: InputMaybe<Scalars['ID']>;\n  teamIDIn?: InputMaybe<Array<Scalars['ID']>>;\n  teamIDLT?: InputMaybe<Scalars['ID']>;\n  teamIDLTE?: InputMaybe<Scalars['ID']>;\n  teamIDNEQ?: InputMaybe<Scalars['ID']>;\n  teamIDNotIn?: InputMaybe<Array<Scalars['ID']>>;\n};\n\nexport type RpcLog = Node & {\n  __typename?: 'RPCLog';\n  /** API key used (if any) */\n  apiKeyID?: Maybe<Scalars['String']>;\n  /** IP address of the client */\n  clientIP: Scalars['String'];\n  /** CORS domain used (if any) */\n  corsDomainID?: Maybe<Scalars['String']>;\n  /** Cost in micro-dollars (0.000001 USD per unit). Converted to team credits during billing. */\n  costCredits: Scalars['Int'];\n  /** Request duration in milliseconds */\n  durationMs: Scalars['Int'];\n  id: Scalars['ID'];\n  /** Whether this was an internal request (free) */\n  isInternal: Scalars['Boolean'];\n  /** RPC method called */\n  method?: Maybe<Scalars['String']>;\n  /** Starknet network used */\n  network: RpcLogNetwork;\n  /** When billing was processed. NULL indicates not yet processed. */\n  processedAt?: Maybe<Scalars['Time']>;\n  /** Referer header from the request */\n  referer?: Maybe<Scalars['String']>;\n  /** Size of the response in bytes */\n  responseSizeBytes: Scalars['Int'];\n  /** HTTP response status code */\n  responseStatus: Scalars['Int'];\n  /** Team that made this RPC request */\n  teamID?: Maybe<Scalars['String']>;\n  /** When the request was made */\n  timestamp: Scalars['Time'];\n  /** User agent of the client */\n  userAgent?: Maybe<Scalars['String']>;\n};\n\n/** A connection to a list of items. */\nexport type RpcLogConnection = {\n  __typename?: 'RPCLogConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RpcLogEdge>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type RpcLogEdge = {\n  __typename?: 'RPCLogEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['Cursor'];\n  /** The item at the end of the edge. */\n  node?: Maybe<RpcLog>;\n};\n\n/** RPCLogNetwork is enum for the field network */\nexport enum RpcLogNetwork {\n  Mainnet = 'mainnet',\n  Sepolia = 'sepolia'\n}\n\n/**\n * RPCLogWhereInput is used for filtering RPCLog objects.\n * Input was generated by ent.\n */\nexport type RpcLogWhereInput = {\n  and?: InputMaybe<Array<RpcLogWhereInput>>;\n  /** api_key_id field predicates */\n  apiKeyID?: InputMaybe<Scalars['String']>;\n  apiKeyIDContains?: InputMaybe<Scalars['String']>;\n  apiKeyIDContainsFold?: InputMaybe<Scalars['String']>;\n  apiKeyIDEqualFold?: InputMaybe<Scalars['String']>;\n  apiKeyIDGT?: InputMaybe<Scalars['String']>;\n  apiKeyIDGTE?: InputMaybe<Scalars['String']>;\n  apiKeyIDHasPrefix?: InputMaybe<Scalars['String']>;\n  apiKeyIDHasSuffix?: InputMaybe<Scalars['String']>;\n  apiKeyIDIn?: InputMaybe<Array<Scalars['String']>>;\n  apiKeyIDIsNil?: InputMaybe<Scalars['Boolean']>;\n  apiKeyIDLT?: InputMaybe<Scalars['String']>;\n  apiKeyIDLTE?: InputMaybe<Scalars['String']>;\n  apiKeyIDNEQ?: InputMaybe<Scalars['String']>;\n  apiKeyIDNotIn?: InputMaybe<Array<Scalars['String']>>;\n  apiKeyIDNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** client_ip field predicates */\n  clientIP?: InputMaybe<Scalars['String']>;\n  clientIPContains?: InputMaybe<Scalars['String']>;\n  clientIPContainsFold?: InputMaybe<Scalars['String']>;\n  clientIPEqualFold?: InputMaybe<Scalars['String']>;\n  clientIPGT?: InputMaybe<Scalars['String']>;\n  clientIPGTE?: InputMaybe<Scalars['String']>;\n  clientIPHasPrefix?: InputMaybe<Scalars['String']>;\n  clientIPHasSuffix?: InputMaybe<Scalars['String']>;\n  clientIPIn?: InputMaybe<Array<Scalars['String']>>;\n  clientIPLT?: InputMaybe<Scalars['String']>;\n  clientIPLTE?: InputMaybe<Scalars['String']>;\n  clientIPNEQ?: InputMaybe<Scalars['String']>;\n  clientIPNotIn?: InputMaybe<Array<Scalars['String']>>;\n  /** cors_domain_id field predicates */\n  corsDomainID?: InputMaybe<Scalars['String']>;\n  corsDomainIDContains?: InputMaybe<Scalars['String']>;\n  corsDomainIDContainsFold?: InputMaybe<Scalars['String']>;\n  corsDomainIDEqualFold?: InputMaybe<Scalars['String']>;\n  corsDomainIDGT?: InputMaybe<Scalars['String']>;\n  corsDomainIDGTE?: InputMaybe<Scalars['String']>;\n  corsDomainIDHasPrefix?: InputMaybe<Scalars['String']>;\n  corsDomainIDHasSuffix?: InputMaybe<Scalars['String']>;\n  corsDomainIDIn?: InputMaybe<Array<Scalars['String']>>;\n  corsDomainIDIsNil?: InputMaybe<Scalars['Boolean']>;\n  corsDomainIDLT?: InputMaybe<Scalars['String']>;\n  corsDomainIDLTE?: InputMaybe<Scalars['String']>;\n  corsDomainIDNEQ?: InputMaybe<Scalars['String']>;\n  corsDomainIDNotIn?: InputMaybe<Array<Scalars['String']>>;\n  corsDomainIDNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** cost_credits field predicates */\n  costCredits?: InputMaybe<Scalars['Int']>;\n  costCreditsGT?: InputMaybe<Scalars['Int']>;\n  costCreditsGTE?: InputMaybe<Scalars['Int']>;\n  costCreditsIn?: InputMaybe<Array<Scalars['Int']>>;\n  costCreditsLT?: InputMaybe<Scalars['Int']>;\n  costCreditsLTE?: InputMaybe<Scalars['Int']>;\n  costCreditsNEQ?: InputMaybe<Scalars['Int']>;\n  costCreditsNotIn?: InputMaybe<Array<Scalars['Int']>>;\n  /** duration_ms field predicates */\n  durationMs?: InputMaybe<Scalars['Int']>;\n  durationMsGT?: InputMaybe<Scalars['Int']>;\n  durationMsGTE?: InputMaybe<Scalars['Int']>;\n  durationMsIn?: InputMaybe<Array<Scalars['Int']>>;\n  durationMsLT?: InputMaybe<Scalars['Int']>;\n  durationMsLTE?: InputMaybe<Scalars['Int']>;\n  durationMsNEQ?: InputMaybe<Scalars['Int']>;\n  durationMsNotIn?: InputMaybe<Array<Scalars['Int']>>;\n  /** id field predicates */\n  id?: InputMaybe<Scalars['ID']>;\n  idContainsFold?: InputMaybe<Scalars['ID']>;\n  idEqualFold?: InputMaybe<Scalars['ID']>;\n  idGT?: InputMaybe<Scalars['ID']>;\n  idGTE?: InputMaybe<Scalars['ID']>;\n  idIn?: InputMaybe<Array<Scalars['ID']>>;\n  idLT?: InputMaybe<Scalars['ID']>;\n  idLTE?: InputMaybe<Scalars['ID']>;\n  idNEQ?: InputMaybe<Scalars['ID']>;\n  idNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  /** is_internal field predicates */\n  isInternal?: InputMaybe<Scalars['Boolean']>;\n  isInternalNEQ?: InputMaybe<Scalars['Boolean']>;\n  /** method field predicates */\n  method?: InputMaybe<Scalars['String']>;\n  methodContains?: InputMaybe<Scalars['String']>;\n  methodContainsFold?: InputMaybe<Scalars['String']>;\n  methodEqualFold?: InputMaybe<Scalars['String']>;\n  methodGT?: InputMaybe<Scalars['String']>;\n  methodGTE?: InputMaybe<Scalars['String']>;\n  methodHasPrefix?: InputMaybe<Scalars['String']>;\n  methodHasSuffix?: InputMaybe<Scalars['String']>;\n  methodIn?: InputMaybe<Array<Scalars['String']>>;\n  methodIsNil?: InputMaybe<Scalars['Boolean']>;\n  methodLT?: InputMaybe<Scalars['String']>;\n  methodLTE?: InputMaybe<Scalars['String']>;\n  methodNEQ?: InputMaybe<Scalars['String']>;\n  methodNotIn?: InputMaybe<Array<Scalars['String']>>;\n  methodNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** network field predicates */\n  network?: InputMaybe<RpcLogNetwork>;\n  networkIn?: InputMaybe<Array<RpcLogNetwork>>;\n  networkNEQ?: InputMaybe<RpcLogNetwork>;\n  networkNotIn?: InputMaybe<Array<RpcLogNetwork>>;\n  not?: InputMaybe<RpcLogWhereInput>;\n  or?: InputMaybe<Array<RpcLogWhereInput>>;\n  /** processed_at field predicates */\n  processedAt?: InputMaybe<Scalars['Time']>;\n  processedAtGT?: InputMaybe<Scalars['Time']>;\n  processedAtGTE?: InputMaybe<Scalars['Time']>;\n  processedAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  processedAtIsNil?: InputMaybe<Scalars['Boolean']>;\n  processedAtLT?: InputMaybe<Scalars['Time']>;\n  processedAtLTE?: InputMaybe<Scalars['Time']>;\n  processedAtNEQ?: InputMaybe<Scalars['Time']>;\n  processedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n  processedAtNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** referer field predicates */\n  referer?: InputMaybe<Scalars['String']>;\n  refererContains?: InputMaybe<Scalars['String']>;\n  refererContainsFold?: InputMaybe<Scalars['String']>;\n  refererEqualFold?: InputMaybe<Scalars['String']>;\n  refererGT?: InputMaybe<Scalars['String']>;\n  refererGTE?: InputMaybe<Scalars['String']>;\n  refererHasPrefix?: InputMaybe<Scalars['String']>;\n  refererHasSuffix?: InputMaybe<Scalars['String']>;\n  refererIn?: InputMaybe<Array<Scalars['String']>>;\n  refererIsNil?: InputMaybe<Scalars['Boolean']>;\n  refererLT?: InputMaybe<Scalars['String']>;\n  refererLTE?: InputMaybe<Scalars['String']>;\n  refererNEQ?: InputMaybe<Scalars['String']>;\n  refererNotIn?: InputMaybe<Array<Scalars['String']>>;\n  refererNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** response_size_bytes field predicates */\n  responseSizeBytes?: InputMaybe<Scalars['Int']>;\n  responseSizeBytesGT?: InputMaybe<Scalars['Int']>;\n  responseSizeBytesGTE?: InputMaybe<Scalars['Int']>;\n  responseSizeBytesIn?: InputMaybe<Array<Scalars['Int']>>;\n  responseSizeBytesLT?: InputMaybe<Scalars['Int']>;\n  responseSizeBytesLTE?: InputMaybe<Scalars['Int']>;\n  responseSizeBytesNEQ?: InputMaybe<Scalars['Int']>;\n  responseSizeBytesNotIn?: InputMaybe<Array<Scalars['Int']>>;\n  /** response_status field predicates */\n  responseStatus?: InputMaybe<Scalars['Int']>;\n  responseStatusGT?: InputMaybe<Scalars['Int']>;\n  responseStatusGTE?: InputMaybe<Scalars['Int']>;\n  responseStatusIn?: InputMaybe<Array<Scalars['Int']>>;\n  responseStatusLT?: InputMaybe<Scalars['Int']>;\n  responseStatusLTE?: InputMaybe<Scalars['Int']>;\n  responseStatusNEQ?: InputMaybe<Scalars['Int']>;\n  responseStatusNotIn?: InputMaybe<Array<Scalars['Int']>>;\n  /** team_id field predicates */\n  teamID?: InputMaybe<Scalars['String']>;\n  teamIDContains?: InputMaybe<Scalars['String']>;\n  teamIDContainsFold?: InputMaybe<Scalars['String']>;\n  teamIDEqualFold?: InputMaybe<Scalars['String']>;\n  teamIDGT?: InputMaybe<Scalars['String']>;\n  teamIDGTE?: InputMaybe<Scalars['String']>;\n  teamIDHasPrefix?: InputMaybe<Scalars['String']>;\n  teamIDHasSuffix?: InputMaybe<Scalars['String']>;\n  teamIDIn?: InputMaybe<Array<Scalars['String']>>;\n  teamIDIsNil?: InputMaybe<Scalars['Boolean']>;\n  teamIDLT?: InputMaybe<Scalars['String']>;\n  teamIDLTE?: InputMaybe<Scalars['String']>;\n  teamIDNEQ?: InputMaybe<Scalars['String']>;\n  teamIDNotIn?: InputMaybe<Array<Scalars['String']>>;\n  teamIDNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** timestamp field predicates */\n  timestamp?: InputMaybe<Scalars['Time']>;\n  timestampGT?: InputMaybe<Scalars['Time']>;\n  timestampGTE?: InputMaybe<Scalars['Time']>;\n  timestampIn?: InputMaybe<Array<Scalars['Time']>>;\n  timestampLT?: InputMaybe<Scalars['Time']>;\n  timestampLTE?: InputMaybe<Scalars['Time']>;\n  timestampNEQ?: InputMaybe<Scalars['Time']>;\n  timestampNotIn?: InputMaybe<Array<Scalars['Time']>>;\n  /** user_agent field predicates */\n  userAgent?: InputMaybe<Scalars['String']>;\n  userAgentContains?: InputMaybe<Scalars['String']>;\n  userAgentContainsFold?: InputMaybe<Scalars['String']>;\n  userAgentEqualFold?: InputMaybe<Scalars['String']>;\n  userAgentGT?: InputMaybe<Scalars['String']>;\n  userAgentGTE?: InputMaybe<Scalars['String']>;\n  userAgentHasPrefix?: InputMaybe<Scalars['String']>;\n  userAgentHasSuffix?: InputMaybe<Scalars['String']>;\n  userAgentIn?: InputMaybe<Array<Scalars['String']>>;\n  userAgentIsNil?: InputMaybe<Scalars['Boolean']>;\n  userAgentLT?: InputMaybe<Scalars['String']>;\n  userAgentLTE?: InputMaybe<Scalars['String']>;\n  userAgentNEQ?: InputMaybe<Scalars['String']>;\n  userAgentNotIn?: InputMaybe<Array<Scalars['String']>>;\n  userAgentNotNil?: InputMaybe<Scalars['Boolean']>;\n};\n\nexport type Resources = {\n  __typename?: 'Resources';\n  cpu?: Maybe<Scalars['Float']>;\n  memory?: Maybe<Scalars['Float']>;\n};\n\nexport type RevokeSessionInput = {\n  chainID: Scalars['String'];\n  sessionHash: Scalars['Felt'];\n  username: Scalars['String'];\n};\n\nexport enum Role {\n  Admin = 'ADMIN',\n  User = 'USER'\n}\n\nexport type SiwsCredential = {\n  __typename?: 'SIWSCredential';\n  provider: Scalars['String'];\n  publicKey: Scalars['String'];\n};\n\nexport type SiwsCredentials = {\n  __typename?: 'SIWSCredentials';\n  siws?: Maybe<Array<SiwsCredential>>;\n};\n\nexport type Service = Node & {\n  __typename?: 'Service';\n  createdAt: Scalars['Time'];\n  deployments?: Maybe<Array<Deployment>>;\n  id: Scalars['ID'];\n  updatedAt: Scalars['Time'];\n};\n\n/** A connection to a list of items. */\nexport type ServiceConnection = {\n  __typename?: 'ServiceConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ServiceEdge>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type ServiceEdge = {\n  __typename?: 'ServiceEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['Cursor'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Service>;\n};\n\n/** Ordering options for Service connections */\nexport type ServiceOrder = {\n  /** The ordering direction. */\n  direction?: OrderDirection;\n  /** The field by which to order Services. */\n  field: ServiceOrderField;\n};\n\n/** Properties by which Service connections can be ordered. */\nexport enum ServiceOrderField {\n  CreatedAt = 'CREATED_AT'\n}\n\n/**\n * ServiceWhereInput is used for filtering Service objects.\n * Input was generated by ent.\n */\nexport type ServiceWhereInput = {\n  and?: InputMaybe<Array<ServiceWhereInput>>;\n  /** created_at field predicates */\n  createdAt?: InputMaybe<Scalars['Time']>;\n  createdAtGT?: InputMaybe<Scalars['Time']>;\n  createdAtGTE?: InputMaybe<Scalars['Time']>;\n  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  createdAtLT?: InputMaybe<Scalars['Time']>;\n  createdAtLTE?: InputMaybe<Scalars['Time']>;\n  createdAtNEQ?: InputMaybe<Scalars['Time']>;\n  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n  /** deployments edge predicates */\n  hasDeployments?: InputMaybe<Scalars['Boolean']>;\n  hasDeploymentsWith?: InputMaybe<Array<DeploymentWhereInput>>;\n  /** id field predicates */\n  id?: InputMaybe<Scalars['ID']>;\n  idContainsFold?: InputMaybe<Scalars['ID']>;\n  idEqualFold?: InputMaybe<Scalars['ID']>;\n  idGT?: InputMaybe<Scalars['ID']>;\n  idGTE?: InputMaybe<Scalars['ID']>;\n  idIn?: InputMaybe<Array<Scalars['ID']>>;\n  idLT?: InputMaybe<Scalars['ID']>;\n  idLTE?: InputMaybe<Scalars['ID']>;\n  idNEQ?: InputMaybe<Scalars['ID']>;\n  idNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  not?: InputMaybe<ServiceWhereInput>;\n  or?: InputMaybe<Array<ServiceWhereInput>>;\n  /** updated_at field predicates */\n  updatedAt?: InputMaybe<Scalars['Time']>;\n  updatedAtGT?: InputMaybe<Scalars['Time']>;\n  updatedAtGTE?: InputMaybe<Scalars['Time']>;\n  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  updatedAtLT?: InputMaybe<Scalars['Time']>;\n  updatedAtLTE?: InputMaybe<Scalars['Time']>;\n  updatedAtNEQ?: InputMaybe<Scalars['Time']>;\n  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n};\n\nexport type Session = Node & {\n  __typename?: 'Session';\n  activities: ActivityConnection;\n  appID: Scalars['String'];\n  /** Array of field elements represented as hex strings */\n  authorization: Array<Scalars['String']>;\n  chainID: Scalars['String'];\n  controller: Controller;\n  /** The time when the session was created */\n  createdAt: Scalars['Time'];\n  /** The time when the session expires */\n  expiresAt: Scalars['Long'];\n  id: Scalars['ID'];\n  /** Whether the session has been revoked */\n  isRevoked: Scalars['Boolean'];\n  metadata?: Maybe<SessionMetadata>;\n  signer?: Maybe<Signer>;\n  updatedAt: Scalars['Time'];\n};\n\n\nexport type SessionActivitiesArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ActivityOrder>;\n  where?: InputMaybe<ActivityWhereInput>;\n};\n\n/** A connection to a list of items. */\nexport type SessionConnection = {\n  __typename?: 'SessionConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SessionEdge>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type SessionEdge = {\n  __typename?: 'SessionEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['Cursor'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Session>;\n};\n\nexport type SessionInput = {\n  allowedPoliciesRoot: Scalars['Felt'];\n  appId?: InputMaybe<Scalars['String']>;\n  authorization: Array<Scalars['Felt']>;\n  expiresAt: Scalars['Long'];\n  guardianKeyGuid: Scalars['Felt'];\n  metadataHash: Scalars['Felt'];\n  sessionKeyGuid: Scalars['Felt'];\n};\n\nexport type SessionMetadata = {\n  __typename?: 'SessionMetadata';\n  browser: Scalars['String'];\n  os: Scalars['String'];\n};\n\n/** Ordering options for Session connections */\nexport type SessionOrder = {\n  /** The ordering direction. */\n  direction?: OrderDirection;\n  /** The field by which to order Sessions. */\n  field: SessionOrderField;\n};\n\n/** Properties by which Session connections can be ordered. */\nexport enum SessionOrderField {\n  CreatedAt = 'CREATED_AT'\n}\n\n/**\n * SessionWhereInput is used for filtering Session objects.\n * Input was generated by ent.\n */\nexport type SessionWhereInput = {\n  and?: InputMaybe<Array<SessionWhereInput>>;\n  /** app_id field predicates */\n  appID?: InputMaybe<Scalars['String']>;\n  appIDContains?: InputMaybe<Scalars['String']>;\n  appIDContainsFold?: InputMaybe<Scalars['String']>;\n  appIDEqualFold?: InputMaybe<Scalars['String']>;\n  appIDGT?: InputMaybe<Scalars['String']>;\n  appIDGTE?: InputMaybe<Scalars['String']>;\n  appIDHasPrefix?: InputMaybe<Scalars['String']>;\n  appIDHasSuffix?: InputMaybe<Scalars['String']>;\n  appIDIn?: InputMaybe<Array<Scalars['String']>>;\n  appIDLT?: InputMaybe<Scalars['String']>;\n  appIDLTE?: InputMaybe<Scalars['String']>;\n  appIDNEQ?: InputMaybe<Scalars['String']>;\n  appIDNotIn?: InputMaybe<Array<Scalars['String']>>;\n  /** chain_id field predicates */\n  chainID?: InputMaybe<Scalars['String']>;\n  chainIDContains?: InputMaybe<Scalars['String']>;\n  chainIDContainsFold?: InputMaybe<Scalars['String']>;\n  chainIDEqualFold?: InputMaybe<Scalars['String']>;\n  chainIDGT?: InputMaybe<Scalars['String']>;\n  chainIDGTE?: InputMaybe<Scalars['String']>;\n  chainIDHasPrefix?: InputMaybe<Scalars['String']>;\n  chainIDHasSuffix?: InputMaybe<Scalars['String']>;\n  chainIDIn?: InputMaybe<Array<Scalars['String']>>;\n  chainIDLT?: InputMaybe<Scalars['String']>;\n  chainIDLTE?: InputMaybe<Scalars['String']>;\n  chainIDNEQ?: InputMaybe<Scalars['String']>;\n  chainIDNotIn?: InputMaybe<Array<Scalars['String']>>;\n  /** created_at field predicates */\n  createdAt?: InputMaybe<Scalars['Time']>;\n  createdAtGT?: InputMaybe<Scalars['Time']>;\n  createdAtGTE?: InputMaybe<Scalars['Time']>;\n  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  createdAtLT?: InputMaybe<Scalars['Time']>;\n  createdAtLTE?: InputMaybe<Scalars['Time']>;\n  createdAtNEQ?: InputMaybe<Scalars['Time']>;\n  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n  /** expires_at field predicates */\n  expiresAt?: InputMaybe<Scalars['Long']>;\n  expiresAtGT?: InputMaybe<Scalars['Long']>;\n  expiresAtGTE?: InputMaybe<Scalars['Long']>;\n  expiresAtIn?: InputMaybe<Array<Scalars['Long']>>;\n  expiresAtLT?: InputMaybe<Scalars['Long']>;\n  expiresAtLTE?: InputMaybe<Scalars['Long']>;\n  expiresAtNEQ?: InputMaybe<Scalars['Long']>;\n  expiresAtNotIn?: InputMaybe<Array<Scalars['Long']>>;\n  /** activities edge predicates */\n  hasActivities?: InputMaybe<Scalars['Boolean']>;\n  hasActivitiesWith?: InputMaybe<Array<ActivityWhereInput>>;\n  /** controller edge predicates */\n  hasController?: InputMaybe<Scalars['Boolean']>;\n  hasControllerWith?: InputMaybe<Array<ControllerWhereInput>>;\n  /** signer edge predicates */\n  hasSigner?: InputMaybe<Scalars['Boolean']>;\n  hasSignerWith?: InputMaybe<Array<SignerWhereInput>>;\n  /** id field predicates */\n  id?: InputMaybe<Scalars['ID']>;\n  idContainsFold?: InputMaybe<Scalars['ID']>;\n  idEqualFold?: InputMaybe<Scalars['ID']>;\n  idGT?: InputMaybe<Scalars['ID']>;\n  idGTE?: InputMaybe<Scalars['ID']>;\n  idIn?: InputMaybe<Array<Scalars['ID']>>;\n  idLT?: InputMaybe<Scalars['ID']>;\n  idLTE?: InputMaybe<Scalars['ID']>;\n  idNEQ?: InputMaybe<Scalars['ID']>;\n  idNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  /** is_revoked field predicates */\n  isRevoked?: InputMaybe<Scalars['Boolean']>;\n  isRevokedNEQ?: InputMaybe<Scalars['Boolean']>;\n  not?: InputMaybe<SessionWhereInput>;\n  or?: InputMaybe<Array<SessionWhereInput>>;\n  /** updated_at field predicates */\n  updatedAt?: InputMaybe<Scalars['Time']>;\n  updatedAtGT?: InputMaybe<Scalars['Time']>;\n  updatedAtGTE?: InputMaybe<Scalars['Time']>;\n  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  updatedAtLT?: InputMaybe<Scalars['Time']>;\n  updatedAtLTE?: InputMaybe<Scalars['Time']>;\n  updatedAtNEQ?: InputMaybe<Scalars['Time']>;\n  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n};\n\nexport type Signer = Node & {\n  __typename?: 'Signer';\n  controller: Controller;\n  controllerID: Scalars['ID'];\n  createdAt: Scalars['Time'];\n  id: Scalars['ID'];\n  isOriginal: Scalars['Boolean'];\n  isRevoked: Scalars['Boolean'];\n  metadata: CredentialMetadata;\n  session?: Maybe<Session>;\n  type: SignerType;\n  updatedAt: Scalars['Time'];\n};\n\nexport type SignerInput = {\n  credential: Scalars['JSON'];\n  type: SignerType;\n};\n\n/** Ordering options for Signer connections */\nexport type SignerOrder = {\n  /** The ordering direction. */\n  direction?: OrderDirection;\n  /** The field by which to order Signers. */\n  field: SignerOrderField;\n};\n\n/** Properties by which Signer connections can be ordered. */\nexport enum SignerOrderField {\n  CreatedAt = 'CREATED_AT'\n}\n\n/** SignerType is enum for the field type */\nexport enum SignerType {\n  Eip191 = 'eip191',\n  Password = 'password',\n  Secp256k1 = 'secp256k1',\n  Secp256r1 = 'secp256r1',\n  Siws = 'siws',\n  Starknet = 'starknet',\n  StarknetAccount = 'starknet_account',\n  Webauthn = 'webauthn'\n}\n\n/**\n * SignerWhereInput is used for filtering Signer objects.\n * Input was generated by ent.\n */\nexport type SignerWhereInput = {\n  and?: InputMaybe<Array<SignerWhereInput>>;\n  /** controller_id field predicates */\n  controllerID?: InputMaybe<Scalars['ID']>;\n  controllerIDContains?: InputMaybe<Scalars['ID']>;\n  controllerIDContainsFold?: InputMaybe<Scalars['ID']>;\n  controllerIDEqualFold?: InputMaybe<Scalars['ID']>;\n  controllerIDGT?: InputMaybe<Scalars['ID']>;\n  controllerIDGTE?: InputMaybe<Scalars['ID']>;\n  controllerIDHasPrefix?: InputMaybe<Scalars['ID']>;\n  controllerIDHasSuffix?: InputMaybe<Scalars['ID']>;\n  controllerIDIn?: InputMaybe<Array<Scalars['ID']>>;\n  controllerIDLT?: InputMaybe<Scalars['ID']>;\n  controllerIDLTE?: InputMaybe<Scalars['ID']>;\n  controllerIDNEQ?: InputMaybe<Scalars['ID']>;\n  controllerIDNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  /** created_at field predicates */\n  createdAt?: InputMaybe<Scalars['Time']>;\n  createdAtGT?: InputMaybe<Scalars['Time']>;\n  createdAtGTE?: InputMaybe<Scalars['Time']>;\n  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  createdAtLT?: InputMaybe<Scalars['Time']>;\n  createdAtLTE?: InputMaybe<Scalars['Time']>;\n  createdAtNEQ?: InputMaybe<Scalars['Time']>;\n  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n  /** controller edge predicates */\n  hasController?: InputMaybe<Scalars['Boolean']>;\n  hasControllerWith?: InputMaybe<Array<ControllerWhereInput>>;\n  /** session edge predicates */\n  hasSession?: InputMaybe<Scalars['Boolean']>;\n  hasSessionWith?: InputMaybe<Array<SessionWhereInput>>;\n  /** id field predicates */\n  id?: InputMaybe<Scalars['ID']>;\n  idContainsFold?: InputMaybe<Scalars['ID']>;\n  idEqualFold?: InputMaybe<Scalars['ID']>;\n  idGT?: InputMaybe<Scalars['ID']>;\n  idGTE?: InputMaybe<Scalars['ID']>;\n  idIn?: InputMaybe<Array<Scalars['ID']>>;\n  idLT?: InputMaybe<Scalars['ID']>;\n  idLTE?: InputMaybe<Scalars['ID']>;\n  idNEQ?: InputMaybe<Scalars['ID']>;\n  idNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  /** is_original field predicates */\n  isOriginal?: InputMaybe<Scalars['Boolean']>;\n  isOriginalNEQ?: InputMaybe<Scalars['Boolean']>;\n  /** is_revoked field predicates */\n  isRevoked?: InputMaybe<Scalars['Boolean']>;\n  isRevokedNEQ?: InputMaybe<Scalars['Boolean']>;\n  not?: InputMaybe<SignerWhereInput>;\n  or?: InputMaybe<Array<SignerWhereInput>>;\n  /** type field predicates */\n  type?: InputMaybe<SignerType>;\n  typeIn?: InputMaybe<Array<SignerType>>;\n  typeNEQ?: InputMaybe<SignerType>;\n  typeNotIn?: InputMaybe<Array<SignerType>>;\n  /** updated_at field predicates */\n  updatedAt?: InputMaybe<Scalars['Time']>;\n  updatedAtGT?: InputMaybe<Scalars['Time']>;\n  updatedAtGTE?: InputMaybe<Scalars['Time']>;\n  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  updatedAtLT?: InputMaybe<Scalars['Time']>;\n  updatedAtLTE?: InputMaybe<Scalars['Time']>;\n  updatedAtNEQ?: InputMaybe<Scalars['Time']>;\n  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n};\n\nexport type StarknetCredential = {\n  __typename?: 'StarknetCredential';\n  publicKey: Scalars['String'];\n};\n\nexport type StarknetCredentials = {\n  __typename?: 'StarknetCredentials';\n  starknet?: Maybe<Array<StarknetCredential>>;\n};\n\nexport type Starterpack = Node & {\n  __typename?: 'Starterpack';\n  /** Type of acquisition for the starterpack */\n  acquisitionType: StarterpackAcquisitionType;\n  active: Scalars['Boolean'];\n  chainID: Scalars['String'];\n  createdAt: Scalars['Time'];\n  description?: Maybe<Scalars['String']>;\n  id: Scalars['ID'];\n  issuance: Scalars['Int'];\n  maxIssuance?: Maybe<Scalars['Int']>;\n  /** Maximum number of issuances per account */\n  maxPerAccount?: Maybe<Scalars['Int']>;\n  merkleDrops: MerkleDropConnection;\n  name: Scalars['String'];\n  paymaster?: Maybe<Paymaster>;\n  paymasterID?: Maybe<Scalars['ID']>;\n  starterpackContract: StarterpackContractConnection;\n  starterpackMint: StarterpackMintConnection;\n  team?: Maybe<Team>;\n  updatedAt: Scalars['Time'];\n};\n\n\nexport type StarterpackMerkleDropsArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<MerkleDropOrder>;\n  where?: InputMaybe<MerkleDropWhereInput>;\n};\n\n\nexport type StarterpackStarterpackContractArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<StarterpackContractOrder>;\n  where?: InputMaybe<StarterpackContractWhereInput>;\n};\n\n\nexport type StarterpackStarterpackMintArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<StarterpackMintOrder>;\n  where?: InputMaybe<StarterpackMintWhereInput>;\n};\n\n/** StarterpackAcquisitionType is enum for the field acquisition_type */\nexport enum StarterpackAcquisitionType {\n  Claimed = 'CLAIMED',\n  Paid = 'PAID'\n}\n\n/** A connection to a list of items. */\nexport type StarterpackConnection = {\n  __typename?: 'StarterpackConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<StarterpackEdge>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\nexport type StarterpackContract = Node & {\n  __typename?: 'StarterpackContract';\n  /** Calldata for the execution entrypoint */\n  calldata: Array<Scalars['String']>;\n  contractAddress: Scalars['String'];\n  createdAt: Scalars['Time'];\n  description?: Maybe<Scalars['String']>;\n  /** Entrypoint to execute on the contract */\n  entryPoint: Scalars['String'];\n  iconURL?: Maybe<Scalars['String']>;\n  id: Scalars['ID'];\n  name: Scalars['String'];\n  starterpack: Starterpack;\n  starterpackID: Scalars['ID'];\n  /** Calldata for the supply check entrypoint */\n  supplyCalldata?: Maybe<Array<Scalars['String']>>;\n  /** Entrypoint to check available supply on the contract */\n  supplyEntryPoint?: Maybe<Scalars['String']>;\n  updatedAt: Scalars['Time'];\n};\n\n/** A connection to a list of items. */\nexport type StarterpackContractConnection = {\n  __typename?: 'StarterpackContractConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<StarterpackContractEdge>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type StarterpackContractEdge = {\n  __typename?: 'StarterpackContractEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['Cursor'];\n  /** The item at the end of the edge. */\n  node?: Maybe<StarterpackContract>;\n};\n\n/** Ordering options for StarterpackContract connections */\nexport type StarterpackContractOrder = {\n  /** The ordering direction. */\n  direction?: OrderDirection;\n  /** The field by which to order StarterpackContracts. */\n  field: StarterpackContractOrderField;\n};\n\n/** Properties by which StarterpackContract connections can be ordered. */\nexport enum StarterpackContractOrderField {\n  CreatedAt = 'CREATED_AT'\n}\n\n/**\n * StarterpackContractWhereInput is used for filtering StarterpackContract objects.\n * Input was generated by ent.\n */\nexport type StarterpackContractWhereInput = {\n  and?: InputMaybe<Array<StarterpackContractWhereInput>>;\n  /** contract_address field predicates */\n  contractAddress?: InputMaybe<Scalars['String']>;\n  contractAddressContains?: InputMaybe<Scalars['String']>;\n  contractAddressContainsFold?: InputMaybe<Scalars['String']>;\n  contractAddressEqualFold?: InputMaybe<Scalars['String']>;\n  contractAddressGT?: InputMaybe<Scalars['String']>;\n  contractAddressGTE?: InputMaybe<Scalars['String']>;\n  contractAddressHasPrefix?: InputMaybe<Scalars['String']>;\n  contractAddressHasSuffix?: InputMaybe<Scalars['String']>;\n  contractAddressIn?: InputMaybe<Array<Scalars['String']>>;\n  contractAddressLT?: InputMaybe<Scalars['String']>;\n  contractAddressLTE?: InputMaybe<Scalars['String']>;\n  contractAddressNEQ?: InputMaybe<Scalars['String']>;\n  contractAddressNotIn?: InputMaybe<Array<Scalars['String']>>;\n  /** created_at field predicates */\n  createdAt?: InputMaybe<Scalars['Time']>;\n  createdAtGT?: InputMaybe<Scalars['Time']>;\n  createdAtGTE?: InputMaybe<Scalars['Time']>;\n  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  createdAtLT?: InputMaybe<Scalars['Time']>;\n  createdAtLTE?: InputMaybe<Scalars['Time']>;\n  createdAtNEQ?: InputMaybe<Scalars['Time']>;\n  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n  /** description field predicates */\n  description?: InputMaybe<Scalars['String']>;\n  descriptionContains?: InputMaybe<Scalars['String']>;\n  descriptionContainsFold?: InputMaybe<Scalars['String']>;\n  descriptionEqualFold?: InputMaybe<Scalars['String']>;\n  descriptionGT?: InputMaybe<Scalars['String']>;\n  descriptionGTE?: InputMaybe<Scalars['String']>;\n  descriptionHasPrefix?: InputMaybe<Scalars['String']>;\n  descriptionHasSuffix?: InputMaybe<Scalars['String']>;\n  descriptionIn?: InputMaybe<Array<Scalars['String']>>;\n  descriptionIsNil?: InputMaybe<Scalars['Boolean']>;\n  descriptionLT?: InputMaybe<Scalars['String']>;\n  descriptionLTE?: InputMaybe<Scalars['String']>;\n  descriptionNEQ?: InputMaybe<Scalars['String']>;\n  descriptionNotIn?: InputMaybe<Array<Scalars['String']>>;\n  descriptionNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** entry_point field predicates */\n  entryPoint?: InputMaybe<Scalars['String']>;\n  entryPointContains?: InputMaybe<Scalars['String']>;\n  entryPointContainsFold?: InputMaybe<Scalars['String']>;\n  entryPointEqualFold?: InputMaybe<Scalars['String']>;\n  entryPointGT?: InputMaybe<Scalars['String']>;\n  entryPointGTE?: InputMaybe<Scalars['String']>;\n  entryPointHasPrefix?: InputMaybe<Scalars['String']>;\n  entryPointHasSuffix?: InputMaybe<Scalars['String']>;\n  entryPointIn?: InputMaybe<Array<Scalars['String']>>;\n  entryPointLT?: InputMaybe<Scalars['String']>;\n  entryPointLTE?: InputMaybe<Scalars['String']>;\n  entryPointNEQ?: InputMaybe<Scalars['String']>;\n  entryPointNotIn?: InputMaybe<Array<Scalars['String']>>;\n  /** starterpack edge predicates */\n  hasStarterpack?: InputMaybe<Scalars['Boolean']>;\n  hasStarterpackWith?: InputMaybe<Array<StarterpackWhereInput>>;\n  /** icon_url field predicates */\n  iconURL?: InputMaybe<Scalars['String']>;\n  iconURLContains?: InputMaybe<Scalars['String']>;\n  iconURLContainsFold?: InputMaybe<Scalars['String']>;\n  iconURLEqualFold?: InputMaybe<Scalars['String']>;\n  iconURLGT?: InputMaybe<Scalars['String']>;\n  iconURLGTE?: InputMaybe<Scalars['String']>;\n  iconURLHasPrefix?: InputMaybe<Scalars['String']>;\n  iconURLHasSuffix?: InputMaybe<Scalars['String']>;\n  iconURLIn?: InputMaybe<Array<Scalars['String']>>;\n  iconURLIsNil?: InputMaybe<Scalars['Boolean']>;\n  iconURLLT?: InputMaybe<Scalars['String']>;\n  iconURLLTE?: InputMaybe<Scalars['String']>;\n  iconURLNEQ?: InputMaybe<Scalars['String']>;\n  iconURLNotIn?: InputMaybe<Array<Scalars['String']>>;\n  iconURLNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** id field predicates */\n  id?: InputMaybe<Scalars['ID']>;\n  idContainsFold?: InputMaybe<Scalars['ID']>;\n  idEqualFold?: InputMaybe<Scalars['ID']>;\n  idGT?: InputMaybe<Scalars['ID']>;\n  idGTE?: InputMaybe<Scalars['ID']>;\n  idIn?: InputMaybe<Array<Scalars['ID']>>;\n  idLT?: InputMaybe<Scalars['ID']>;\n  idLTE?: InputMaybe<Scalars['ID']>;\n  idNEQ?: InputMaybe<Scalars['ID']>;\n  idNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  /** name field predicates */\n  name?: InputMaybe<Scalars['String']>;\n  nameContains?: InputMaybe<Scalars['String']>;\n  nameContainsFold?: InputMaybe<Scalars['String']>;\n  nameEqualFold?: InputMaybe<Scalars['String']>;\n  nameGT?: InputMaybe<Scalars['String']>;\n  nameGTE?: InputMaybe<Scalars['String']>;\n  nameHasPrefix?: InputMaybe<Scalars['String']>;\n  nameHasSuffix?: InputMaybe<Scalars['String']>;\n  nameIn?: InputMaybe<Array<Scalars['String']>>;\n  nameLT?: InputMaybe<Scalars['String']>;\n  nameLTE?: InputMaybe<Scalars['String']>;\n  nameNEQ?: InputMaybe<Scalars['String']>;\n  nameNotIn?: InputMaybe<Array<Scalars['String']>>;\n  not?: InputMaybe<StarterpackContractWhereInput>;\n  or?: InputMaybe<Array<StarterpackContractWhereInput>>;\n  /** starterpack_id field predicates */\n  starterpackID?: InputMaybe<Scalars['ID']>;\n  starterpackIDContains?: InputMaybe<Scalars['ID']>;\n  starterpackIDContainsFold?: InputMaybe<Scalars['ID']>;\n  starterpackIDEqualFold?: InputMaybe<Scalars['ID']>;\n  starterpackIDGT?: InputMaybe<Scalars['ID']>;\n  starterpackIDGTE?: InputMaybe<Scalars['ID']>;\n  starterpackIDHasPrefix?: InputMaybe<Scalars['ID']>;\n  starterpackIDHasSuffix?: InputMaybe<Scalars['ID']>;\n  starterpackIDIn?: InputMaybe<Array<Scalars['ID']>>;\n  starterpackIDLT?: InputMaybe<Scalars['ID']>;\n  starterpackIDLTE?: InputMaybe<Scalars['ID']>;\n  starterpackIDNEQ?: InputMaybe<Scalars['ID']>;\n  starterpackIDNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  /** supply_entry_point field predicates */\n  supplyEntryPoint?: InputMaybe<Scalars['String']>;\n  supplyEntryPointContains?: InputMaybe<Scalars['String']>;\n  supplyEntryPointContainsFold?: InputMaybe<Scalars['String']>;\n  supplyEntryPointEqualFold?: InputMaybe<Scalars['String']>;\n  supplyEntryPointGT?: InputMaybe<Scalars['String']>;\n  supplyEntryPointGTE?: InputMaybe<Scalars['String']>;\n  supplyEntryPointHasPrefix?: InputMaybe<Scalars['String']>;\n  supplyEntryPointHasSuffix?: InputMaybe<Scalars['String']>;\n  supplyEntryPointIn?: InputMaybe<Array<Scalars['String']>>;\n  supplyEntryPointIsNil?: InputMaybe<Scalars['Boolean']>;\n  supplyEntryPointLT?: InputMaybe<Scalars['String']>;\n  supplyEntryPointLTE?: InputMaybe<Scalars['String']>;\n  supplyEntryPointNEQ?: InputMaybe<Scalars['String']>;\n  supplyEntryPointNotIn?: InputMaybe<Array<Scalars['String']>>;\n  supplyEntryPointNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** updated_at field predicates */\n  updatedAt?: InputMaybe<Scalars['Time']>;\n  updatedAtGT?: InputMaybe<Scalars['Time']>;\n  updatedAtGTE?: InputMaybe<Scalars['Time']>;\n  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  updatedAtLT?: InputMaybe<Scalars['Time']>;\n  updatedAtLTE?: InputMaybe<Scalars['Time']>;\n  updatedAtNEQ?: InputMaybe<Scalars['Time']>;\n  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n};\n\nexport type StarterpackDetails = {\n  __typename?: 'StarterpackDetails';\n  acquisitionType: StarterpackAcquisitionType;\n  bonusCredits: Credits;\n  mintAllowance?: Maybe<MintAllowance>;\n  price: Credits;\n  starterpack: Starterpack;\n};\n\n/** An edge in a connection. */\nexport type StarterpackEdge = {\n  __typename?: 'StarterpackEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['Cursor'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Starterpack>;\n};\n\nexport type StarterpackInput = {\n  accountId: Scalars['ID'];\n  starterpackId: Scalars['ID'];\n};\n\nexport type StarterpackMint = Node & {\n  __typename?: 'StarterpackMint';\n  account: Account;\n  accountID: Scalars['ID'];\n  activity?: Maybe<Activity>;\n  activityID?: Maybe<Scalars['ID']>;\n  createdAt: Scalars['Time'];\n  id: Scalars['ID'];\n  starterpack: Starterpack;\n  starterpackID: Scalars['ID'];\n  updatedAt: Scalars['Time'];\n};\n\n/** A connection to a list of items. */\nexport type StarterpackMintConnection = {\n  __typename?: 'StarterpackMintConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<StarterpackMintEdge>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type StarterpackMintEdge = {\n  __typename?: 'StarterpackMintEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['Cursor'];\n  /** The item at the end of the edge. */\n  node?: Maybe<StarterpackMint>;\n};\n\n/** Ordering options for StarterpackMint connections */\nexport type StarterpackMintOrder = {\n  /** The ordering direction. */\n  direction?: OrderDirection;\n  /** The field by which to order StarterpackMints. */\n  field: StarterpackMintOrderField;\n};\n\n/** Properties by which StarterpackMint connections can be ordered. */\nexport enum StarterpackMintOrderField {\n  CreatedAt = 'CREATED_AT'\n}\n\n/**\n * StarterpackMintWhereInput is used for filtering StarterpackMint objects.\n * Input was generated by ent.\n */\nexport type StarterpackMintWhereInput = {\n  /** account_id field predicates */\n  accountID?: InputMaybe<Scalars['ID']>;\n  accountIDContains?: InputMaybe<Scalars['ID']>;\n  accountIDContainsFold?: InputMaybe<Scalars['ID']>;\n  accountIDEqualFold?: InputMaybe<Scalars['ID']>;\n  accountIDGT?: InputMaybe<Scalars['ID']>;\n  accountIDGTE?: InputMaybe<Scalars['ID']>;\n  accountIDHasPrefix?: InputMaybe<Scalars['ID']>;\n  accountIDHasSuffix?: InputMaybe<Scalars['ID']>;\n  accountIDIn?: InputMaybe<Array<Scalars['ID']>>;\n  accountIDLT?: InputMaybe<Scalars['ID']>;\n  accountIDLTE?: InputMaybe<Scalars['ID']>;\n  accountIDNEQ?: InputMaybe<Scalars['ID']>;\n  accountIDNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  /** activity_id field predicates */\n  activityID?: InputMaybe<Scalars['ID']>;\n  activityIDContains?: InputMaybe<Scalars['ID']>;\n  activityIDContainsFold?: InputMaybe<Scalars['ID']>;\n  activityIDEqualFold?: InputMaybe<Scalars['ID']>;\n  activityIDGT?: InputMaybe<Scalars['ID']>;\n  activityIDGTE?: InputMaybe<Scalars['ID']>;\n  activityIDHasPrefix?: InputMaybe<Scalars['ID']>;\n  activityIDHasSuffix?: InputMaybe<Scalars['ID']>;\n  activityIDIn?: InputMaybe<Array<Scalars['ID']>>;\n  activityIDIsNil?: InputMaybe<Scalars['Boolean']>;\n  activityIDLT?: InputMaybe<Scalars['ID']>;\n  activityIDLTE?: InputMaybe<Scalars['ID']>;\n  activityIDNEQ?: InputMaybe<Scalars['ID']>;\n  activityIDNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  activityIDNotNil?: InputMaybe<Scalars['Boolean']>;\n  and?: InputMaybe<Array<StarterpackMintWhereInput>>;\n  /** created_at field predicates */\n  createdAt?: InputMaybe<Scalars['Time']>;\n  createdAtGT?: InputMaybe<Scalars['Time']>;\n  createdAtGTE?: InputMaybe<Scalars['Time']>;\n  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  createdAtLT?: InputMaybe<Scalars['Time']>;\n  createdAtLTE?: InputMaybe<Scalars['Time']>;\n  createdAtNEQ?: InputMaybe<Scalars['Time']>;\n  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n  /** account edge predicates */\n  hasAccount?: InputMaybe<Scalars['Boolean']>;\n  hasAccountWith?: InputMaybe<Array<AccountWhereInput>>;\n  /** activity edge predicates */\n  hasActivity?: InputMaybe<Scalars['Boolean']>;\n  hasActivityWith?: InputMaybe<Array<ActivityWhereInput>>;\n  /** starterpack edge predicates */\n  hasStarterpack?: InputMaybe<Scalars['Boolean']>;\n  hasStarterpackWith?: InputMaybe<Array<StarterpackWhereInput>>;\n  /** id field predicates */\n  id?: InputMaybe<Scalars['ID']>;\n  idContainsFold?: InputMaybe<Scalars['ID']>;\n  idEqualFold?: InputMaybe<Scalars['ID']>;\n  idGT?: InputMaybe<Scalars['ID']>;\n  idGTE?: InputMaybe<Scalars['ID']>;\n  idIn?: InputMaybe<Array<Scalars['ID']>>;\n  idLT?: InputMaybe<Scalars['ID']>;\n  idLTE?: InputMaybe<Scalars['ID']>;\n  idNEQ?: InputMaybe<Scalars['ID']>;\n  idNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  not?: InputMaybe<StarterpackMintWhereInput>;\n  or?: InputMaybe<Array<StarterpackMintWhereInput>>;\n  /** starterpack_id field predicates */\n  starterpackID?: InputMaybe<Scalars['ID']>;\n  starterpackIDContains?: InputMaybe<Scalars['ID']>;\n  starterpackIDContainsFold?: InputMaybe<Scalars['ID']>;\n  starterpackIDEqualFold?: InputMaybe<Scalars['ID']>;\n  starterpackIDGT?: InputMaybe<Scalars['ID']>;\n  starterpackIDGTE?: InputMaybe<Scalars['ID']>;\n  starterpackIDHasPrefix?: InputMaybe<Scalars['ID']>;\n  starterpackIDHasSuffix?: InputMaybe<Scalars['ID']>;\n  starterpackIDIn?: InputMaybe<Array<Scalars['ID']>>;\n  starterpackIDLT?: InputMaybe<Scalars['ID']>;\n  starterpackIDLTE?: InputMaybe<Scalars['ID']>;\n  starterpackIDNEQ?: InputMaybe<Scalars['ID']>;\n  starterpackIDNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  /** updated_at field predicates */\n  updatedAt?: InputMaybe<Scalars['Time']>;\n  updatedAtGT?: InputMaybe<Scalars['Time']>;\n  updatedAtGTE?: InputMaybe<Scalars['Time']>;\n  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  updatedAtLT?: InputMaybe<Scalars['Time']>;\n  updatedAtLTE?: InputMaybe<Scalars['Time']>;\n  updatedAtNEQ?: InputMaybe<Scalars['Time']>;\n  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n};\n\n/** Ordering options for Starterpack connections */\nexport type StarterpackOrder = {\n  /** The ordering direction. */\n  direction?: OrderDirection;\n  /** The field by which to order Starterpacks. */\n  field: StarterpackOrderField;\n};\n\n/** Properties by which Starterpack connections can be ordered. */\nexport enum StarterpackOrderField {\n  CreatedAt = 'CREATED_AT'\n}\n\n/**\n * StarterpackWhereInput is used for filtering Starterpack objects.\n * Input was generated by ent.\n */\nexport type StarterpackWhereInput = {\n  /** acquisition_type field predicates */\n  acquisitionType?: InputMaybe<StarterpackAcquisitionType>;\n  acquisitionTypeIn?: InputMaybe<Array<StarterpackAcquisitionType>>;\n  acquisitionTypeNEQ?: InputMaybe<StarterpackAcquisitionType>;\n  acquisitionTypeNotIn?: InputMaybe<Array<StarterpackAcquisitionType>>;\n  /** active field predicates */\n  active?: InputMaybe<Scalars['Boolean']>;\n  activeNEQ?: InputMaybe<Scalars['Boolean']>;\n  and?: InputMaybe<Array<StarterpackWhereInput>>;\n  /** chain_id field predicates */\n  chainID?: InputMaybe<Scalars['String']>;\n  chainIDContains?: InputMaybe<Scalars['String']>;\n  chainIDContainsFold?: InputMaybe<Scalars['String']>;\n  chainIDEqualFold?: InputMaybe<Scalars['String']>;\n  chainIDGT?: InputMaybe<Scalars['String']>;\n  chainIDGTE?: InputMaybe<Scalars['String']>;\n  chainIDHasPrefix?: InputMaybe<Scalars['String']>;\n  chainIDHasSuffix?: InputMaybe<Scalars['String']>;\n  chainIDIn?: InputMaybe<Array<Scalars['String']>>;\n  chainIDLT?: InputMaybe<Scalars['String']>;\n  chainIDLTE?: InputMaybe<Scalars['String']>;\n  chainIDNEQ?: InputMaybe<Scalars['String']>;\n  chainIDNotIn?: InputMaybe<Array<Scalars['String']>>;\n  /** created_at field predicates */\n  createdAt?: InputMaybe<Scalars['Time']>;\n  createdAtGT?: InputMaybe<Scalars['Time']>;\n  createdAtGTE?: InputMaybe<Scalars['Time']>;\n  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  createdAtLT?: InputMaybe<Scalars['Time']>;\n  createdAtLTE?: InputMaybe<Scalars['Time']>;\n  createdAtNEQ?: InputMaybe<Scalars['Time']>;\n  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n  /** description field predicates */\n  description?: InputMaybe<Scalars['String']>;\n  descriptionContains?: InputMaybe<Scalars['String']>;\n  descriptionContainsFold?: InputMaybe<Scalars['String']>;\n  descriptionEqualFold?: InputMaybe<Scalars['String']>;\n  descriptionGT?: InputMaybe<Scalars['String']>;\n  descriptionGTE?: InputMaybe<Scalars['String']>;\n  descriptionHasPrefix?: InputMaybe<Scalars['String']>;\n  descriptionHasSuffix?: InputMaybe<Scalars['String']>;\n  descriptionIn?: InputMaybe<Array<Scalars['String']>>;\n  descriptionIsNil?: InputMaybe<Scalars['Boolean']>;\n  descriptionLT?: InputMaybe<Scalars['String']>;\n  descriptionLTE?: InputMaybe<Scalars['String']>;\n  descriptionNEQ?: InputMaybe<Scalars['String']>;\n  descriptionNotIn?: InputMaybe<Array<Scalars['String']>>;\n  descriptionNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** merkle_drops edge predicates */\n  hasMerkleDrops?: InputMaybe<Scalars['Boolean']>;\n  hasMerkleDropsWith?: InputMaybe<Array<MerkleDropWhereInput>>;\n  /** paymaster edge predicates */\n  hasPaymaster?: InputMaybe<Scalars['Boolean']>;\n  hasPaymasterWith?: InputMaybe<Array<PaymasterWhereInput>>;\n  /** starterpack_contract edge predicates */\n  hasStarterpackContract?: InputMaybe<Scalars['Boolean']>;\n  hasStarterpackContractWith?: InputMaybe<Array<StarterpackContractWhereInput>>;\n  /** starterpack_mint edge predicates */\n  hasStarterpackMint?: InputMaybe<Scalars['Boolean']>;\n  hasStarterpackMintWith?: InputMaybe<Array<StarterpackMintWhereInput>>;\n  /** team edge predicates */\n  hasTeam?: InputMaybe<Scalars['Boolean']>;\n  hasTeamWith?: InputMaybe<Array<TeamWhereInput>>;\n  /** id field predicates */\n  id?: InputMaybe<Scalars['ID']>;\n  idContainsFold?: InputMaybe<Scalars['ID']>;\n  idEqualFold?: InputMaybe<Scalars['ID']>;\n  idGT?: InputMaybe<Scalars['ID']>;\n  idGTE?: InputMaybe<Scalars['ID']>;\n  idIn?: InputMaybe<Array<Scalars['ID']>>;\n  idLT?: InputMaybe<Scalars['ID']>;\n  idLTE?: InputMaybe<Scalars['ID']>;\n  idNEQ?: InputMaybe<Scalars['ID']>;\n  idNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  /** issuance field predicates */\n  issuance?: InputMaybe<Scalars['Int']>;\n  issuanceGT?: InputMaybe<Scalars['Int']>;\n  issuanceGTE?: InputMaybe<Scalars['Int']>;\n  issuanceIn?: InputMaybe<Array<Scalars['Int']>>;\n  issuanceLT?: InputMaybe<Scalars['Int']>;\n  issuanceLTE?: InputMaybe<Scalars['Int']>;\n  issuanceNEQ?: InputMaybe<Scalars['Int']>;\n  issuanceNotIn?: InputMaybe<Array<Scalars['Int']>>;\n  /** max_issuance field predicates */\n  maxIssuance?: InputMaybe<Scalars['Int']>;\n  maxIssuanceGT?: InputMaybe<Scalars['Int']>;\n  maxIssuanceGTE?: InputMaybe<Scalars['Int']>;\n  maxIssuanceIn?: InputMaybe<Array<Scalars['Int']>>;\n  maxIssuanceIsNil?: InputMaybe<Scalars['Boolean']>;\n  maxIssuanceLT?: InputMaybe<Scalars['Int']>;\n  maxIssuanceLTE?: InputMaybe<Scalars['Int']>;\n  maxIssuanceNEQ?: InputMaybe<Scalars['Int']>;\n  maxIssuanceNotIn?: InputMaybe<Array<Scalars['Int']>>;\n  maxIssuanceNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** max_per_account field predicates */\n  maxPerAccount?: InputMaybe<Scalars['Int']>;\n  maxPerAccountGT?: InputMaybe<Scalars['Int']>;\n  maxPerAccountGTE?: InputMaybe<Scalars['Int']>;\n  maxPerAccountIn?: InputMaybe<Array<Scalars['Int']>>;\n  maxPerAccountIsNil?: InputMaybe<Scalars['Boolean']>;\n  maxPerAccountLT?: InputMaybe<Scalars['Int']>;\n  maxPerAccountLTE?: InputMaybe<Scalars['Int']>;\n  maxPerAccountNEQ?: InputMaybe<Scalars['Int']>;\n  maxPerAccountNotIn?: InputMaybe<Array<Scalars['Int']>>;\n  maxPerAccountNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** name field predicates */\n  name?: InputMaybe<Scalars['String']>;\n  nameContains?: InputMaybe<Scalars['String']>;\n  nameContainsFold?: InputMaybe<Scalars['String']>;\n  nameEqualFold?: InputMaybe<Scalars['String']>;\n  nameGT?: InputMaybe<Scalars['String']>;\n  nameGTE?: InputMaybe<Scalars['String']>;\n  nameHasPrefix?: InputMaybe<Scalars['String']>;\n  nameHasSuffix?: InputMaybe<Scalars['String']>;\n  nameIn?: InputMaybe<Array<Scalars['String']>>;\n  nameLT?: InputMaybe<Scalars['String']>;\n  nameLTE?: InputMaybe<Scalars['String']>;\n  nameNEQ?: InputMaybe<Scalars['String']>;\n  nameNotIn?: InputMaybe<Array<Scalars['String']>>;\n  not?: InputMaybe<StarterpackWhereInput>;\n  or?: InputMaybe<Array<StarterpackWhereInput>>;\n  /** paymaster_id field predicates */\n  paymasterID?: InputMaybe<Scalars['ID']>;\n  paymasterIDContains?: InputMaybe<Scalars['ID']>;\n  paymasterIDContainsFold?: InputMaybe<Scalars['ID']>;\n  paymasterIDEqualFold?: InputMaybe<Scalars['ID']>;\n  paymasterIDGT?: InputMaybe<Scalars['ID']>;\n  paymasterIDGTE?: InputMaybe<Scalars['ID']>;\n  paymasterIDHasPrefix?: InputMaybe<Scalars['ID']>;\n  paymasterIDHasSuffix?: InputMaybe<Scalars['ID']>;\n  paymasterIDIn?: InputMaybe<Array<Scalars['ID']>>;\n  paymasterIDIsNil?: InputMaybe<Scalars['Boolean']>;\n  paymasterIDLT?: InputMaybe<Scalars['ID']>;\n  paymasterIDLTE?: InputMaybe<Scalars['ID']>;\n  paymasterIDNEQ?: InputMaybe<Scalars['ID']>;\n  paymasterIDNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  paymasterIDNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** updated_at field predicates */\n  updatedAt?: InputMaybe<Scalars['Time']>;\n  updatedAtGT?: InputMaybe<Scalars['Time']>;\n  updatedAtGTE?: InputMaybe<Scalars['Time']>;\n  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  updatedAtLT?: InputMaybe<Scalars['Time']>;\n  updatedAtLTE?: InputMaybe<Scalars['Time']>;\n  updatedAtNEQ?: InputMaybe<Scalars['Time']>;\n  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n};\n\nexport type Streak = {\n  __typename?: 'Streak';\n  currentStreak: Scalars['Int'];\n  maxStreak: Scalars['Int'];\n  playerAddress: Scalars['String'];\n};\n\nexport type StreakItem = {\n  __typename?: 'StreakItem';\n  meta: StreakMeta;\n  streaks: Array<Streak>;\n};\n\nexport type StreakMeta = {\n  __typename?: 'StreakMeta';\n  count: Scalars['Int'];\n  error?: Maybe<Scalars['String']>;\n  project: Scalars['String'];\n};\n\nexport type StreakProject = {\n  project: Scalars['String'];\n};\n\nexport type StreakResult = {\n  __typename?: 'StreakResult';\n  items: Array<StreakItem>;\n};\n\nexport type StripePayment = {\n  __typename?: 'StripePayment';\n  id: Scalars['ID'];\n  paymentStatus: StripePaymentStatus;\n};\n\nexport type StripePaymentIntent = {\n  __typename?: 'StripePaymentIntent';\n  clientSecret: Scalars['String'];\n  id: Scalars['ID'];\n  pricing: StripePricingDetails;\n};\n\nexport enum StripePaymentStatus {\n  Failed = 'FAILED',\n  Pending = 'PENDING',\n  Succeeded = 'SUCCEEDED'\n}\n\nexport type StripePricingDetails = {\n  __typename?: 'StripePricingDetails';\n  baseCostInCents: Scalars['Int'];\n  processingFeeInCents: Scalars['Int'];\n  totalInCents: Scalars['Int'];\n};\n\nexport type Team = Node & {\n  __typename?: 'Team';\n  address?: Maybe<Scalars['String']>;\n  /** Credits to use for slot billing. 1 credit = 0.01 USD. */\n  credits: Scalars['Int'];\n  /** Soft delete flag for legal and billing purposes. */\n  deleted: Scalars['Boolean'];\n  deployments: DeploymentConnection;\n  description?: Maybe<Scalars['String']>;\n  email?: Maybe<Scalars['String']>;\n  id: Scalars['ID'];\n  /** Incubator tier: kohai (tier 1), senpai (tier 2, $5k free), sensei (tier 3, $20k free), cartridge (internal teams, unlimited). */\n  incubatorStage?: Maybe<TeamIncubatorStage>;\n  invoices: InvoiceConnection;\n  members: AccountConnection;\n  membership: AccountTeamConnection;\n  name: Scalars['String'];\n  paymasters: PaymasterConnection;\n  rpcAPIKeys: RpcApiKeyConnection;\n  rpcCorsDomains: RpcCorsDomainConnection;\n  starterpacks: StarterpackConnection;\n  taxID?: Maybe<Scalars['String']>;\n  /** Total amount debited for incubator stage tracking. 1 credit = 0.01 USD. */\n  totalDebits: Scalars['Int'];\n};\n\n\nexport type TeamDeploymentsArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<DeploymentOrder>;\n  where?: InputMaybe<DeploymentWhereInput>;\n};\n\n\nexport type TeamInvoicesArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<InvoiceOrder>;\n  where?: InputMaybe<InvoiceWhereInput>;\n};\n\n\nexport type TeamMembersArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<AccountOrder>;\n  where?: InputMaybe<AccountWhereInput>;\n};\n\n\nexport type TeamMembershipArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<AccountTeamWhereInput>;\n};\n\n\nexport type TeamPaymastersArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<PaymasterOrder>;\n  where?: InputMaybe<PaymasterWhereInput>;\n};\n\n\nexport type TeamRpcApiKeysArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<RpcApiKeyWhereInput>;\n};\n\n\nexport type TeamRpcCorsDomainsArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<RpcCorsDomainWhereInput>;\n};\n\n\nexport type TeamStarterpacksArgs = {\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<StarterpackOrder>;\n  where?: InputMaybe<StarterpackWhereInput>;\n};\n\n/** A connection to a list of items. */\nexport type TeamConnection = {\n  __typename?: 'TeamConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<TeamEdge>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\nexport type TeamCreditsHistory = Node & {\n  __typename?: 'TeamCreditsHistory';\n  amount: Scalars['Int'];\n  /** Optional comment for transaction reason */\n  comment?: Maybe<Scalars['String']>;\n  createdAt: Scalars['Time'];\n  id: Scalars['ID'];\n  teamID: Scalars['String'];\n  /** Type of transaction: credit or debit */\n  transactionType: TeamCreditsHistoryTransactionType;\n  updatedAt: Scalars['Time'];\n};\n\n/** Ordering options for TeamCreditsHistory connections */\nexport type TeamCreditsHistoryOrder = {\n  /** The ordering direction. */\n  direction?: OrderDirection;\n  /** The field by which to order TeamCreditsHistories. */\n  field: TeamCreditsHistoryOrderField;\n};\n\n/** Properties by which TeamCreditsHistory connections can be ordered. */\nexport enum TeamCreditsHistoryOrderField {\n  CreatedAt = 'CREATED_AT'\n}\n\n/** TeamCreditsHistoryTransactionType is enum for the field transaction_type */\nexport enum TeamCreditsHistoryTransactionType {\n  Credit = 'credit',\n  Debit = 'debit'\n}\n\n/**\n * TeamCreditsHistoryWhereInput is used for filtering TeamCreditsHistory objects.\n * Input was generated by ent.\n */\nexport type TeamCreditsHistoryWhereInput = {\n  /** amount field predicates */\n  amount?: InputMaybe<Scalars['Int']>;\n  amountGT?: InputMaybe<Scalars['Int']>;\n  amountGTE?: InputMaybe<Scalars['Int']>;\n  amountIn?: InputMaybe<Array<Scalars['Int']>>;\n  amountLT?: InputMaybe<Scalars['Int']>;\n  amountLTE?: InputMaybe<Scalars['Int']>;\n  amountNEQ?: InputMaybe<Scalars['Int']>;\n  amountNotIn?: InputMaybe<Array<Scalars['Int']>>;\n  and?: InputMaybe<Array<TeamCreditsHistoryWhereInput>>;\n  /** comment field predicates */\n  comment?: InputMaybe<Scalars['String']>;\n  commentContains?: InputMaybe<Scalars['String']>;\n  commentContainsFold?: InputMaybe<Scalars['String']>;\n  commentEqualFold?: InputMaybe<Scalars['String']>;\n  commentGT?: InputMaybe<Scalars['String']>;\n  commentGTE?: InputMaybe<Scalars['String']>;\n  commentHasPrefix?: InputMaybe<Scalars['String']>;\n  commentHasSuffix?: InputMaybe<Scalars['String']>;\n  commentIn?: InputMaybe<Array<Scalars['String']>>;\n  commentIsNil?: InputMaybe<Scalars['Boolean']>;\n  commentLT?: InputMaybe<Scalars['String']>;\n  commentLTE?: InputMaybe<Scalars['String']>;\n  commentNEQ?: InputMaybe<Scalars['String']>;\n  commentNotIn?: InputMaybe<Array<Scalars['String']>>;\n  commentNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** created_at field predicates */\n  createdAt?: InputMaybe<Scalars['Time']>;\n  createdAtGT?: InputMaybe<Scalars['Time']>;\n  createdAtGTE?: InputMaybe<Scalars['Time']>;\n  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  createdAtLT?: InputMaybe<Scalars['Time']>;\n  createdAtLTE?: InputMaybe<Scalars['Time']>;\n  createdAtNEQ?: InputMaybe<Scalars['Time']>;\n  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n  /** id field predicates */\n  id?: InputMaybe<Scalars['ID']>;\n  idContainsFold?: InputMaybe<Scalars['ID']>;\n  idEqualFold?: InputMaybe<Scalars['ID']>;\n  idGT?: InputMaybe<Scalars['ID']>;\n  idGTE?: InputMaybe<Scalars['ID']>;\n  idIn?: InputMaybe<Array<Scalars['ID']>>;\n  idLT?: InputMaybe<Scalars['ID']>;\n  idLTE?: InputMaybe<Scalars['ID']>;\n  idNEQ?: InputMaybe<Scalars['ID']>;\n  idNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  not?: InputMaybe<TeamCreditsHistoryWhereInput>;\n  or?: InputMaybe<Array<TeamCreditsHistoryWhereInput>>;\n  /** team_id field predicates */\n  teamID?: InputMaybe<Scalars['String']>;\n  teamIDContains?: InputMaybe<Scalars['String']>;\n  teamIDContainsFold?: InputMaybe<Scalars['String']>;\n  teamIDEqualFold?: InputMaybe<Scalars['String']>;\n  teamIDGT?: InputMaybe<Scalars['String']>;\n  teamIDGTE?: InputMaybe<Scalars['String']>;\n  teamIDHasPrefix?: InputMaybe<Scalars['String']>;\n  teamIDHasSuffix?: InputMaybe<Scalars['String']>;\n  teamIDIn?: InputMaybe<Array<Scalars['String']>>;\n  teamIDLT?: InputMaybe<Scalars['String']>;\n  teamIDLTE?: InputMaybe<Scalars['String']>;\n  teamIDNEQ?: InputMaybe<Scalars['String']>;\n  teamIDNotIn?: InputMaybe<Array<Scalars['String']>>;\n  /** transaction_type field predicates */\n  transactionType?: InputMaybe<TeamCreditsHistoryTransactionType>;\n  transactionTypeIn?: InputMaybe<Array<TeamCreditsHistoryTransactionType>>;\n  transactionTypeNEQ?: InputMaybe<TeamCreditsHistoryTransactionType>;\n  transactionTypeNotIn?: InputMaybe<Array<TeamCreditsHistoryTransactionType>>;\n  /** updated_at field predicates */\n  updatedAt?: InputMaybe<Scalars['Time']>;\n  updatedAtGT?: InputMaybe<Scalars['Time']>;\n  updatedAtGTE?: InputMaybe<Scalars['Time']>;\n  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;\n  updatedAtLT?: InputMaybe<Scalars['Time']>;\n  updatedAtLTE?: InputMaybe<Scalars['Time']>;\n  updatedAtNEQ?: InputMaybe<Scalars['Time']>;\n  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;\n};\n\n/** An edge in a connection. */\nexport type TeamEdge = {\n  __typename?: 'TeamEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['Cursor'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Team>;\n};\n\n/** TeamIncubatorStage is enum for the field incubator_stage */\nexport enum TeamIncubatorStage {\n  Cartridge = 'cartridge',\n  Kohai = 'kohai',\n  Senpai = 'senpai',\n  Sensei = 'sensei'\n}\n\nexport type TeamInput = {\n  address?: InputMaybe<Scalars['String']>;\n  email?: InputMaybe<Scalars['String']>;\n  taxId?: InputMaybe<Scalars['String']>;\n};\n\n/**\n * TeamWhereInput is used for filtering Team objects.\n * Input was generated by ent.\n */\nexport type TeamWhereInput = {\n  /** address field predicates */\n  address?: InputMaybe<Scalars['String']>;\n  addressContains?: InputMaybe<Scalars['String']>;\n  addressContainsFold?: InputMaybe<Scalars['String']>;\n  addressEqualFold?: InputMaybe<Scalars['String']>;\n  addressGT?: InputMaybe<Scalars['String']>;\n  addressGTE?: InputMaybe<Scalars['String']>;\n  addressHasPrefix?: InputMaybe<Scalars['String']>;\n  addressHasSuffix?: InputMaybe<Scalars['String']>;\n  addressIn?: InputMaybe<Array<Scalars['String']>>;\n  addressIsNil?: InputMaybe<Scalars['Boolean']>;\n  addressLT?: InputMaybe<Scalars['String']>;\n  addressLTE?: InputMaybe<Scalars['String']>;\n  addressNEQ?: InputMaybe<Scalars['String']>;\n  addressNotIn?: InputMaybe<Array<Scalars['String']>>;\n  addressNotNil?: InputMaybe<Scalars['Boolean']>;\n  and?: InputMaybe<Array<TeamWhereInput>>;\n  /** credits field predicates */\n  credits?: InputMaybe<Scalars['Int']>;\n  creditsGT?: InputMaybe<Scalars['Int']>;\n  creditsGTE?: InputMaybe<Scalars['Int']>;\n  creditsIn?: InputMaybe<Array<Scalars['Int']>>;\n  creditsLT?: InputMaybe<Scalars['Int']>;\n  creditsLTE?: InputMaybe<Scalars['Int']>;\n  creditsNEQ?: InputMaybe<Scalars['Int']>;\n  creditsNotIn?: InputMaybe<Array<Scalars['Int']>>;\n  /** deleted field predicates */\n  deleted?: InputMaybe<Scalars['Boolean']>;\n  deletedNEQ?: InputMaybe<Scalars['Boolean']>;\n  /** description field predicates */\n  description?: InputMaybe<Scalars['String']>;\n  descriptionContains?: InputMaybe<Scalars['String']>;\n  descriptionContainsFold?: InputMaybe<Scalars['String']>;\n  descriptionEqualFold?: InputMaybe<Scalars['String']>;\n  descriptionGT?: InputMaybe<Scalars['String']>;\n  descriptionGTE?: InputMaybe<Scalars['String']>;\n  descriptionHasPrefix?: InputMaybe<Scalars['String']>;\n  descriptionHasSuffix?: InputMaybe<Scalars['String']>;\n  descriptionIn?: InputMaybe<Array<Scalars['String']>>;\n  descriptionIsNil?: InputMaybe<Scalars['Boolean']>;\n  descriptionLT?: InputMaybe<Scalars['String']>;\n  descriptionLTE?: InputMaybe<Scalars['String']>;\n  descriptionNEQ?: InputMaybe<Scalars['String']>;\n  descriptionNotIn?: InputMaybe<Array<Scalars['String']>>;\n  descriptionNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** email field predicates */\n  email?: InputMaybe<Scalars['String']>;\n  emailContains?: InputMaybe<Scalars['String']>;\n  emailContainsFold?: InputMaybe<Scalars['String']>;\n  emailEqualFold?: InputMaybe<Scalars['String']>;\n  emailGT?: InputMaybe<Scalars['String']>;\n  emailGTE?: InputMaybe<Scalars['String']>;\n  emailHasPrefix?: InputMaybe<Scalars['String']>;\n  emailHasSuffix?: InputMaybe<Scalars['String']>;\n  emailIn?: InputMaybe<Array<Scalars['String']>>;\n  emailIsNil?: InputMaybe<Scalars['Boolean']>;\n  emailLT?: InputMaybe<Scalars['String']>;\n  emailLTE?: InputMaybe<Scalars['String']>;\n  emailNEQ?: InputMaybe<Scalars['String']>;\n  emailNotIn?: InputMaybe<Array<Scalars['String']>>;\n  emailNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** deployments edge predicates */\n  hasDeployments?: InputMaybe<Scalars['Boolean']>;\n  hasDeploymentsWith?: InputMaybe<Array<DeploymentWhereInput>>;\n  /** invoices edge predicates */\n  hasInvoices?: InputMaybe<Scalars['Boolean']>;\n  hasInvoicesWith?: InputMaybe<Array<InvoiceWhereInput>>;\n  /** members edge predicates */\n  hasMembers?: InputMaybe<Scalars['Boolean']>;\n  hasMembersWith?: InputMaybe<Array<AccountWhereInput>>;\n  /** membership edge predicates */\n  hasMembership?: InputMaybe<Scalars['Boolean']>;\n  hasMembershipWith?: InputMaybe<Array<AccountTeamWhereInput>>;\n  /** paymasters edge predicates */\n  hasPaymasters?: InputMaybe<Scalars['Boolean']>;\n  hasPaymastersWith?: InputMaybe<Array<PaymasterWhereInput>>;\n  /** rpc_api_keys edge predicates */\n  hasRPCAPIKeys?: InputMaybe<Scalars['Boolean']>;\n  hasRPCAPIKeysWith?: InputMaybe<Array<RpcApiKeyWhereInput>>;\n  /** rpc_cors_domains edge predicates */\n  hasRPCCorsDomains?: InputMaybe<Scalars['Boolean']>;\n  hasRPCCorsDomainsWith?: InputMaybe<Array<RpcCorsDomainWhereInput>>;\n  /** starterpacks edge predicates */\n  hasStarterpacks?: InputMaybe<Scalars['Boolean']>;\n  hasStarterpacksWith?: InputMaybe<Array<StarterpackWhereInput>>;\n  /** id field predicates */\n  id?: InputMaybe<Scalars['ID']>;\n  idContainsFold?: InputMaybe<Scalars['ID']>;\n  idEqualFold?: InputMaybe<Scalars['ID']>;\n  idGT?: InputMaybe<Scalars['ID']>;\n  idGTE?: InputMaybe<Scalars['ID']>;\n  idIn?: InputMaybe<Array<Scalars['ID']>>;\n  idLT?: InputMaybe<Scalars['ID']>;\n  idLTE?: InputMaybe<Scalars['ID']>;\n  idNEQ?: InputMaybe<Scalars['ID']>;\n  idNotIn?: InputMaybe<Array<Scalars['ID']>>;\n  /** incubator_stage field predicates */\n  incubatorStage?: InputMaybe<TeamIncubatorStage>;\n  incubatorStageIn?: InputMaybe<Array<TeamIncubatorStage>>;\n  incubatorStageIsNil?: InputMaybe<Scalars['Boolean']>;\n  incubatorStageNEQ?: InputMaybe<TeamIncubatorStage>;\n  incubatorStageNotIn?: InputMaybe<Array<TeamIncubatorStage>>;\n  incubatorStageNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** name field predicates */\n  name?: InputMaybe<Scalars['String']>;\n  nameContains?: InputMaybe<Scalars['String']>;\n  nameContainsFold?: InputMaybe<Scalars['String']>;\n  nameEqualFold?: InputMaybe<Scalars['String']>;\n  nameGT?: InputMaybe<Scalars['String']>;\n  nameGTE?: InputMaybe<Scalars['String']>;\n  nameHasPrefix?: InputMaybe<Scalars['String']>;\n  nameHasSuffix?: InputMaybe<Scalars['String']>;\n  nameIn?: InputMaybe<Array<Scalars['String']>>;\n  nameLT?: InputMaybe<Scalars['String']>;\n  nameLTE?: InputMaybe<Scalars['String']>;\n  nameNEQ?: InputMaybe<Scalars['String']>;\n  nameNotIn?: InputMaybe<Array<Scalars['String']>>;\n  not?: InputMaybe<TeamWhereInput>;\n  or?: InputMaybe<Array<TeamWhereInput>>;\n  /** tax_id field predicates */\n  taxID?: InputMaybe<Scalars['String']>;\n  taxIDContains?: InputMaybe<Scalars['String']>;\n  taxIDContainsFold?: InputMaybe<Scalars['String']>;\n  taxIDEqualFold?: InputMaybe<Scalars['String']>;\n  taxIDGT?: InputMaybe<Scalars['String']>;\n  taxIDGTE?: InputMaybe<Scalars['String']>;\n  taxIDHasPrefix?: InputMaybe<Scalars['String']>;\n  taxIDHasSuffix?: InputMaybe<Scalars['String']>;\n  taxIDIn?: InputMaybe<Array<Scalars['String']>>;\n  taxIDIsNil?: InputMaybe<Scalars['Boolean']>;\n  taxIDLT?: InputMaybe<Scalars['String']>;\n  taxIDLTE?: InputMaybe<Scalars['String']>;\n  taxIDNEQ?: InputMaybe<Scalars['String']>;\n  taxIDNotIn?: InputMaybe<Array<Scalars['String']>>;\n  taxIDNotNil?: InputMaybe<Scalars['Boolean']>;\n  /** total_debits field predicates */\n  totalDebits?: InputMaybe<Scalars['Int']>;\n  totalDebitsGT?: InputMaybe<Scalars['Int']>;\n  totalDebitsGTE?: InputMaybe<Scalars['Int']>;\n  totalDebitsIn?: InputMaybe<Array<Scalars['Int']>>;\n  totalDebitsLT?: InputMaybe<Scalars['Int']>;\n  totalDebitsLTE?: InputMaybe<Scalars['Int']>;\n  totalDebitsNEQ?: InputMaybe<Scalars['Int']>;\n  totalDebitsNotIn?: InputMaybe<Array<Scalars['Int']>>;\n};\n\nexport enum TokenPair {\n  EthUsdc = 'ETH_USDC',\n  LordsUsdc = 'LORDS_USDC',\n  StrkUsdc = 'STRK_USDC'\n}\n\nexport type ToriiCreateInput = {\n  replicas?: InputMaybe<Scalars['Int']>;\n  replication?: InputMaybe<Scalars['Boolean']>;\n};\n\nexport type ToriiUpdateInput = {\n  replicas?: InputMaybe<Scalars['Int']>;\n};\n\nexport type Traceability = {\n  __typename?: 'Traceability';\n  amount: Scalars['String'];\n  contractAddress: Scalars['String'];\n  decimals: Scalars['Int'];\n  eventId: Scalars['String'];\n  executedAt: Scalars['String'];\n  fromAddress: Scalars['String'];\n  metadata: Scalars['String'];\n  name: Scalars['String'];\n  symbol: Scalars['String'];\n  toAddress: Scalars['String'];\n  tokenId: Scalars['String'];\n  transactionHash: Scalars['String'];\n};\n\nexport type TraceabilityItem = {\n  __typename?: 'TraceabilityItem';\n  meta: TraceabilityMeta;\n  transfers: Array<Traceability>;\n};\n\nexport type TraceabilityMeta = {\n  __typename?: 'TraceabilityMeta';\n  contractAddress: Scalars['String'];\n  count: Scalars['Int'];\n  date: Scalars['String'];\n  error?: Maybe<Scalars['String']>;\n  limit: Scalars['Int'];\n  project: Scalars['String'];\n  tokenId: Scalars['String'];\n};\n\nexport type TraceabilityProject = {\n  contractAddress: Scalars['String'];\n  date: Scalars['String'];\n  limit: Scalars['Int'];\n  project: Scalars['String'];\n  tokenId: Scalars['String'];\n};\n\nexport type TraceabilityResult = {\n  __typename?: 'TraceabilityResult';\n  items: Array<TraceabilityItem>;\n};\n\nexport type Transfer = {\n  __typename?: 'Transfer';\n  amount: Scalars['String'];\n  contractAddress: Scalars['String'];\n  decimals: Scalars['Int'];\n  eventId: Scalars['String'];\n  executedAt: Scalars['String'];\n  fromAddress: Scalars['String'];\n  metadata: Scalars['String'];\n  name: Scalars['String'];\n  symbol: Scalars['String'];\n  toAddress: Scalars['String'];\n  tokenId: Scalars['String'];\n  transactionHash: Scalars['String'];\n};\n\nexport type TransferInput = {\n  /** The amount to transfer. */\n  amount: Scalars['Int'];\n  /** The team name to transfer funds to. */\n  team: Scalars['String'];\n};\n\nexport type TransferItem = {\n  __typename?: 'TransferItem';\n  meta: TransferMeta;\n  transfers: Array<Transfer>;\n};\n\nexport type TransferMeta = {\n  __typename?: 'TransferMeta';\n  address: Scalars['String'];\n  count: Scalars['Int'];\n  date: Scalars['String'];\n  error?: Maybe<Scalars['String']>;\n  limit: Scalars['Int'];\n  project: Scalars['String'];\n};\n\nexport type TransferProject = {\n  address: Scalars['String'];\n  date: Scalars['String'];\n  limit: Scalars['Int'];\n  project: Scalars['String'];\n};\n\nexport type TransferResponse = {\n  __typename?: 'TransferResponse';\n  accountAfter: Scalars['Int'];\n  accountBefore: Scalars['Int'];\n  amount: Scalars['Int'];\n  teamAfter: Scalars['Int'];\n  teamBefore: Scalars['Int'];\n};\n\nexport type TransferResult = {\n  __typename?: 'TransferResult';\n  items: Array<TransferItem>;\n};\n\n/**\n * UpdateMerkleClaimInput is used for update MerkleClaim object.\n * Input was generated by ent.\n */\nexport type UpdateMerkleClaimInput = {\n  address?: InputMaybe<Scalars['String']>;\n  appendData?: InputMaybe<Array<Scalars['String']>>;\n  appendMerkleProof?: InputMaybe<Array<Scalars['String']>>;\n  claimed?: InputMaybe<Scalars['Boolean']>;\n  claimedAt?: InputMaybe<Scalars['Time']>;\n  clearClaimedAt?: InputMaybe<Scalars['Boolean']>;\n  clearMerkleProof?: InputMaybe<Scalars['Boolean']>;\n  createdAt?: InputMaybe<Scalars['Time']>;\n  data?: InputMaybe<Array<Scalars['String']>>;\n  /** Index of the claim in the merkle tree */\n  index?: InputMaybe<Scalars['Int']>;\n  merkleDropID?: InputMaybe<Scalars['ID']>;\n  merkleProof?: InputMaybe<Array<Scalars['String']>>;\n  updatedAt?: InputMaybe<Scalars['Time']>;\n};\n\n/**\n * UpdateMerkleDropInput is used for update MerkleDrop object.\n * Input was generated by ent.\n */\nexport type UpdateMerkleDropInput = {\n  addClaimIDs?: InputMaybe<Array<Scalars['ID']>>;\n  appendMetadata?: InputMaybe<Scalars['JSON']>;\n  clearClaims?: InputMaybe<Scalars['Boolean']>;\n  clearDescription?: InputMaybe<Scalars['Boolean']>;\n  clearMetadata?: InputMaybe<Scalars['Boolean']>;\n  clearStarterpack?: InputMaybe<Scalars['Boolean']>;\n  contract?: InputMaybe<Scalars['String']>;\n  createdAt?: InputMaybe<Scalars['Time']>;\n  description?: InputMaybe<Scalars['String']>;\n  entrypoint?: InputMaybe<Scalars['String']>;\n  key?: InputMaybe<Scalars['String']>;\n  matchStarterpackItem?: InputMaybe<Scalars['Boolean']>;\n  merkleRoot?: InputMaybe<Scalars['String']>;\n  /** Additional metadata for the merkle drop */\n  metadata?: InputMaybe<Scalars['JSON']>;\n  network?: InputMaybe<MerkleDropNetwork>;\n  removeClaimIDs?: InputMaybe<Array<Scalars['ID']>>;\n  salt?: InputMaybe<Scalars['String']>;\n  starterpackID?: InputMaybe<Scalars['ID']>;\n  updatedAt?: InputMaybe<Scalars['Time']>;\n};\n\nexport type UpdateServiceInput = {\n  config?: InputMaybe<Scalars['String']>;\n  torii?: InputMaybe<ToriiUpdateInput>;\n  type: DeploymentService;\n  version?: InputMaybe<Scalars['String']>;\n};\n\nexport type WebauthnCredential = {\n  __typename?: 'WebauthnCredential';\n  AAGUID: Scalars['String'];\n  id: Scalars['ID'];\n  publicKey: Scalars['String'];\n};\n\nexport type WebauthnCredentials = {\n  __typename?: 'WebauthnCredentials';\n  webauthn?: Maybe<Array<WebauthnCredential>>;\n};\n\nexport type AccountQueryVariables = Exact<{\n  username: Scalars['String'];\n}>;\n\n\nexport type AccountQuery = { __typename?: 'Query', account?: { __typename?: 'Account', username: string, credentials: { __typename?: 'Credentials', webauthn?: Array<{ __typename?: 'WebauthnCredential', id: string, publicKey: string }> | null }, controllers: { __typename?: 'ControllerConnection', edges?: Array<{ __typename?: 'ControllerEdge', node?: { __typename?: 'Controller', address: string, constructorCalldata: Array<string>, signers?: Array<{ __typename?: 'Signer', type: SignerType }> | null } | null } | null> | null } } | null };\n\nexport type CreditQueryVariables = Exact<{\n  username: Scalars['String'];\n}>;\n\n\nexport type CreditQuery = { __typename?: 'Query', account?: { __typename?: 'Account', credits: { __typename?: 'Credits', amount: string, decimals: number } } | null };\n\nexport type AccountNameQueryVariables = Exact<{\n  address: Scalars['String'];\n}>;\n\n\nexport type AccountNameQuery = { __typename?: 'Query', accounts?: { __typename?: 'AccountConnection', edges?: Array<{ __typename?: 'AccountEdge', node?: { __typename?: 'Account', username: string } | null } | null> | null } | null };\n\nexport type AccountNamesQueryVariables = Exact<{\n  addresses: Array<Scalars['String']> | Scalars['String'];\n}>;\n\n\nexport type AccountNamesQuery = { __typename?: 'Query', accounts?: { __typename?: 'AccountConnection', edges?: Array<{ __typename?: 'AccountEdge', node?: { __typename?: 'Account', username: string, controllers: { __typename?: 'ControllerConnection', edges?: Array<{ __typename?: 'ControllerEdge', node?: { __typename?: 'Controller', address: string } | null } | null> | null } } | null } | null> | null } | null };\n\nexport type AddressByUsernameQueryVariables = Exact<{\n  username: Scalars['String'];\n}>;\n\n\nexport type AddressByUsernameQuery = { __typename?: 'Query', account?: { __typename?: 'Account', controllers: { __typename?: 'ControllerConnection', edges?: Array<{ __typename?: 'ControllerEdge', node?: { __typename?: 'Controller', address: string } | null } | null> | null } } | null };\n\nexport type AccountSearchQueryVariables = Exact<{\n  query: Scalars['String'];\n  limit?: InputMaybe<Scalars['Int']>;\n}>;\n\n\nexport type AccountSearchQuery = { __typename?: 'Query', searchAccounts: Array<{ __typename?: 'Account', username: string, updatedAt: string, credits: { __typename?: 'Credits', amount: string, decimals: number } }> };\n\nexport type AchievementsQueryVariables = Exact<{\n  projects: Array<Project> | Project;\n}>;\n\n\nexport type AchievementsQuery = { __typename?: 'Query', achievements: { __typename?: 'AchievementResult', items: Array<{ __typename?: 'AchievementItem', meta: { __typename?: 'AchievementMeta', project: string, model: string, namespace: string, count: number }, achievements: Array<{ __typename?: 'Achievement', id: string, hidden: number, page: number, points: number, start: string, end: string, achievementGroup: string, icon: string, title: string, description: string, taskId: string, taskTotal: number, taskDescription: string, data?: string | null }> }> } };\n\nexport type ProgressionsQueryVariables = Exact<{\n  projects: Array<Project> | Project;\n}>;\n\n\nexport type ProgressionsQuery = { __typename?: 'Query', playerAchievements: { __typename?: 'PlayerAchievementResult', items: Array<{ __typename?: 'PlayerAchievementItem', meta: { __typename?: 'AchievementMeta', project: string, model: string, namespace: string, count: number }, achievements: Array<{ __typename?: 'PlayerAchievement', playerId: string, achievementId: string, points: number, taskId: string, taskTotal: number, total: number, completionTime: string }> }> } };\n\nexport type ActivitiesQueryVariables = Exact<{\n  projects: Array<ActivityProject> | ActivityProject;\n}>;\n\n\nexport type ActivitiesQuery = { __typename?: 'Query', activities: { __typename?: 'ActivityResult', items: Array<{ __typename?: 'ActivityItem', meta: { __typename?: 'ActivityMeta', project: string, address: string, limit: number, count: number }, activities: Array<{ __typename?: 'ActivityEntry', contractAddress: string, entrypoint: string, executedAt: string, callerAddress: string, transactionHash: string }> }> } };\n\nexport type BalancesQueryVariables = Exact<{\n  projects?: InputMaybe<Array<Scalars['String']> | Scalars['String']>;\n  accountAddress: Scalars['String'];\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  after?: InputMaybe<Scalars['Cursor']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n}>;\n\n\nexport type BalancesQuery = { __typename?: 'Query', balances: { __typename?: 'BalanceConnection', totalCount: number, edges: Array<{ __typename?: 'BalanceEdge', node: { __typename?: 'Balance', raw: string, amount: number, value: number, meta: { __typename?: 'ERC20Metadata', project: string, decimals: number, contractAddress: string, name: string, symbol: string, price: number, periodPrice: number } } }> } };\n\nexport type BalanceQueryVariables = Exact<{\n  projects: Array<Scalars['String']> | Scalars['String'];\n  tokenAddress: Scalars['String'];\n  accountAddress: Scalars['String'];\n}>;\n\n\nexport type BalanceQuery = { __typename?: 'Query', balance: { __typename?: 'Balance', raw: string, amount: number, value: number, meta: { __typename?: 'ERC20Metadata', project: string, decimals: number, contractAddress: string, name: string, symbol: string, price: number, periodPrice: number } } };\n\nexport type CollectiblesQueryVariables = Exact<{\n  projects?: InputMaybe<Array<Scalars['String']> | Scalars['String']>;\n  accountAddress: Scalars['String'];\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  after?: InputMaybe<Scalars['Cursor']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n}>;\n\n\nexport type CollectiblesQuery = { __typename?: 'Query', collectibles: { __typename?: 'CollectibleConnection', edges: Array<{ __typename?: 'CollectibleEdge', node: { __typename?: 'Collectible', assets: Array<{ __typename?: 'AssetEdge', attributes?: string | null, description?: string | null, imageUrl: string, name: string, tokenId: string, amount: number, metadata?: string | null }>, meta: { __typename?: 'ERC1155Metadata', project: string, assetCount: number, contractAddress: string, imagePath: string, name: string } } }> } };\n\nexport type CollectibleQueryVariables = Exact<{\n  projects: Array<Scalars['String']> | Scalars['String'];\n  contractAddress: Scalars['String'];\n  accountAddress: Scalars['String'];\n}>;\n\n\nexport type CollectibleQuery = { __typename?: 'Query', collectible: { __typename?: 'Collectible', assets: Array<{ __typename?: 'AssetEdge', attributes?: string | null, description?: string | null, imageUrl: string, name: string, tokenId: string, amount: number, metadata?: string | null }>, meta: { __typename?: 'ERC1155Metadata', assetCount: number, contractAddress: string, imagePath: string, name: string } } };\n\nexport type CollectionsQueryVariables = Exact<{\n  projects?: InputMaybe<Array<Scalars['String']> | Scalars['String']>;\n  accountAddress: Scalars['String'];\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  after?: InputMaybe<Scalars['Cursor']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n}>;\n\n\nexport type CollectionsQuery = { __typename?: 'Query', collections: { __typename?: 'CollectionConnection', edges: Array<{ __typename?: 'CollectionEdge', node: { __typename?: 'Collection', assets: Array<{ __typename?: 'AssetEdge', attributes?: string | null, description?: string | null, imageUrl: string, name: string, tokenId: string, metadata?: string | null }>, meta: { __typename?: 'ERC721Metadata', project: string, assetCount: number, contractAddress: string, imagePath: string, name: string } } }> } };\n\nexport type CollectionQueryVariables = Exact<{\n  projects: Array<Scalars['String']> | Scalars['String'];\n  contractAddress: Scalars['String'];\n  accountAddress: Scalars['String'];\n}>;\n\n\nexport type CollectionQuery = { __typename?: 'Query', collection: { __typename?: 'Collection', assets: Array<{ __typename?: 'AssetEdge', attributes?: string | null, description?: string | null, imageUrl: string, name: string, tokenId: string, metadata?: string | null }>, meta: { __typename?: 'ERC721Metadata', assetCount: number, contractAddress: string, imagePath: string, name: string } } };\n\nexport type ControllerQueryVariables = Exact<{\n  username: Scalars['String'];\n  chainId: Scalars['String'];\n}>;\n\n\nexport type ControllerQuery = { __typename?: 'Query', controller?: { __typename?: 'Controller', id: string, accountID: string, address: string, network: string, constructorCalldata: Array<string>, createdAt: string, updatedAt: string, signers?: Array<{ __typename?: 'Signer', createdAt: string, isRevoked: boolean, isOriginal: boolean, metadata: { __typename: 'Eip191Credentials', eip191?: Array<{ __typename?: 'Eip191Credential', provider: string, ethAddress: string }> | null } | { __typename: 'PasswordCredentials', password?: Array<{ __typename?: 'PasswordCredential', publicKey: string, encryptedPrivateKey: string }> | null } | { __typename: 'SIWSCredentials', siws?: Array<{ __typename?: 'SIWSCredential', publicKey: string }> | null } | { __typename: 'StarknetCredentials', starknet?: Array<{ __typename?: 'StarknetCredential', publicKey: string }> | null } | { __typename: 'WebauthnCredentials', webauthn?: Array<{ __typename?: 'WebauthnCredential', id: string, publicKey: string, AAGUID: string }> | null } }> | null } | null };\n\nexport type BeginRegistrationMutationVariables = Exact<{\n  username: Scalars['String'];\n}>;\n\n\nexport type BeginRegistrationMutation = { __typename?: 'Mutation', beginRegistration: any };\n\nexport type FinalizeRegistrationMutationVariables = Exact<{\n  credentials: Scalars['String'];\n  network: Scalars['String'];\n}>;\n\n\nexport type FinalizeRegistrationMutation = { __typename?: 'Mutation', finalizeRegistration: { __typename?: 'Account', username: string, controllers: { __typename?: 'ControllerConnection', edges?: Array<{ __typename?: 'ControllerEdge', node?: { __typename?: 'Controller', address: string, constructorCalldata: Array<string>, signers?: Array<{ __typename?: 'Signer', type: SignerType }> | null } | null } | null> | null }, credentials: { __typename?: 'Credentials', webauthn?: Array<{ __typename?: 'WebauthnCredential', id: string, publicKey: string }> | null } } };\n\nexport type BeginLoginMutationVariables = Exact<{\n  username: Scalars['String'];\n}>;\n\n\nexport type BeginLoginMutation = { __typename?: 'Mutation', beginLogin: any };\n\nexport type FinalizeLoginMutationVariables = Exact<{\n  credentials: Scalars['String'];\n}>;\n\n\nexport type FinalizeLoginMutation = { __typename?: 'Mutation', finalizeLogin: string };\n\nexport type MeQueryVariables = Exact<{ [key: string]: never; }>;\n\n\nexport type MeQuery = { __typename?: 'Query', me?: { __typename?: 'Account', id: string } | null };\n\nexport type MerkleDropByKeyQueryVariables = Exact<{\n  key: Scalars['String'];\n}>;\n\n\nexport type MerkleDropByKeyQuery = { __typename?: 'Query', merkleDropByKey?: { __typename?: 'MerkleDrop', key: string, salt: string, network: MerkleDropNetwork, contract: string, entrypoint: string, merkleRoot: string, description?: string | null, matchStarterpackItem: boolean } | null };\n\nexport type MerkleClaimsForAddressQueryVariables = Exact<{\n  keys: Array<Scalars['String']> | Scalars['String'];\n  address: Scalars['String'];\n}>;\n\n\nexport type MerkleClaimsForAddressQuery = { __typename?: 'Query', merkleClaimsForAddress: Array<{ __typename?: 'MerkleClaim', index: number, data: Array<string>, merkleProof?: Array<string> | null, merkleDrop: { __typename?: 'MerkleDrop', key: string, salt: string, network: MerkleDropNetwork, contract: string, entrypoint: string, merkleRoot: string, description?: string | null, matchStarterpackItem: boolean } }> };\n\nexport type MetricsQueryVariables = Exact<{\n  projects: Array<MetricsProject> | MetricsProject;\n}>;\n\n\nexport type MetricsQuery = { __typename?: 'Query', metrics: { __typename?: 'MetricsResult', items: Array<{ __typename?: 'MetricsItem', meta: { __typename?: 'MetricsMeta', project: string, error?: string | null, count: number }, metrics: Array<{ __typename?: 'MetricsEntry', transactionDate: string, transactionCount: number, callerCount: number }> }> } };\n\nexport type OwnershipsQueryVariables = Exact<{\n  projects: Array<OwnershipProject> | OwnershipProject;\n}>;\n\n\nexport type OwnershipsQuery = { __typename?: 'Query', ownerships: { __typename?: 'OwnershipResult', items: Array<{ __typename?: 'OwnershipItem', ownerships: Array<{ __typename?: 'Ownership', accountAddress: string, contractAddress: string, tokenId: string, balance: string }>, meta: { __typename?: 'OwnershipMeta', project: string, tokenIds: Array<string>, contractAddresses: Array<string>, limit: number, error?: string | null, count: number } }> } };\n\nexport type CryptoPaymentQueryVariables = Exact<{\n  id: Scalars['ID'];\n}>;\n\n\nexport type CryptoPaymentQuery = { __typename?: 'Query', cryptoPayment?: { __typename?: 'CryptoPayment', tokenAmount: string, status: CryptoPaymentStatus, network: Network, tokenAddress: string, depositAddress: string, expiresAt: string } | null };\n\nexport type StripePaymentQueryVariables = Exact<{\n  id: Scalars['ID'];\n}>;\n\n\nexport type StripePaymentQuery = { __typename?: 'Query', stripePayment: { __typename?: 'StripePayment', id: string, paymentStatus: StripePaymentStatus } };\n\nexport type LayerswapSourcesQueryVariables = Exact<{\n  token: Scalars['String'];\n  isMainnet?: InputMaybe<Scalars['Boolean']>;\n}>;\n\n\nexport type LayerswapSourcesQuery = { __typename?: 'Query', layerswapSources: Array<{ __typename?: 'LayerswapSource', name: string, displayName: string, logo: string, chainId: string, type: string, depositMethods: Array<string>, tokens: Array<{ __typename?: 'LayerswapSourceToken', symbol: string, displayAsset: string, decimals: number, priceInUsd: number, status: string }> }> };\n\nexport type CreateCryptoPaymentMutationVariables = Exact<{\n  input: CreateCryptoPaymentInput;\n}>;\n\n\nexport type CreateCryptoPaymentMutation = { __typename?: 'Mutation', createCryptoPayment: { __typename?: 'CryptoPayment', id: string, tokenAmount: string, status: CryptoPaymentStatus, network: Network, tokenAddress: string, depositAddress: string, expiresAt: string } };\n\nexport type CreateStripePaymentIntentMutationVariables = Exact<{\n  input: CreateStripePaymentIntentInput;\n}>;\n\n\nexport type CreateStripePaymentIntentMutation = { __typename?: 'Mutation', createStripePaymentIntent: { __typename?: 'StripePaymentIntent', id: string, clientSecret: string, pricing: { __typename?: 'StripePricingDetails', baseCostInCents: number, processingFeeInCents: number, totalInCents: number } } };\n\nexport type CreateLayerswapPaymentMutationVariables = Exact<{\n  input: CreateLayerswapPaymentInput;\n}>;\n\n\nexport type CreateLayerswapPaymentMutation = { __typename?: 'Mutation', createLayerswapPayment: { __typename?: 'LayerswapPayment', cryptoPaymentId: string, swapId: string, status: LayerswapStatus, sourceNetwork: LayerswapSourceNetwork, sourceTokenAmount: string, sourceTokenAddress: string, sourceDepositAddress: string, expiresAt: string } };\n\nexport type CreateLayerswapDepositMutationVariables = Exact<{\n  input: CreateLayerswapDepositInput;\n}>;\n\n\nexport type CreateLayerswapDepositMutation = { __typename?: 'Mutation', createLayerswapDeposit: { __typename?: 'LayerswapPayment', cryptoPaymentId: string, swapId: string, status: LayerswapStatus, sourceNetwork: LayerswapSourceNetwork, sourceTokenAmount: string, sourceTokenAddress: string, sourceDepositAddress: string, expiresAt: string } };\n\nexport type LayerswapQuoteQueryVariables = Exact<{\n  input: CreateLayerswapDepositInput;\n}>;\n\n\nexport type LayerswapQuoteQuery = { __typename?: 'Query', layerswapQuote: { __typename?: 'LayerswapQuote', requestedAmount: string, receivedAmount: string, totalFees: string, averageCompletionTime: string } };\n\nexport type LayerswapStatusQueryVariables = Exact<{\n  swapId: Scalars['ID'];\n  isMainnet?: InputMaybe<Scalars['Boolean']>;\n}>;\n\n\nexport type LayerswapStatusQuery = { __typename?: 'Query', layerswapStatus: LayerswapStatus };\n\nexport type CoinbaseOnrampRequirementsQueryVariables = Exact<{\n  username: Scalars['String'];\n}>;\n\n\nexport type CoinbaseOnrampRequirementsQuery = { __typename?: 'Query', coinbaseOnrampRequirements: { __typename?: 'CoinbaseOnrampRequirements', needsEmail: boolean, needsPhoneNumber: boolean, needsPhoneVerification: boolean } };\n\nexport type CreateCoinbaseOnRampOrderMutationVariables = Exact<{\n  input: CreateCoinbaseOnrampOrderInput;\n}>;\n\n\nexport type CreateCoinbaseOnRampOrderMutation = { __typename?: 'Mutation', createCoinbaseOnrampOrder: { __typename?: 'CoinbaseOnrampOrder', orderId: string, paymentLink: string, paymentLinkType: string, paymentSubtotal: string, paymentTotal: string, purchaseAmount: string, purchaseCurrency: string, status: CoinbaseOnrampStatus, fees: Array<{ __typename?: 'CoinbaseOnrampFee', type: string, amount: string, currency: string }> } };\n\nexport type PlaythroughsQueryVariables = Exact<{\n  projects: Array<PlaythroughProject> | PlaythroughProject;\n}>;\n\n\nexport type PlaythroughsQuery = { __typename?: 'Query', playthroughs: { __typename?: 'PlaythroughResult', items: Array<{ __typename?: 'PlaythroughItem', playthroughs: Array<{ __typename?: 'PlaythroughEntry', entrypoints: string, sessionStart: string, sessionEnd: string, actionCount: number, callerAddress: string }>, meta: { __typename?: 'PlaythroughMeta', project: string, limit: number, error?: string | null, count: number } }> } };\n\nexport type PriceQueryVariables = Exact<{\n  pairs: Array<TokenPair> | TokenPair;\n}>;\n\n\nexport type PriceQuery = { __typename?: 'Query', price: Array<{ __typename?: 'Price', amount: string, base: string, decimals: number, quote: string }> };\n\nexport type PriceByAddressesQueryVariables = Exact<{\n  addresses: Array<Scalars['String']> | Scalars['String'];\n}>;\n\n\nexport type PriceByAddressesQuery = { __typename?: 'Query', priceByAddresses: Array<{ __typename?: 'Price', amount: string, base: string, decimals: number, quote: string }> };\n\nexport type PricePeriodByAddressesQueryVariables = Exact<{\n  addresses: Array<Scalars['String']> | Scalars['String'];\n  start: Scalars['Int'];\n  end: Scalars['Int'];\n}>;\n\n\nexport type PricePeriodByAddressesQuery = { __typename?: 'Query', pricePeriodByAddresses: Array<{ __typename?: 'Price', amount: string, base: string, decimals: number, quote: string }> };\n\nexport type SessionsQueryVariables = Exact<{\n  where: SessionWhereInput;\n}>;\n\n\nexport type SessionsQuery = { __typename?: 'Query', sessions?: { __typename?: 'SessionConnection', edges?: Array<{ __typename?: 'SessionEdge', node?: { __typename?: 'Session', id: string, appID: string, chainID: string, isRevoked: boolean, expiresAt: string, createdAt: string, updatedAt: string, metadata?: { __typename?: 'SessionMetadata', os: string, browser: string } | null } | null } | null> | null } | null };\n\nexport type SignerQueryVariables = Exact<{\n  username: Scalars['String'];\n}>;\n\n\nexport type SignerQuery = { __typename?: 'Query', account?: { __typename?: 'Account', username: string, controllers: { __typename?: 'ControllerConnection', edges?: Array<{ __typename?: 'ControllerEdge', node?: { __typename?: 'Controller', signers?: Array<{ __typename?: 'Signer', id: string, type: SignerType, createdAt: string, updatedAt: string, controller: { __typename?: 'Controller', id: string, accountID: string } }> | null } | null } | null> | null } } | null };\n\nexport type ClaimFreeStarterpackMutationVariables = Exact<{\n  input: StarterpackInput;\n}>;\n\n\nexport type ClaimFreeStarterpackMutation = { __typename?: 'Mutation', claimFreeStarterpack: string };\n\nexport type StarterPackQueryVariables = Exact<{\n  input: StarterpackInput;\n}>;\n\n\nexport type StarterPackQuery = { __typename?: 'Query', starterpack?: { __typename?: 'StarterpackDetails', starterpack: { __typename?: 'Starterpack', name: string, description?: string | null, active: boolean, issuance: number, maxIssuance?: number | null, acquisitionType: StarterpackAcquisitionType, starterpackContract: { __typename?: 'StarterpackContractConnection', edges?: Array<{ __typename?: 'StarterpackContractEdge', node?: { __typename?: 'StarterpackContract', name: string, description?: string | null, iconURL?: string | null, contractAddress: string, supplyEntryPoint?: string | null, supplyCalldata?: Array<string> | null } | null } | null> | null }, merkleDrops: { __typename?: 'MerkleDropConnection', edges?: Array<{ __typename?: 'MerkleDropEdge', node?: { __typename?: 'MerkleDrop', key: string, salt: string, network: MerkleDropNetwork, contract: string, entrypoint: string, merkleRoot: string, description?: string | null } | null } | null> | null } }, price: { __typename?: 'Credits', amount: string, decimals: number }, bonusCredits: { __typename?: 'Credits', amount: string, decimals: number }, mintAllowance?: { __typename?: 'MintAllowance', count: number, limit: number } | null } | null };\n\nexport type TeamsQueryVariables = Exact<{ [key: string]: never; }>;\n\n\nexport type TeamsQuery = { __typename?: 'Query', me?: { __typename?: 'Account', teams: { __typename?: 'TeamConnection', totalCount: number, edges?: Array<{ __typename?: 'TeamEdge', node?: { __typename?: 'Team', id: string, name: string, credits: number, deployments: { __typename?: 'DeploymentConnection', totalCount: number, edges?: Array<{ __typename?: 'DeploymentEdge', node?: { __typename?: 'Deployment', project: string } | null } | null> | null } } | null } | null> | null } } | null };\n\nexport type TraceabilitiesQueryVariables = Exact<{\n  projects: Array<TraceabilityProject> | TraceabilityProject;\n}>;\n\n\nexport type TraceabilitiesQuery = { __typename?: 'Query', traceabilities: { __typename?: 'TraceabilityResult', items: Array<{ __typename?: 'TraceabilityItem', transfers: Array<{ __typename?: 'Traceability', amount: string, contractAddress: string, decimals: number, eventId: string, executedAt: string, fromAddress: string, toAddress: string, metadata: string, name: string, symbol: string, tokenId: string, transactionHash: string }>, meta: { __typename?: 'TraceabilityMeta', project: string, tokenId: string, contractAddress: string, date: string, limit: number, error?: string | null, count: number } }> } };\n\nexport type TransfersQueryVariables = Exact<{\n  projects: Array<TransferProject> | TransferProject;\n}>;\n\n\nexport type TransfersQuery = { __typename?: 'Query', transfers: { __typename?: 'TransferResult', items: Array<{ __typename?: 'TransferItem', meta: { __typename?: 'TransferMeta', project: string, address: string, date: string, limit: number, count: number }, transfers: Array<{ __typename?: 'Transfer', amount: string, decimals: number, metadata: string, name: string, symbol: string, contractAddress: string, executedAt: string, fromAddress: string, toAddress: string, tokenId: string, eventId: string, transactionHash: string }> }> } };\n\nexport type TxsHistoryQueryVariables = Exact<{\n  username: Scalars['String'];\n}>;\n\n\nexport type TxsHistoryQuery = { __typename?: 'Query', account?: { __typename?: 'Account', activities: { __typename?: 'ActivityConnection', edges?: Array<{ __typename?: 'ActivityEdge', node?: { __typename?: 'Activity', id: string, paymasterID?: string | null, type: ActivityType, status: ActivityStatus, network?: string | null, transactionHash?: string | null, feeSource: ActivityFeeSource, updatedAt: string } | null } | null> | null } } | null };\n\n\nexport const AccountDocument = `\n    query Account($username: String!) {\n  account(username: $username) {\n    username\n    credentials {\n      webauthn {\n        id\n        publicKey\n      }\n    }\n    controllers {\n      edges {\n        node {\n          address\n          constructorCalldata\n          signers {\n            type\n          }\n        }\n      }\n    }\n  }\n}\n    `;\nexport const useAccountQuery = <\n      TData = AccountQuery,\n      TError = unknown\n    >(\n      variables: AccountQueryVariables,\n      options?: UseQueryOptions<AccountQuery, TError, TData>\n    ) =>\n    useQuery<AccountQuery, TError, TData>(\n      ['Account', variables],\n      useFetchData<AccountQuery, AccountQueryVariables>(AccountDocument).bind(null, variables),\n      options\n    );\nexport const CreditDocument = `\n    query Credit($username: String!) {\n  account(username: $username) {\n    credits {\n      amount\n      decimals\n    }\n  }\n}\n    `;\nexport const useCreditQuery = <\n      TData = CreditQuery,\n      TError = unknown\n    >(\n      variables: CreditQueryVariables,\n      options?: UseQueryOptions<CreditQuery, TError, TData>\n    ) =>\n    useQuery<CreditQuery, TError, TData>(\n      ['Credit', variables],\n      useFetchData<CreditQuery, CreditQueryVariables>(CreditDocument).bind(null, variables),\n      options\n    );\nexport const AccountNameDocument = `\n    query AccountName($address: String!) {\n  accounts(where: {hasControllersWith: {address: $address}}, first: 1) {\n    edges {\n      node {\n        username\n      }\n    }\n  }\n}\n    `;\nexport const useAccountNameQuery = <\n      TData = AccountNameQuery,\n      TError = unknown\n    >(\n      variables: AccountNameQueryVariables,\n      options?: UseQueryOptions<AccountNameQuery, TError, TData>\n    ) =>\n    useQuery<AccountNameQuery, TError, TData>(\n      ['AccountName', variables],\n      useFetchData<AccountNameQuery, AccountNameQueryVariables>(AccountNameDocument).bind(null, variables),\n      options\n    );\nexport const AccountNamesDocument = `\n    query AccountNames($addresses: [String!]!) {\n  accounts(where: {hasControllersWith: {addressIn: $addresses}}) {\n    edges {\n      node {\n        username\n        controllers {\n          edges {\n            node {\n              address\n            }\n          }\n        }\n      }\n    }\n  }\n}\n    `;\nexport const useAccountNamesQuery = <\n      TData = AccountNamesQuery,\n      TError = unknown\n    >(\n      variables: AccountNamesQueryVariables,\n      options?: UseQueryOptions<AccountNamesQuery, TError, TData>\n    ) =>\n    useQuery<AccountNamesQuery, TError, TData>(\n      ['AccountNames', variables],\n      useFetchData<AccountNamesQuery, AccountNamesQueryVariables>(AccountNamesDocument).bind(null, variables),\n      options\n    );\nexport const AddressByUsernameDocument = `\n    query AddressByUsername($username: String!) {\n  account(username: $username) {\n    controllers(first: 1) {\n      edges {\n        node {\n          address\n        }\n      }\n    }\n  }\n}\n    `;\nexport const useAddressByUsernameQuery = <\n      TData = AddressByUsernameQuery,\n      TError = unknown\n    >(\n      variables: AddressByUsernameQueryVariables,\n      options?: UseQueryOptions<AddressByUsernameQuery, TError, TData>\n    ) =>\n    useQuery<AddressByUsernameQuery, TError, TData>(\n      ['AddressByUsername', variables],\n      useFetchData<AddressByUsernameQuery, AddressByUsernameQueryVariables>(AddressByUsernameDocument).bind(null, variables),\n      options\n    );\nexport const AccountSearchDocument = `\n    query AccountSearch($query: String!, $limit: Int = 5) {\n  searchAccounts(query: $query, limit: $limit) {\n    username\n    credits {\n      amount\n      decimals\n    }\n    updatedAt\n  }\n}\n    `;\nexport const useAccountSearchQuery = <\n      TData = AccountSearchQuery,\n      TError = unknown\n    >(\n      variables: AccountSearchQueryVariables,\n      options?: UseQueryOptions<AccountSearchQuery, TError, TData>\n    ) =>\n    useQuery<AccountSearchQuery, TError, TData>(\n      ['AccountSearch', variables],\n      useFetchData<AccountSearchQuery, AccountSearchQueryVariables>(AccountSearchDocument).bind(null, variables),\n      options\n    );\nexport const AchievementsDocument = `\n    query Achievements($projects: [Project!]!) {\n  achievements(projects: $projects) {\n    items {\n      meta {\n        project\n        model\n        namespace\n        count\n      }\n      achievements {\n        id\n        hidden\n        page\n        points\n        start\n        end\n        achievementGroup\n        icon\n        title\n        description\n        taskId\n        taskTotal\n        taskDescription\n        data\n      }\n    }\n  }\n}\n    `;\nexport const useAchievementsQuery = <\n      TData = AchievementsQuery,\n      TError = unknown\n    >(\n      variables: AchievementsQueryVariables,\n      options?: UseQueryOptions<AchievementsQuery, TError, TData>\n    ) =>\n    useQuery<AchievementsQuery, TError, TData>(\n      ['Achievements', variables],\n      useFetchData<AchievementsQuery, AchievementsQueryVariables>(AchievementsDocument).bind(null, variables),\n      options\n    );\nexport const ProgressionsDocument = `\n    query Progressions($projects: [Project!]!) {\n  playerAchievements(projects: $projects) {\n    items {\n      meta {\n        project\n        model\n        namespace\n        count\n      }\n      achievements {\n        playerId\n        achievementId\n        points\n        taskId\n        taskTotal\n        total\n        completionTime\n      }\n    }\n  }\n}\n    `;\nexport const useProgressionsQuery = <\n      TData = ProgressionsQuery,\n      TError = unknown\n    >(\n      variables: ProgressionsQueryVariables,\n      options?: UseQueryOptions<ProgressionsQuery, TError, TData>\n    ) =>\n    useQuery<ProgressionsQuery, TError, TData>(\n      ['Progressions', variables],\n      useFetchData<ProgressionsQuery, ProgressionsQueryVariables>(ProgressionsDocument).bind(null, variables),\n      options\n    );\nexport const ActivitiesDocument = `\n    query Activities($projects: [ActivityProject!]!) {\n  activities(projects: $projects) {\n    items {\n      meta {\n        project\n        address\n        limit\n        count\n      }\n      activities {\n        contractAddress\n        entrypoint\n        executedAt\n        callerAddress\n        transactionHash\n      }\n    }\n  }\n}\n    `;\nexport const useActivitiesQuery = <\n      TData = ActivitiesQuery,\n      TError = unknown\n    >(\n      variables: ActivitiesQueryVariables,\n      options?: UseQueryOptions<ActivitiesQuery, TError, TData>\n    ) =>\n    useQuery<ActivitiesQuery, TError, TData>(\n      ['Activities', variables],\n      useFetchData<ActivitiesQuery, ActivitiesQueryVariables>(ActivitiesDocument).bind(null, variables),\n      options\n    );\nexport const BalancesDocument = `\n    query Balances($projects: [String!], $accountAddress: String!, $first: Int, $last: Int, $before: Cursor, $after: Cursor, $offset: Int, $limit: Int) {\n  balances(\n    projects: $projects\n    accountAddress: $accountAddress\n    first: $first\n    last: $last\n    before: $before\n    after: $after\n    offset: $offset\n    limit: $limit\n  ) {\n    totalCount\n    edges {\n      node {\n        raw\n        amount\n        value\n        meta {\n          project\n          decimals\n          contractAddress\n          name\n          symbol\n          price\n          periodPrice\n        }\n      }\n    }\n  }\n}\n    `;\nexport const useBalancesQuery = <\n      TData = BalancesQuery,\n      TError = unknown\n    >(\n      variables: BalancesQueryVariables,\n      options?: UseQueryOptions<BalancesQuery, TError, TData>\n    ) =>\n    useQuery<BalancesQuery, TError, TData>(\n      ['Balances', variables],\n      useFetchData<BalancesQuery, BalancesQueryVariables>(BalancesDocument).bind(null, variables),\n      options\n    );\nexport const BalanceDocument = `\n    query Balance($projects: [String!]!, $tokenAddress: String!, $accountAddress: String!) {\n  balance(\n    projects: $projects\n    tokenAddress: $tokenAddress\n    accountAddress: $accountAddress\n  ) {\n    raw\n    amount\n    value\n    meta {\n      project\n      decimals\n      contractAddress\n      name\n      symbol\n      price\n      periodPrice\n    }\n  }\n}\n    `;\nexport const useBalanceQuery = <\n      TData = BalanceQuery,\n      TError = unknown\n    >(\n      variables: BalanceQueryVariables,\n      options?: UseQueryOptions<BalanceQuery, TError, TData>\n    ) =>\n    useQuery<BalanceQuery, TError, TData>(\n      ['Balance', variables],\n      useFetchData<BalanceQuery, BalanceQueryVariables>(BalanceDocument).bind(null, variables),\n      options\n    );\nexport const CollectiblesDocument = `\n    query Collectibles($projects: [String!], $accountAddress: String!, $first: Int, $last: Int, $before: Cursor, $after: Cursor, $offset: Int, $limit: Int) {\n  collectibles(\n    projects: $projects\n    accountAddress: $accountAddress\n    first: $first\n    last: $last\n    before: $before\n    after: $after\n    offset: $offset\n    limit: $limit\n  ) {\n    edges {\n      node {\n        assets {\n          attributes\n          description\n          imageUrl\n          name\n          tokenId\n          amount\n          metadata\n        }\n        meta {\n          project\n          assetCount\n          contractAddress\n          imagePath\n          name\n        }\n      }\n    }\n  }\n}\n    `;\nexport const useCollectiblesQuery = <\n      TData = CollectiblesQuery,\n      TError = unknown\n    >(\n      variables: CollectiblesQueryVariables,\n      options?: UseQueryOptions<CollectiblesQuery, TError, TData>\n    ) =>\n    useQuery<CollectiblesQuery, TError, TData>(\n      ['Collectibles', variables],\n      useFetchData<CollectiblesQuery, CollectiblesQueryVariables>(CollectiblesDocument).bind(null, variables),\n      options\n    );\nexport const CollectibleDocument = `\n    query Collectible($projects: [String!]!, $contractAddress: String!, $accountAddress: String!) {\n  collectible(\n    projects: $projects\n    contractAddress: $contractAddress\n    accountAddress: $accountAddress\n  ) {\n    assets {\n      attributes\n      description\n      imageUrl\n      name\n      tokenId\n      amount\n      metadata\n    }\n    meta {\n      assetCount\n      contractAddress\n      imagePath\n      name\n    }\n  }\n}\n    `;\nexport const useCollectibleQuery = <\n      TData = CollectibleQuery,\n      TError = unknown\n    >(\n      variables: CollectibleQueryVariables,\n      options?: UseQueryOptions<CollectibleQuery, TError, TData>\n    ) =>\n    useQuery<CollectibleQuery, TError, TData>(\n      ['Collectible', variables],\n      useFetchData<CollectibleQuery, CollectibleQueryVariables>(CollectibleDocument).bind(null, variables),\n      options\n    );\nexport const CollectionsDocument = `\n    query Collections($projects: [String!], $accountAddress: String!, $first: Int, $last: Int, $before: Cursor, $after: Cursor, $offset: Int, $limit: Int) {\n  collections(\n    projects: $projects\n    accountAddress: $accountAddress\n    first: $first\n    last: $last\n    before: $before\n    after: $after\n    offset: $offset\n    limit: $limit\n  ) {\n    edges {\n      node {\n        assets {\n          attributes\n          description\n          imageUrl\n          name\n          tokenId\n          metadata\n        }\n        meta {\n          project\n          assetCount\n          contractAddress\n          imagePath\n          name\n        }\n      }\n    }\n  }\n}\n    `;\nexport const useCollectionsQuery = <\n      TData = CollectionsQuery,\n      TError = unknown\n    >(\n      variables: CollectionsQueryVariables,\n      options?: UseQueryOptions<CollectionsQuery, TError, TData>\n    ) =>\n    useQuery<CollectionsQuery, TError, TData>(\n      ['Collections', variables],\n      useFetchData<CollectionsQuery, CollectionsQueryVariables>(CollectionsDocument).bind(null, variables),\n      options\n    );\nexport const CollectionDocument = `\n    query Collection($projects: [String!]!, $contractAddress: String!, $accountAddress: String!) {\n  collection(\n    projects: $projects\n    contractAddress: $contractAddress\n    accountAddress: $accountAddress\n  ) {\n    assets {\n      attributes\n      description\n      imageUrl\n      name\n      tokenId\n      metadata\n    }\n    meta {\n      assetCount\n      contractAddress\n      imagePath\n      name\n    }\n  }\n}\n    `;\nexport const useCollectionQuery = <\n      TData = CollectionQuery,\n      TError = unknown\n    >(\n      variables: CollectionQueryVariables,\n      options?: UseQueryOptions<CollectionQuery, TError, TData>\n    ) =>\n    useQuery<CollectionQuery, TError, TData>(\n      ['Collection', variables],\n      useFetchData<CollectionQuery, CollectionQueryVariables>(CollectionDocument).bind(null, variables),\n      options\n    );\nexport const ControllerDocument = `\n    query Controller($username: String!, $chainId: String!) {\n  controller(username: $username, chainId: $chainId) {\n    id\n    accountID\n    address\n    network\n    constructorCalldata\n    createdAt\n    updatedAt\n    signers {\n      createdAt\n      isRevoked\n      isOriginal\n      metadata {\n        ... on WebauthnCredentials {\n          __typename\n          webauthn {\n            id\n            publicKey\n            AAGUID\n          }\n        }\n        ... on StarknetCredentials {\n          __typename\n          starknet {\n            publicKey\n          }\n        }\n        ... on Eip191Credentials {\n          __typename\n          eip191 {\n            provider\n            ethAddress\n          }\n        }\n        ... on SIWSCredentials {\n          __typename\n          siws {\n            publicKey\n          }\n        }\n        ... on PasswordCredentials {\n          __typename\n          password {\n            publicKey\n            encryptedPrivateKey\n          }\n        }\n      }\n    }\n  }\n}\n    `;\nexport const useControllerQuery = <\n      TData = ControllerQuery,\n      TError = unknown\n    >(\n      variables: ControllerQueryVariables,\n      options?: UseQueryOptions<ControllerQuery, TError, TData>\n    ) =>\n    useQuery<ControllerQuery, TError, TData>(\n      ['Controller', variables],\n      useFetchData<ControllerQuery, ControllerQueryVariables>(ControllerDocument).bind(null, variables),\n      options\n    );\nexport const BeginRegistrationDocument = `\n    mutation BeginRegistration($username: String!) {\n  beginRegistration(username: $username)\n}\n    `;\nexport const useBeginRegistrationMutation = <\n      TError = unknown,\n      TContext = unknown\n    >(options?: UseMutationOptions<BeginRegistrationMutation, TError, BeginRegistrationMutationVariables, TContext>) =>\n    useMutation<BeginRegistrationMutation, TError, BeginRegistrationMutationVariables, TContext>(\n      ['BeginRegistration'],\n      useFetchData<BeginRegistrationMutation, BeginRegistrationMutationVariables>(BeginRegistrationDocument),\n      options\n    );\nexport const FinalizeRegistrationDocument = `\n    mutation FinalizeRegistration($credentials: String!, $network: String!) {\n  finalizeRegistration(credentials: $credentials, network: $network) {\n    username\n    controllers {\n      edges {\n        node {\n          address\n          constructorCalldata\n          signers {\n            type\n          }\n        }\n      }\n    }\n    credentials {\n      webauthn {\n        id\n        publicKey\n      }\n    }\n  }\n}\n    `;\nexport const useFinalizeRegistrationMutation = <\n      TError = unknown,\n      TContext = unknown\n    >(options?: UseMutationOptions<FinalizeRegistrationMutation, TError, FinalizeRegistrationMutationVariables, TContext>) =>\n    useMutation<FinalizeRegistrationMutation, TError, FinalizeRegistrationMutationVariables, TContext>(\n      ['FinalizeRegistration'],\n      useFetchData<FinalizeRegistrationMutation, FinalizeRegistrationMutationVariables>(FinalizeRegistrationDocument),\n      options\n    );\nexport const BeginLoginDocument = `\n    mutation BeginLogin($username: String!) {\n  beginLogin(username: $username)\n}\n    `;\nexport const useBeginLoginMutation = <\n      TError = unknown,\n      TContext = unknown\n    >(options?: UseMutationOptions<BeginLoginMutation, TError, BeginLoginMutationVariables, TContext>) =>\n    useMutation<BeginLoginMutation, TError, BeginLoginMutationVariables, TContext>(\n      ['BeginLogin'],\n      useFetchData<BeginLoginMutation, BeginLoginMutationVariables>(BeginLoginDocument),\n      options\n    );\nexport const FinalizeLoginDocument = `\n    mutation FinalizeLogin($credentials: String!) {\n  finalizeLogin(credentials: $credentials)\n}\n    `;\nexport const useFinalizeLoginMutation = <\n      TError = unknown,\n      TContext = unknown\n    >(options?: UseMutationOptions<FinalizeLoginMutation, TError, FinalizeLoginMutationVariables, TContext>) =>\n    useMutation<FinalizeLoginMutation, TError, FinalizeLoginMutationVariables, TContext>(\n      ['FinalizeLogin'],\n      useFetchData<FinalizeLoginMutation, FinalizeLoginMutationVariables>(FinalizeLoginDocument),\n      options\n    );\nexport const MeDocument = `\n    query Me {\n  me {\n    id\n  }\n}\n    `;\nexport const useMeQuery = <\n      TData = MeQuery,\n      TError = unknown\n    >(\n      variables?: MeQueryVariables,\n      options?: UseQueryOptions<MeQuery, TError, TData>\n    ) =>\n    useQuery<MeQuery, TError, TData>(\n      variables === undefined ? ['Me'] : ['Me', variables],\n      useFetchData<MeQuery, MeQueryVariables>(MeDocument).bind(null, variables),\n      options\n    );\nexport const MerkleDropByKeyDocument = `\n    query MerkleDropByKey($key: String!) {\n  merkleDropByKey(key: $key) {\n    key\n    salt\n    network\n    contract\n    entrypoint\n    merkleRoot\n    description\n    matchStarterpackItem\n  }\n}\n    `;\nexport const useMerkleDropByKeyQuery = <\n      TData = MerkleDropByKeyQuery,\n      TError = unknown\n    >(\n      variables: MerkleDropByKeyQueryVariables,\n      options?: UseQueryOptions<MerkleDropByKeyQuery, TError, TData>\n    ) =>\n    useQuery<MerkleDropByKeyQuery, TError, TData>(\n      ['MerkleDropByKey', variables],\n      useFetchData<MerkleDropByKeyQuery, MerkleDropByKeyQueryVariables>(MerkleDropByKeyDocument).bind(null, variables),\n      options\n    );\nexport const MerkleClaimsForAddressDocument = `\n    query MerkleClaimsForAddress($keys: [String!]!, $address: String!) {\n  merkleClaimsForAddress(keys: $keys, address: $address) {\n    index\n    data\n    merkleProof\n    merkleDrop {\n      key\n      salt\n      network\n      contract\n      entrypoint\n      merkleRoot\n      description\n      matchStarterpackItem\n    }\n  }\n}\n    `;\nexport const useMerkleClaimsForAddressQuery = <\n      TData = MerkleClaimsForAddressQuery,\n      TError = unknown\n    >(\n      variables: MerkleClaimsForAddressQueryVariables,\n      options?: UseQueryOptions<MerkleClaimsForAddressQuery, TError, TData>\n    ) =>\n    useQuery<MerkleClaimsForAddressQuery, TError, TData>(\n      ['MerkleClaimsForAddress', variables],\n      useFetchData<MerkleClaimsForAddressQuery, MerkleClaimsForAddressQueryVariables>(MerkleClaimsForAddressDocument).bind(null, variables),\n      options\n    );\nexport const MetricsDocument = `\n    query Metrics($projects: [MetricsProject!]!) {\n  metrics(projects: $projects) {\n    items {\n      meta {\n        project\n        error\n        count\n      }\n      metrics {\n        transactionDate\n        transactionCount\n        callerCount\n      }\n    }\n  }\n}\n    `;\nexport const useMetricsQuery = <\n      TData = MetricsQuery,\n      TError = unknown\n    >(\n      variables: MetricsQueryVariables,\n      options?: UseQueryOptions<MetricsQuery, TError, TData>\n    ) =>\n    useQuery<MetricsQuery, TError, TData>(\n      ['Metrics', variables],\n      useFetchData<MetricsQuery, MetricsQueryVariables>(MetricsDocument).bind(null, variables),\n      options\n    );\nexport const OwnershipsDocument = `\n    query Ownerships($projects: [OwnershipProject!]!) {\n  ownerships(projects: $projects) {\n    items {\n      ownerships {\n        accountAddress\n        contractAddress\n        tokenId\n        balance\n      }\n      meta {\n        project\n        tokenIds\n        contractAddresses\n        limit\n        error\n        count\n      }\n    }\n  }\n}\n    `;\nexport const useOwnershipsQuery = <\n      TData = OwnershipsQuery,\n      TError = unknown\n    >(\n      variables: OwnershipsQueryVariables,\n      options?: UseQueryOptions<OwnershipsQuery, TError, TData>\n    ) =>\n    useQuery<OwnershipsQuery, TError, TData>(\n      ['Ownerships', variables],\n      useFetchData<OwnershipsQuery, OwnershipsQueryVariables>(OwnershipsDocument).bind(null, variables),\n      options\n    );\nexport const CryptoPaymentDocument = `\n    query CryptoPayment($id: ID!) {\n  cryptoPayment(id: $id) {\n    tokenAmount\n    status\n    network\n    tokenAddress\n    depositAddress\n    expiresAt\n  }\n}\n    `;\nexport const useCryptoPaymentQuery = <\n      TData = CryptoPaymentQuery,\n      TError = unknown\n    >(\n      variables: CryptoPaymentQueryVariables,\n      options?: UseQueryOptions<CryptoPaymentQuery, TError, TData>\n    ) =>\n    useQuery<CryptoPaymentQuery, TError, TData>(\n      ['CryptoPayment', variables],\n      useFetchData<CryptoPaymentQuery, CryptoPaymentQueryVariables>(CryptoPaymentDocument).bind(null, variables),\n      options\n    );\nexport const StripePaymentDocument = `\n    query StripePayment($id: ID!) {\n  stripePayment(id: $id) {\n    id\n    paymentStatus\n  }\n}\n    `;\nexport const useStripePaymentQuery = <\n      TData = StripePaymentQuery,\n      TError = unknown\n    >(\n      variables: StripePaymentQueryVariables,\n      options?: UseQueryOptions<StripePaymentQuery, TError, TData>\n    ) =>\n    useQuery<StripePaymentQuery, TError, TData>(\n      ['StripePayment', variables],\n      useFetchData<StripePaymentQuery, StripePaymentQueryVariables>(StripePaymentDocument).bind(null, variables),\n      options\n    );\nexport const LayerswapSourcesDocument = `\n    query LayerswapSources($token: String!, $isMainnet: Boolean) {\n  layerswapSources(token: $token, isMainnet: $isMainnet) {\n    name\n    displayName\n    logo\n    chainId\n    type\n    tokens {\n      symbol\n      displayAsset\n      decimals\n      priceInUsd\n      status\n    }\n    depositMethods\n  }\n}\n    `;\nexport const useLayerswapSourcesQuery = <\n      TData = LayerswapSourcesQuery,\n      TError = unknown\n    >(\n      variables: LayerswapSourcesQueryVariables,\n      options?: UseQueryOptions<LayerswapSourcesQuery, TError, TData>\n    ) =>\n    useQuery<LayerswapSourcesQuery, TError, TData>(\n      ['LayerswapSources', variables],\n      useFetchData<LayerswapSourcesQuery, LayerswapSourcesQueryVariables>(LayerswapSourcesDocument).bind(null, variables),\n      options\n    );\nexport const CreateCryptoPaymentDocument = `\n    mutation CreateCryptoPayment($input: CreateCryptoPaymentInput!) {\n  createCryptoPayment(input: $input) {\n    id\n    tokenAmount\n    status\n    network\n    tokenAddress\n    depositAddress\n    expiresAt\n  }\n}\n    `;\nexport const useCreateCryptoPaymentMutation = <\n      TError = unknown,\n      TContext = unknown\n    >(options?: UseMutationOptions<CreateCryptoPaymentMutation, TError, CreateCryptoPaymentMutationVariables, TContext>) =>\n    useMutation<CreateCryptoPaymentMutation, TError, CreateCryptoPaymentMutationVariables, TContext>(\n      ['CreateCryptoPayment'],\n      useFetchData<CreateCryptoPaymentMutation, CreateCryptoPaymentMutationVariables>(CreateCryptoPaymentDocument),\n      options\n    );\nexport const CreateStripePaymentIntentDocument = `\n    mutation CreateStripePaymentIntent($input: CreateStripePaymentIntentInput!) {\n  createStripePaymentIntent(input: $input) {\n    id\n    clientSecret\n    pricing {\n      baseCostInCents\n      processingFeeInCents\n      totalInCents\n    }\n  }\n}\n    `;\nexport const useCreateStripePaymentIntentMutation = <\n      TError = unknown,\n      TContext = unknown\n    >(options?: UseMutationOptions<CreateStripePaymentIntentMutation, TError, CreateStripePaymentIntentMutationVariables, TContext>) =>\n    useMutation<CreateStripePaymentIntentMutation, TError, CreateStripePaymentIntentMutationVariables, TContext>(\n      ['CreateStripePaymentIntent'],\n      useFetchData<CreateStripePaymentIntentMutation, CreateStripePaymentIntentMutationVariables>(CreateStripePaymentIntentDocument),\n      options\n    );\nexport const CreateLayerswapPaymentDocument = `\n    mutation CreateLayerswapPayment($input: CreateLayerswapPaymentInput!) {\n  createLayerswapPayment(input: $input) {\n    cryptoPaymentId\n    swapId\n    status\n    sourceNetwork\n    sourceTokenAmount\n    sourceTokenAddress\n    sourceDepositAddress\n    expiresAt\n  }\n}\n    `;\nexport const useCreateLayerswapPaymentMutation = <\n      TError = unknown,\n      TContext = unknown\n    >(options?: UseMutationOptions<CreateLayerswapPaymentMutation, TError, CreateLayerswapPaymentMutationVariables, TContext>) =>\n    useMutation<CreateLayerswapPaymentMutation, TError, CreateLayerswapPaymentMutationVariables, TContext>(\n      ['CreateLayerswapPayment'],\n      useFetchData<CreateLayerswapPaymentMutation, CreateLayerswapPaymentMutationVariables>(CreateLayerswapPaymentDocument),\n      options\n    );\nexport const CreateLayerswapDepositDocument = `\n    mutation CreateLayerswapDeposit($input: CreateLayerswapDepositInput!) {\n  createLayerswapDeposit(input: $input) {\n    cryptoPaymentId\n    swapId\n    status\n    sourceNetwork\n    sourceTokenAmount\n    sourceTokenAddress\n    sourceDepositAddress\n    expiresAt\n  }\n}\n    `;\nexport const useCreateLayerswapDepositMutation = <\n      TError = unknown,\n      TContext = unknown\n    >(options?: UseMutationOptions<CreateLayerswapDepositMutation, TError, CreateLayerswapDepositMutationVariables, TContext>) =>\n    useMutation<CreateLayerswapDepositMutation, TError, CreateLayerswapDepositMutationVariables, TContext>(\n      ['CreateLayerswapDeposit'],\n      useFetchData<CreateLayerswapDepositMutation, CreateLayerswapDepositMutationVariables>(CreateLayerswapDepositDocument),\n      options\n    );\nexport const LayerswapQuoteDocument = `\n    query LayerswapQuote($input: CreateLayerswapDepositInput!) {\n  layerswapQuote(input: $input) {\n    requestedAmount\n    receivedAmount\n    totalFees\n    averageCompletionTime\n  }\n}\n    `;\nexport const useLayerswapQuoteQuery = <\n      TData = LayerswapQuoteQuery,\n      TError = unknown\n    >(\n      variables: LayerswapQuoteQueryVariables,\n      options?: UseQueryOptions<LayerswapQuoteQuery, TError, TData>\n    ) =>\n    useQuery<LayerswapQuoteQuery, TError, TData>(\n      ['LayerswapQuote', variables],\n      useFetchData<LayerswapQuoteQuery, LayerswapQuoteQueryVariables>(LayerswapQuoteDocument).bind(null, variables),\n      options\n    );\nexport const LayerswapStatusDocument = `\n    query LayerswapStatus($swapId: ID!, $isMainnet: Boolean) {\n  layerswapStatus(swapId: $swapId, isMainnet: $isMainnet)\n}\n    `;\nexport const useLayerswapStatusQuery = <\n      TData = LayerswapStatusQuery,\n      TError = unknown\n    >(\n      variables: LayerswapStatusQueryVariables,\n      options?: UseQueryOptions<LayerswapStatusQuery, TError, TData>\n    ) =>\n    useQuery<LayerswapStatusQuery, TError, TData>(\n      ['LayerswapStatus', variables],\n      useFetchData<LayerswapStatusQuery, LayerswapStatusQueryVariables>(LayerswapStatusDocument).bind(null, variables),\n      options\n    );\nexport const CoinbaseOnrampRequirementsDocument = `\n    query CoinbaseOnrampRequirements($username: String!) {\n  coinbaseOnrampRequirements(username: $username) {\n    needsEmail\n    needsPhoneNumber\n    needsPhoneVerification\n  }\n}\n    `;\nexport const useCoinbaseOnrampRequirementsQuery = <\n      TData = CoinbaseOnrampRequirementsQuery,\n      TError = unknown\n    >(\n      variables: CoinbaseOnrampRequirementsQueryVariables,\n      options?: UseQueryOptions<CoinbaseOnrampRequirementsQuery, TError, TData>\n    ) =>\n    useQuery<CoinbaseOnrampRequirementsQuery, TError, TData>(\n      ['CoinbaseOnrampRequirements', variables],\n      useFetchData<CoinbaseOnrampRequirementsQuery, CoinbaseOnrampRequirementsQueryVariables>(CoinbaseOnrampRequirementsDocument).bind(null, variables),\n      options\n    );\nexport const CreateCoinbaseOnRampOrderDocument = `\n    mutation CreateCoinbaseOnRampOrder($input: CreateCoinbaseOnrampOrderInput!) {\n  createCoinbaseOnrampOrder(input: $input) {\n    orderId\n    paymentLink\n    paymentLinkType\n    paymentSubtotal\n    paymentTotal\n    purchaseAmount\n    purchaseCurrency\n    status\n    fees {\n      type\n      amount\n      currency\n    }\n  }\n}\n    `;\nexport const useCreateCoinbaseOnRampOrderMutation = <\n      TError = unknown,\n      TContext = unknown\n    >(options?: UseMutationOptions<CreateCoinbaseOnRampOrderMutation, TError, CreateCoinbaseOnRampOrderMutationVariables, TContext>) =>\n    useMutation<CreateCoinbaseOnRampOrderMutation, TError, CreateCoinbaseOnRampOrderMutationVariables, TContext>(\n      ['CreateCoinbaseOnRampOrder'],\n      useFetchData<CreateCoinbaseOnRampOrderMutation, CreateCoinbaseOnRampOrderMutationVariables>(CreateCoinbaseOnRampOrderDocument),\n      options\n    );\nexport const PlaythroughsDocument = `\n    query Playthroughs($projects: [PlaythroughProject!]!) {\n  playthroughs(projects: $projects) {\n    items {\n      playthroughs {\n        entrypoints\n        sessionStart\n        sessionEnd\n        actionCount\n        callerAddress\n      }\n      meta {\n        project\n        limit\n        error\n        count\n      }\n    }\n  }\n}\n    `;\nexport const usePlaythroughsQuery = <\n      TData = PlaythroughsQuery,\n      TError = unknown\n    >(\n      variables: PlaythroughsQueryVariables,\n      options?: UseQueryOptions<PlaythroughsQuery, TError, TData>\n    ) =>\n    useQuery<PlaythroughsQuery, TError, TData>(\n      ['Playthroughs', variables],\n      useFetchData<PlaythroughsQuery, PlaythroughsQueryVariables>(PlaythroughsDocument).bind(null, variables),\n      options\n    );\nexport const PriceDocument = `\n    query Price($pairs: [TokenPair!]!) {\n  price(pairs: $pairs) {\n    amount\n    base\n    decimals\n    quote\n  }\n}\n    `;\nexport const usePriceQuery = <\n      TData = PriceQuery,\n      TError = unknown\n    >(\n      variables: PriceQueryVariables,\n      options?: UseQueryOptions<PriceQuery, TError, TData>\n    ) =>\n    useQuery<PriceQuery, TError, TData>(\n      ['Price', variables],\n      useFetchData<PriceQuery, PriceQueryVariables>(PriceDocument).bind(null, variables),\n      options\n    );\nexport const PriceByAddressesDocument = `\n    query PriceByAddresses($addresses: [String!]!) {\n  priceByAddresses(addresses: $addresses) {\n    amount\n    base\n    decimals\n    quote\n  }\n}\n    `;\nexport const usePriceByAddressesQuery = <\n      TData = PriceByAddressesQuery,\n      TError = unknown\n    >(\n      variables: PriceByAddressesQueryVariables,\n      options?: UseQueryOptions<PriceByAddressesQuery, TError, TData>\n    ) =>\n    useQuery<PriceByAddressesQuery, TError, TData>(\n      ['PriceByAddresses', variables],\n      useFetchData<PriceByAddressesQuery, PriceByAddressesQueryVariables>(PriceByAddressesDocument).bind(null, variables),\n      options\n    );\nexport const PricePeriodByAddressesDocument = `\n    query PricePeriodByAddresses($addresses: [String!]!, $start: Int!, $end: Int!) {\n  pricePeriodByAddresses(addresses: $addresses, start: $start, end: $end) {\n    amount\n    base\n    decimals\n    quote\n  }\n}\n    `;\nexport const usePricePeriodByAddressesQuery = <\n      TData = PricePeriodByAddressesQuery,\n      TError = unknown\n    >(\n      variables: PricePeriodByAddressesQueryVariables,\n      options?: UseQueryOptions<PricePeriodByAddressesQuery, TError, TData>\n    ) =>\n    useQuery<PricePeriodByAddressesQuery, TError, TData>(\n      ['PricePeriodByAddresses', variables],\n      useFetchData<PricePeriodByAddressesQuery, PricePeriodByAddressesQueryVariables>(PricePeriodByAddressesDocument).bind(null, variables),\n      options\n    );\nexport const SessionsDocument = `\n    query Sessions($where: SessionWhereInput!) {\n  sessions(where: $where) {\n    edges {\n      node {\n        id\n        appID\n        chainID\n        isRevoked\n        expiresAt\n        createdAt\n        updatedAt\n        metadata {\n          os\n          browser\n        }\n      }\n    }\n  }\n}\n    `;\nexport const useSessionsQuery = <\n      TData = SessionsQuery,\n      TError = unknown\n    >(\n      variables: SessionsQueryVariables,\n      options?: UseQueryOptions<SessionsQuery, TError, TData>\n    ) =>\n    useQuery<SessionsQuery, TError, TData>(\n      ['Sessions', variables],\n      useFetchData<SessionsQuery, SessionsQueryVariables>(SessionsDocument).bind(null, variables),\n      options\n    );\nexport const SignerDocument = `\n    query Signer($username: String!) {\n  account(username: $username) {\n    username\n    controllers {\n      edges {\n        node {\n          signers {\n            id\n            type\n            createdAt\n            updatedAt\n            controller {\n              id\n              accountID\n            }\n          }\n        }\n      }\n    }\n  }\n}\n    `;\nexport const useSignerQuery = <\n      TData = SignerQuery,\n      TError = unknown\n    >(\n      variables: SignerQueryVariables,\n      options?: UseQueryOptions<SignerQuery, TError, TData>\n    ) =>\n    useQuery<SignerQuery, TError, TData>(\n      ['Signer', variables],\n      useFetchData<SignerQuery, SignerQueryVariables>(SignerDocument).bind(null, variables),\n      options\n    );\nexport const ClaimFreeStarterpackDocument = `\n    mutation ClaimFreeStarterpack($input: StarterpackInput!) {\n  claimFreeStarterpack(input: $input)\n}\n    `;\nexport const useClaimFreeStarterpackMutation = <\n      TError = unknown,\n      TContext = unknown\n    >(options?: UseMutationOptions<ClaimFreeStarterpackMutation, TError, ClaimFreeStarterpackMutationVariables, TContext>) =>\n    useMutation<ClaimFreeStarterpackMutation, TError, ClaimFreeStarterpackMutationVariables, TContext>(\n      ['ClaimFreeStarterpack'],\n      useFetchData<ClaimFreeStarterpackMutation, ClaimFreeStarterpackMutationVariables>(ClaimFreeStarterpackDocument),\n      options\n    );\nexport const StarterPackDocument = `\n    query StarterPack($input: StarterpackInput!) {\n  starterpack(input: $input) {\n    starterpack {\n      name\n      description\n      active\n      issuance\n      maxIssuance\n      acquisitionType\n      starterpackContract {\n        edges {\n          node {\n            name\n            description\n            iconURL\n            contractAddress\n            supplyEntryPoint\n            supplyCalldata\n          }\n        }\n      }\n      merkleDrops {\n        edges {\n          node {\n            key\n            salt\n            network\n            contract\n            entrypoint\n            merkleRoot\n            description\n          }\n        }\n      }\n    }\n    price {\n      amount\n      decimals\n    }\n    bonusCredits {\n      amount\n      decimals\n    }\n    mintAllowance {\n      count\n      limit\n    }\n  }\n}\n    `;\nexport const useStarterPackQuery = <\n      TData = StarterPackQuery,\n      TError = unknown\n    >(\n      variables: StarterPackQueryVariables,\n      options?: UseQueryOptions<StarterPackQuery, TError, TData>\n    ) =>\n    useQuery<StarterPackQuery, TError, TData>(\n      ['StarterPack', variables],\n      useFetchData<StarterPackQuery, StarterPackQueryVariables>(StarterPackDocument).bind(null, variables),\n      options\n    );\nexport const TeamsDocument = `\n    query Teams {\n  me {\n    teams(where: {deleted: false}) {\n      totalCount\n      edges {\n        node {\n          id\n          name\n          credits\n          deployments(where: {deprecated: false}) {\n            totalCount\n            edges {\n              node {\n                project\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n    `;\nexport const useTeamsQuery = <\n      TData = TeamsQuery,\n      TError = unknown\n    >(\n      variables?: TeamsQueryVariables,\n      options?: UseQueryOptions<TeamsQuery, TError, TData>\n    ) =>\n    useQuery<TeamsQuery, TError, TData>(\n      variables === undefined ? ['Teams'] : ['Teams', variables],\n      useFetchData<TeamsQuery, TeamsQueryVariables>(TeamsDocument).bind(null, variables),\n      options\n    );\nexport const TraceabilitiesDocument = `\n    query Traceabilities($projects: [TraceabilityProject!]!) {\n  traceabilities(projects: $projects) {\n    items {\n      transfers {\n        amount\n        contractAddress\n        decimals\n        eventId\n        executedAt\n        fromAddress\n        toAddress\n        metadata\n        name\n        symbol\n        tokenId\n        transactionHash\n      }\n      meta {\n        project\n        tokenId\n        contractAddress\n        date\n        limit\n        error\n        count\n      }\n    }\n  }\n}\n    `;\nexport const useTraceabilitiesQuery = <\n      TData = TraceabilitiesQuery,\n      TError = unknown\n    >(\n      variables: TraceabilitiesQueryVariables,\n      options?: UseQueryOptions<TraceabilitiesQuery, TError, TData>\n    ) =>\n    useQuery<TraceabilitiesQuery, TError, TData>(\n      ['Traceabilities', variables],\n      useFetchData<TraceabilitiesQuery, TraceabilitiesQueryVariables>(TraceabilitiesDocument).bind(null, variables),\n      options\n    );\nexport const TransfersDocument = `\n    query Transfers($projects: [TransferProject!]!) {\n  transfers(projects: $projects) {\n    items {\n      meta {\n        project\n        address\n        date\n        limit\n        count\n      }\n      transfers {\n        amount\n        decimals\n        metadata\n        name\n        symbol\n        contractAddress\n        executedAt\n        fromAddress\n        toAddress\n        tokenId\n        eventId\n        transactionHash\n      }\n    }\n  }\n}\n    `;\nexport const useTransfersQuery = <\n      TData = TransfersQuery,\n      TError = unknown\n    >(\n      variables: TransfersQueryVariables,\n      options?: UseQueryOptions<TransfersQuery, TError, TData>\n    ) =>\n    useQuery<TransfersQuery, TError, TData>(\n      ['Transfers', variables],\n      useFetchData<TransfersQuery, TransfersQueryVariables>(TransfersDocument).bind(null, variables),\n      options\n    );\nexport const TxsHistoryDocument = `\n    query TxsHistory($username: String!) {\n  account(username: $username) {\n    activities(where: {type: TRANSACTION}) {\n      edges {\n        node {\n          id\n          paymasterID\n          type\n          status\n          network\n          transactionHash\n          feeSource\n          updatedAt\n        }\n      }\n    }\n  }\n}\n    `;\nexport const useTxsHistoryQuery = <\n      TData = TxsHistoryQuery,\n      TError = unknown\n    >(\n      variables: TxsHistoryQueryVariables,\n      options?: UseQueryOptions<TxsHistoryQuery, TError, TData>\n    ) =>\n    useQuery<TxsHistoryQuery, TError, TData>(\n      ['TxsHistory', variables],\n      useFetchData<TxsHistoryQuery, TxsHistoryQueryVariables>(TxsHistoryDocument).bind(null, variables),\n      options\n    );"]}